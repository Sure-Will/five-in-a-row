<!DOCTYPE html>
<html lang="zh-CN">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>äº”å­æ£‹æ¸¸æˆ - æŒ‘æˆ˜ç¡•ç¥</title>
Â  Â  <style>
Â  Â  Â  Â  /* CSS æ ·å¼ä¸ä¸Šä¸€ç‰ˆç›¸åŒ */
Â  Â  Â  Â  * { margin: 0; padding: 0; box-sizing: border-box; }
Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  font-family: 'Arial', 'Microsoft YaHei', sans-serif;
Â  Â  Â  Â  Â  Â  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
Â  Â  Â  Â  Â  Â  display: flex; justify-content: center; align-items: center;
Â  Â  Â  Â  Â  Â  min-height: 100vh; padding: 20px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .container {
Â  Â  Â  Â  Â  Â  background: white; border-radius: 20px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
Â  Â  Â  Â  Â  Â  padding: 30px; max-width: 850px; width: 100%;
Â  Â  Â  Â  }
Â  Â  Â  Â  h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
Â  Â  Â  Â  .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 1.1em; }
Â  Â  Â  Â  .difficulty-selector { display: flex; justify-content: center; margin-bottom: 20px; align-items: center; }
Â  Â  Â  Â  .diff-label { font-weight: bold; margin-right: 10px; font-size: 1.1em;}
Â  Â  Â  Â  .god-mode-active {
Â  Â  Â  Â  Â  Â  Â padding: 10px 20px; font-size: 1.1em; border-radius: 10px;
Â  Â  Â  Â  Â  Â  Â background: #f44336; color: white; font-weight: bold;
Â  Â  Â  Â  Â  Â  Â box-shadow: 0 2px 4px rgba(0,0,0,0.2);
Â  Â  Â  Â  }
Â  Â  Â  Â  .game-info {
Â  Â  Â  Â  Â  Â  display: flex; justify-content: space-between; align-items: center;
Â  Â  Â  Â  Â  Â  margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .current-player { font-size: 1.3em; font-weight: bold; color: #333; }
Â  Â  Â  Â  #playerTimeLeft { font-size: 0.8em; color: #f44336; margin-left: 8px; font-weight: normal; }
Â  Â  Â  Â  .player-black { color: #000; }
Â  Â  Â  Â  .player-white { color: #666; }
Â  Â  Â  Â  .controls { display: flex; gap: 10px; }
Â  Â  Â  Â  button {
Â  Â  Â  Â  Â  Â  padding: 10px 20px; font-size: 1em; border: none; border-radius: 8px;
Â  Â  Â  Â  Â  Â  cursor: pointer; transition: all 0.3s; font-weight: bold;
Â  Â  Â  Â  }
Â  Â  Â  Â  .btn-restart { background: #4caf50; color: white; }
Â  Â  Â  Â  .btn-restart:hover { background: #45a049; }
Â  Â  Â  Â  button:disabled { opacity: 0.5; cursor: not-allowed; }
Â  Â  Â  Â  .board-container { display: flex; justify-content: center; margin: 20px 0; }
Â  Â  Â  Â  #gameBoard {
Â  Â  Â  Â  Â  Â  background: #daa520; border: 3px solid #8b6914;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); cursor: pointer;
Â  Â  Â  Â  Â  Â  max-width: 100%; height: auto;
Â  Â  Â  Â  }
Â  Â  Â  Â  .winner-message {
Â  Â  Â  Â  Â  Â  text-align: center; font-size: 1.5em; font-weight: bold; color: #4caf50;
Â  Â  Â  Â  Â  Â  margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 10px; display: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  .winner-message.show { display: block; animation: slideDown 0.5s ease; }
Â  Â  Â  Â  @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
Â  Â  Â  Â  .instructions { background: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; }
Â  Â  Â  Â  .instructions h3 { color: #1976d2; margin-bottom: 10px; }
Â  Â  Â  Â  .instructions ul { list-style-position: inside; color: #333; line-height: 1.8; }
Â  Â  Â  Â  .ai-thinking { text-align: center; font-size: 1.1em; color: #ff9800; margin: 10px 0; font-weight: bold; }
Â  Â  Â  Â  .step-taunt { display: block; font-size: 0.9em; color: #e91e63; margin-top: 5px; }
Â  Â  Â  Â  .timer-container {
Â  Â  Â  Â  Â  Â  display: flex; justify-content: center; align-items: center; gap: 20px;
Â  Â  Â  Â  Â  Â  margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
Â  Â  Â  Â  Â  Â  border-radius: 10px; color: white;
Â  Â  Â  Â  }
Â  Â  Â  Â  .timer-item { text-align: center; }
Â  Â  Â  Â  .timer-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
Â  Â  Â  Â  .timer-value { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
Â  Â  Â  Â  .best-time { color: #ffd700; }
Â  Â  Â  Â  .ai-taunt { font-size: 0.8em; color: #f44336; font-weight: bold; display: block; margin-top: 10px; }
Â  Â  Â  Â  @media (max-width: 600px) {
Â  Â  Â  Â  Â  Â  .container { padding: 15px; } h1 { font-size: 1.8em; }
Â  Â  Â  Â  Â  Â  .game-info { flex-direction: column; gap: 10px; }
Â  Â  Â  Â  Â  Â  .controls { flex-wrap: wrap; justify-content: center; }
Â  Â  Â  Â  Â  Â  .timer-container { flex-direction: column; gap: 10px; } .timer-value { font-size: 1.8em; }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <div class="container">
Â  Â  Â  Â  <h1>ğŸ® äº”å­æ£‹</h1>
Â  Â  Â  Â  <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

Â  Â  Â  Â  Â <div class="difficulty-selector">
Â  Â  Â  Â  Â  Â  <span class="diff-label">å½“å‰æ¨¡å¼ï¼š</span>
Â  Â  Â  Â  Â  Â  <span class="god-mode-active">ğŸ”¥ ç¡•ç¥æ¨¡å¼</span>
Â  Â  Â  Â  </div>


Â  Â  Â  Â  <div class="game-info">
Â  Â  Â  Â  Â  Â  <div class="current-player" id="currentPlayer">
Â  Â  Â  Â  Â  Â  Â  Â  å½“å‰ç©å®¶ï¼š<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span id="playerTimeLeft"></span>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="controls">
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="ai-thinking" id="aiThinking" style="display: none;">ğŸ¤– AIæ€è€ƒä¸­...</div>

Â  Â  Â  Â  <div class="timer-container">
Â  Â  Â  Â  Â  Â  <div class="timer-item">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-value" id="currentTime">00:00</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="timer-item">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-label">ğŸ† æœ€ä½³è®°å½• (ç¡•ç¥æ¨¡å¼)</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-value best-time" id="bestTime">--:--</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="winner-message" id="winnerMessage"></div>

Â  Â  Â  Â  <div class="board-container">
Â  Â  Â  Â  Â  Â  <canvas id="gameBoard"></canvas>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="instructions">
Â  Â  Â  Â  Â  Â  <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
Â  Â  Â  Â  Â  Â  <ul id="rules-list">
Â  Â  Â  Â  Â  Â  Â  Â  {/* Rules will be added by JS */}
Â  Â  Â  Â  Â  Â  </ul>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <script id="ai-worker-script" type="text/worker-script">
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- Worker å†…çš„å…¨å±€å˜é‡ ---
Â  Â  Â  Â  let board, boardSize, maxDepth;Â 
Â  Â  Â  Â  let zobristTable, currentHash, moveHistory;
Â  Â  Â  Â  let transpositionTable = new Map();
Â  Â  Â  Â Â 
Â  Â  Â  Â  const TIMEOUT_MS = 10000; // 10 ç§’ AI ç†”æ–­
Â  Â  Â  Â  const openingBook = new Map(); // å¼€å±€åº“

Â  Â  Â  Â  // --- æ ¸å¿ƒå…¥å£ï¼šæ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯ ---
Â  Â  Â  Â  self.onmessage = function(e) {
Â  Â  Â  Â  Â  Â  const data = e.data;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 1. æ›´æ–° Worker çš„å†…éƒ¨çŠ¶æ€
Â  Â  Â  Â  Â  Â  board = data.board;
Â  Â  Â  Â  Â  Â  boardSize = data.boardSize;
Â  Â  Â  Â  Â  Â  maxDepth = data.maxDepth; // ç¡•ç¥(6)
Â  Â  Â  Â  Â  Â  zobristTable = data.zobristTable;
Â  Â  Â  Â  Â  Â  currentHash = data.currentHash;
Â  Â  Â  Â  Â  Â  moveHistory = data.moveHistory;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. æ¯æ¬¡ AI æ€è€ƒæ—¶ï¼Œéƒ½é‡ç½®ç½®æ¢è¡¨
Â  Â  Â  Â  Â  Â  transpositionTable.clear();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const startTime = performance.now();
Â  Â  Â  Â  Â  Â  let moveResult = {};Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 3. å§‹ç»ˆè°ƒç”¨ç¡•ç¥æ¨¡å¼çš„è¿­ä»£åŠ æ·±
Â  Â  Â  Â  Â  Â  console.log(`[Worker] Starting IDDFS search up to depth ${maxDepth}`);
Â  Â  Â  Â  Â  Â  moveResult = getBestMoveIDDFS(startTime, maxDepth);Â 
Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] IDDFS finished. Result depth: ${moveResult.depth}, Move:`, moveResult.move);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const endTime = performance.now();
Â  Â  Â  Â  Â  Â  const duration = ((endTime - startTime) / 1000).toFixed(2);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 4. å°†ç»“æœå‘å›ä¸»çº¿ç¨‹
Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Posting result back to main thread.`);
Â  Â  Â  SÂ  Â  Â  self.postMessage({Â 
Â  Â  Â  Â  Â  Â  Â  Â  move: moveResult.move,Â 
Â  Â  Â  Â  Â  Â  Â  Â  duration: duration,Â 
Â  Â  Â  Â  Â  Â  Â  Â  depth: moveResult.depthÂ 
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- AI ç®—æ³• ---
Â  Â  Â  Â Â 
Â  Â  Â  Â  function getHardMove() { // ä½œä¸º IDDFS è¶…æ—¶æˆ–å¼€å±€åº“/å¼ºåˆ¶æ£€æŸ¥æœªå‘½ä¸­æ—¶çš„å¤‡ç”¨
Â  Â  Â  Â  Â  Â  console.log("[Worker] Calculating fallback 'Hard' move.");
Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  let bestMove = null;
Â  Â  Â  Â  Â  Â  // 1. æ£€æŸ¥AIå¿…èƒœ
Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 2; // AI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(i, j)) { board[i][j] = 0; console.log("[Worker] HardMove found AI win."); return { row: i, col: j }; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // 2. æ£€æŸ¥ç©å®¶å¿…èƒœ (é˜²å®ˆ)
Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 1; // ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(i, j)) { board[i][j] = 0; console.log("[Worker] HardMove found block."); return { row: i, col: j }; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // 3. æ­£å¸¸è¯„åˆ†
Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const score = evaluatePositionAdvanced(i, j);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score > bestScore) { bestScore = score; bestMove = { row: i, col: j }; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â // ä¿åº•éšæœºèµ°æ³•
Â  Â  Â  Â  Â  Â  const emptyPositions = [];
Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) emptyPositions.push({ row: i, col: j }); } }
Â  Â  Â  Â  Â  Â  const finalMove = bestMove || (emptyPositions.length > 0 ? emptyPositions[Math.floor(Math.random() * emptyPositions.length)] : null);
Â  Â  Â  Â  Â  Â  Â console.log("[Worker] HardMove final choice:", finalMove);
Â  Â  Â  Â  Â  Â  Â return finalMove;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // è¿­ä»£åŠ æ·± (IDDFS) å…¥å£ - åŒ…å«å¼€å±€åº“å’Œå¼ºåˆ¶ç»ˆç»“æ£€æŸ¥
Â  Â  Â  Â  function getBestMoveIDDFS(startTime, maxDepth) {
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // [å¼€å±€åº“] æ£€æŸ¥å¼€å±€åº“ (é™åˆ¶åœ¨ 8 æ­¥å†…)
Â  Â  Â  Â  Â  Â  const bookMove = getOpeningMove(); // Opening move check simplified
Â  Â  Â  Â  Â  Â  if (bookMove && moveHistory.length < 8) {
Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Worker] Using opening book move!");
Â  Â  Â  Â  Â  Â  Â  Â  if (board[bookMove.row][bookMove.col] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return { move: bookMove, depth: 1, timedOut: false };
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Worker] Opening book move is invalid, recalculating.");
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // [å¼ºåˆ¶ç»ˆç»“] æ£€æŸ¥ AI æ˜¯å¦èƒ½ä¸€æ­¥è·èƒœæˆ–éœ€è¦é˜²å®ˆ
            // [ä¿®å¤BUG] æ­¤æ—¶ä¸åº”æ’åºï¼Œä¸”åº”ä¼ å…¥ startTime ä»¥é˜²ä¸‡ä¸€
Â  Â  Â  Â  Â  Â  const validMovesCheck = getValidMoves(false, startTime); 
Â  Â  Â  Â  Â  Â  let immediateAiWinMove = null;
Â  Â  Â  Â  Â  Â  let immediatePlayerBlockMove = null;

Â  Â  Â  Â  Â  Â  for (const move of validMovesCheck) {
                // [ä¿®å¤BUG] å¢åŠ è¶…æ—¶æ£€æŸ¥
                if ((performance.now() - startTime) > TIMEOUT_MS) {
                    console.warn("[Worker] Timeout during immediate win/loss check.");
                    break;
                }
Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥ AI è·èƒœ
Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, 2); // æ¨¡æ‹Ÿ AI è½å­
Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  immediateAiWinMove = { row: move.row, col: move.col };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 2); // æ’¤é”€æ¨¡æ‹Ÿ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // æ‰¾åˆ°ä¸€ä¸ªå³å¯
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 2); // æ’¤é”€æ¨¡æ‹Ÿ

Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥ç©å®¶è·èƒœ (AI éœ€è¦é˜²å®ˆ) - ä»…å½“æ²¡æ‰¾åˆ° AI å¿…èƒœæ—¶æ£€æŸ¥
Â  Â  Â  Â  Â  Â  Â  Â  if (!immediateAiWinMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â _simulateMove(move.row, move.col, 1); // æ¨¡æ‹Ÿç©å®¶è½å­
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // æ‰¾åˆ°ç¬¬ä¸€ä¸ªéœ€è¦é˜²å®ˆçš„ç‚¹å°±å¤Ÿäº†ï¼Œå› ä¸ºAIå¿…èƒœä¼˜å…ˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!immediatePlayerBlockMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â immediatePlayerBlockMove = { row: move.row, col: move.col };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â _simulateUndo(move.row, move.col, 1); // æ’¤é”€æ¨¡æ‹Ÿ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â _simulateUndo(move.row, move.col, 1); // æ’¤é”€æ¨¡æ‹Ÿ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // å¦‚æœæ‰¾åˆ° AI å¿…èƒœæ£‹
Â  Â  Â  Â  Â  Â  if (immediateAiWinMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Worker] Found immediate AI win!");
Â  Â  Â  Â  Â  Â  Â  Â  Â return { move: immediateAiWinMove, depth: 1, timedOut: false };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // å¦‚æœæ‰¾åˆ°éœ€è¦ç«‹å³é˜²å®ˆçš„æ£‹ (ä¸”æ²¡æœ‰AIå¿…èƒœæ£‹)
Â  Â  Â  Â  Â  Â  if (immediatePlayerBlockMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Worker] Found immediate block required!");
Â  Â  Â  Â  Â  Â  Â  Â  Â return { move: immediatePlayerBlockMove, depth: 1, timedOut: false };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- å¦‚æœæ²¡æœ‰å¼€å±€åº“å‘½ä¸­å’Œå¼ºåˆ¶ç»ˆç»“ï¼Œåˆ™å¼€å§‹ IDDFS ---
Â  Â  Â  Â  Â  Â  console.log("[Worker] No immediate win/loss/book. Starting IDDFS.");
Â  Â  Â  Â  Â  Â  let bestMove = null;
Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  let completedDepth = 0;

Â  Â  Â  Â  Â  Â  // è¿­ä»£åŠ æ·±: æœç´¢æ·±åº¦ 2, 4, 6, ... ç›´åˆ° maxDepth
Â  Â  Â  Â  Â  Â  for (let d = 2; d <= maxDepth; d += 2) {
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > TIMEOUT_MS) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[Worker] Timeout before starting depth ${d}.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Starting search at depth ${d}`);

Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

Â  Â  Â  Â  Â  Â  Â  Â  if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Search timed out at depth ${d}.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // æœ¬æ¬¡æ·±åº¦æœç´¢(d)æˆåŠŸå®Œæˆã€‚ä¿å­˜ç»“æœã€‚
Â  Â  Â  Â  Â  Â  Â  Â  if (result.move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = result.move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  completedDepth = d;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Depth ${d} complete. Best move: ${result.move.row},${result.move.col}. Score: ${result.score}`);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn(`[Worker] Minimax returned null move at depth ${d}. Stopping iteration.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (bestScore > 9000000) { // æ‰¾åˆ°å¿…èƒœ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Found winning move at depth ${d}. Stopping iteration.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¦‚æœè¶…æ—¶æˆ–æœç´¢æœªå®Œæˆï¼Œè¿”å›ä¸Šä¸€ä¸ªæ·±åº¦çš„ç»“æœæˆ–ä¿åº•
Â  Â  Â  Â  Â  Â  if (bestMove === null) {
Â  Â  Â  Â  Â  Â  Â  Â  console.warn("[Worker] IDDFS couldn't find a move (timeout likely or no valid moves), using hard move fallback.");
Â  Â  Â  Â  Â  Â  Â  Â  bestMove = getHardMove();Â 
Â  Â  Â  Â  Â  Â  Â  Â  completedDepth = completedDepth || 1;Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â console.log(`[Worker] Final IDDFS result: Depth ${completedDepth}, Move:`, bestMove);
Â  Â  Â  Â  Â  Â  return { move: bestMove, score: bestScore, depth: completedDepth };
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ ¸å¿ƒï¼šå¸¦ Alpha-Beta å‰ªæçš„ Minimax
Â  Â  Â  Â  function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > TIMEOUT_MS) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: 0, timedOut: true };Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const hash = currentHash;
Â  Â  Â  Â  Â  Â  const cached = transpositionTable.get(hash);
Â  Â  Â  Â  Â  Â  if (cached && cached.depth >= depth) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: cached.score, timedOut: false };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (depth === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const score = evaluateBoardHeuristic(startTime); // [ä¿®å¤BUG] è¯„ä¼°ä¹Ÿå¯èƒ½è¶…æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  return { score: score, timedOut: false };
Â  Â  Â  Â  Â  Â  }

            // ==========================================================
Â  Â  Â  Â  Â  Â  // [BUG ä¿®å¤] å°† startTime ä¼ é€’ç»™ getValidMoves
Â  Â  Â  Â  Â  Â  const validMoves = getValidMoves(true, startTime); // true = å¸¦æ’åº
            // ==========================================================

Â  Â  Â  Â  Â  Â  if (validMoves.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: 0, timedOut: false }; // å¹³å±€
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  let bestMove = null; // Important: Initialize bestMove for this level
Â  Â  Â  Â  Â  Â  let timedOut = false;

Â  Â  Â  Â  Â  Â  if (isMaximizingPlayer) {
Â  Â  Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  Â  Â  // Don't set bestMove = validMoves[0] here, let the loop find the first valid one

Â  Â  Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, 2); // AI (2)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 10000000 + depth; // å¿…èƒœ (10M)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timedOut = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timedOut) return { score: 0, timedOut: true };Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score > bestScore) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = move; // Update best move when score improves
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alpha = Math.max(alpha, bestScore);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (beta <= alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // å‰ªæ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â // Ensure bestMove is assigned if loop runs
Â  Â  Â  Â  Â  Â  Â  Â  Â bestMove = bestMove || validMoves[0]; // Fallback if all moves pruned? Should be rare with proper ordering.
Â  Â  Â  Â  Â  Â  Â  Â  transpositionTable.set(hash, { depth: depth, score: bestScore });
Â  Â  Â  Â  Â  Â  Â  Â  return { score: bestScore, move: bestMove, timedOut: false };
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } else { // è½®åˆ° Min (ç©å®¶)
Â  Â  Â  Â  Â  Â  Â  Â  let bestScore = +Infinity;
Â  Â  Â  Â  Â  Â  Â  Â  Â // Don't set bestMove = validMoves[0] here

Â  Â  Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, 1); // ç©å®¶ (1)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = -10000000 - depth; // å¿…è´¥ (-10M)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timedOut = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 1);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timedOut) return { score: 0, timedOut: true };Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score < bestScore) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = move; // Update best move for min player
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  beta = Math.min(beta, bestScore);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (beta <= alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // å‰ªæ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â // Ensure bestMove is assigned
Â  Â  Â  Â  Â  Â  Â  Â  Â bestMove = bestMove || validMoves[0]; // Fallback
Â  Â  Â  Â  Â  Â  Â  Â  transpositionTable.set(hash, { depth: depth, score: bestScore });
Â  Â  Â  Â  Â  Â  Â  Â  return { score: bestScore, move: bestMove, timedOut: false };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ¨¡æ‹Ÿè½å­
Â  Â  Â  Â  function _simulateMove(row, col, player) {
Â  Â  Â  Â  Â  Â  board[row][col] = player;
Â  Â  Â  Â  Â  Â  currentHash ^= zobristTable[row][col][player - 1];
Â  Â  Â  Â  }
Â  Â  Â  Â  // æ¨¡æ‹Ÿæ‚”æ£‹
Â  Â  Â  Â  function _simulateUndo(row, col, player) {
Â  Â  Â  Â  Â  Â  board[row][col] = 0;
Â  Â  Â  Â  Â  Â  currentHash ^= zobristTable[row][col][player - 1];
Â  Â  Â  Â  }

Â  Â  Â  Â  // å¼€å±€åº“ - ç¡•ç¥æ¨¡å¼ä¸“ç”¨ (AI å…ˆæ‰‹)
Â  Â  Â  Â  function getOpeningMove() {
Â  Â  Â  Â  Â  Â  // [å¼€å±€åº“.2] ä» openingBook Map ä¸­æŸ¥æ‰¾
Â  Â  Â  Â  Â  Â  return openingBook.get(currentHash);
Â  Â  Â  Â  }

Â  Â  Â  Â  // è·å–æœ‰æ•ˆèµ°æ³•
        // ==========================================================
        // [BUG ä¿®å¤] å¢åŠ  startTime å‚æ•°
        // ==========================================================
Â  Â  Â  Â  function getValidMoves(withOrdering = false, startTime = 0) {
Â  Â  Â  Â  Â  Â  Â const moveSet = new Set();
Â  Â  Â  Â  Â  Â  Â const center = Math.floor(boardSize / 2);
Â  Â  Â  Â  Â  Â  Â if (moveHistory.length === 0) return [{ row: center, col: center }];
Â  Â  Â  Â  Â  Â  Â if (moveHistory.length === 1) { // ç©å®¶ç¬¬ä¸€æ­¥
Â  Â  Â  Â  Â  Â  Â  Â  Â const moves = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â for(let dr = -1; dr <= 1; dr++) { for(let dc = -1; dc <=1; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const r = center + dr; const c = center + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) moves.push({row: r, col: c});
Â  Â  Â  Â  Â  Â  Â  Â  Â }}Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â // [å¼€å±€ä¼˜åŒ–] ç©å®¶ç¬¬ä¸€æ­¥ä¹Ÿå¯ä»¥é€‰æ‹©æ›´è¿œçš„ä½ç½®ï¼Œä¸é™åˆ¶
Â  Â  Â  Â  Â  Â  Â  Â  Â // return moves;Â 
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â const radius = 2; // æ­£å¸¸æœç´¢
Â  Â  Â  Â  Â  Â  Â for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[r][c] === 0) continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â for (let dr = -radius; dr <= radius; dr++) { for (let dc = -radius; dc <= radius; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const nr = r + dr; const nc = c + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc] === 0) moveSet.add(`${nr},${nc}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â }}
Â  Â  Â  Â  Â  Â  Â }}
Â  Â  Â  Â  Â  Â  Â if (moveSet.size === 0) { // ä¿åº•ï¼šè¿”å›æ‰€æœ‰ç©ºç‚¹
Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { if (board[r][c] === 0) moveSet.add(`${r},${c}`); }}
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â const moves = Array.from(moveSet).map(s => { const [row, col] = s.split(',').map(Number); return { row, col }; });
Â  Â  Â  Â  Â  Â  Â 
                  if (withOrdering) { // æ’åº
Â  Â  Â  Â  Â  Â  Â  Â  Â  // [BUG ä¿®å¤] å°† .map ä¿®æ”¹ä¸º for å¾ªç¯ï¼Œä»¥ä¾¿æ’å…¥è¶…æ—¶æ£€æŸ¥
                    const scoredMoves = [];
                    for (const move of moves) {
                        // [BUG ä¿®å¤] æ£€æŸ¥æ˜¯å¦è¶…æ—¶
                        if (startTime > 0 && (performance.now() - startTime) > TIMEOUT_MS) {
                            console.warn("[Worker] Timeout during move ordering.");
                            // å¦‚æœè¶…æ—¶ï¼Œç«‹å³è¿”å›æœªæ’åºçš„æ£‹æ­¥ï¼ˆæˆ–è€…éƒ¨åˆ†æ’åºçš„ï¼‰
                            // è¿”å›æœªæ’åºçš„ moves æ›´å®‰å…¨
                            return moves; 
                        }
                        scoredMoves.push({ move, score: evaluatePositionAdvanced(move.row, move.col) });
                    }
                    
Â  Â  Â  Â  Â  Â  Â  Â  Â  scoredMoves.sort((a, b) => b.score - a.score); 
                    return scoredMoves.map(item => item.move);
Â  Â  Â  Â  Â  Â  Â  } 
                  return moves;
Â  Â  Â  Â  }

Â  Â  Â  Â  // é™æ€æ£‹ç›˜è¯„ä¼°
Â  Â  Â  Â  function evaluateBoardHeuristic(startTime = 0) { // [ä¿®å¤BUG] å¢åŠ  startTime
Â  Â  Â  Â  Â  Â  Â let totalScore = 0; 
            // [ä¿®å¤BUG] ä¼ é€’ startTime
            const validMoves = getValidMoves(false, startTime); 
Â  Â  Â  Â  Â  Â  Â for (const move of validMoves) {
                // [ä¿®å¤BUG] å¢åŠ è¶…æ—¶æ£€æŸ¥
                if (startTime > 0 && (performance.now() - startTime) > TIMEOUT_MS) {
                    console.warn("[Worker] Timeout during evaluateBoardHeuristic.");
                    return totalScore; // è¿”å›å½“å‰å¾—åˆ†
                }
                totalScore += evaluatePositionAdvanced(move.row, move.col); 
            }
Â  Â  Â  Â  Â  Â  Â return totalScore;
Â  Â  Â  Â  }

Â  Â  Â  Â  // è¯„ä¼°ç©ºç‚¹ä»·å€¼ (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
Â  Â  Â  Â  function evaluatePositionAdvanced(row, col) {
Â  Â  Â  Â  Â  Â  let score = 0; const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  const aiScore = evaluateLine(row, col, dr, dc, 2); const playerScore = evaluateLine(row, col, dr, dc, 1);
Â  Â  Â  Â  Â  Â  Â  Â  score += aiScore + (playerScore * 1.1);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const center = Math.floor(boardSize / 2); const distToCenter = Math.abs(row - center) + Math.abs(col - center);
Â  Â  Â  Â  Â  Â  score += (boardSize - distToCenter) * 0.5; return score;
Â  Â  Â  Â  }

Â  Â  Â  Â  // è¯„ä¼°è¿ç æƒ…å†µ (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
Â  Â  Â  Â  function evaluateLine(row, col, dr, dc, player) {
Â  Â  Â  Â  Â  Â  Â let count = 0; let blocks = 0;
Â  Â  Â  Â  Â  Â  Â for (let i = 1; i <= 4; i++) { // æ­£å‘
Â  Â  Â  Â  Â  Â  Â  Â  Â const r = row + dr * i; const c = col + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â for (let i = 1; i <= 4; i++) { // åå‘
Â  Â  Â  Â  Â  Â  Â  Â  Â const r = row - dr * i; const c = col - dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â if (count >= 4) return 10000000; if (count === 3 && blocks === 0) return 1000000;
Â  Â  Â  Â  Â  Â  Â if (count === 2 && blocks === 0) return 50000; if (count === 3 && blocks === 1) return 10000;
Â  Â  Â  Â  Â  Â  Â if (count === 2 && blocks === 1) return 500; if (count === 1 && blocks === 0) return 100;
Â  Â  Â  Â  Â  Â  Â if (count === 1 && blocks === 1) return 10; return 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ£€æŸ¥èƒœåˆ© (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
Â  Â  Â  Â  function checkWin(row, col) {
Â  Â  Â  Â  Â  Â  Â const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ]; const player = board[row][col]; if (player === 0) return false;
Â  Â  Â  Â  Â  Â  Â for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let count = 1; let r = row + dr, c = col + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r += dr; c += dc; }
Â  Â  Â  Â  Â  Â  Â  Â  Â r = row - dr; c = col - dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r -= dr; c -= dc; }
Â  Â  Â  Â  Â  Â  Â  Â  Â if (count >= 5) return true;
Â  Â  Â  Â  Â  Â  Â } return false;
Â  Â  Â  Â  }

Â  Â  </script>
Â  Â Â 
Â  Â  <script>
Â  Â  Â  Â  class GomokuGame {
Â  Â  Â  Â  Â  Â  constructor() {Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.boardSize = 15; // å›ºå®šä¸º 15
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const maxCanvasWidth = 500;
Â  Â  Â  Â  Â  Â  Â  Â  this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

Â  Â  Â  Â  Â  Â  Â  Â  this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®å¤å¡æ­».1] åˆå§‹ currentPlayer è®¾ä¸º 2 (AI)ï¼Œç­‰å¾… AI å®Œæˆç¬¬ä¸€æ­¥
Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.winner = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.gameMode = 'ai'; // å›ºå®šä¸º AI
Â  Â  Â  Â  Â  Â  Â  Â  this.difficulty = 'god'; // å›ºå®šä¸º god
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // è®¡æ—¶å™¨ç›¸å…³
Â  Â  Â  Â  Â  Â  Â  Â  this.startTime = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.elapsedTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimerId = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft = 10; // ç§’

Â  Â  Â  Â  Â  Â  Â  Â  this.canvas = document.getElementById('gameBoard');
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = this.canvas.getContext('2d');

Â  Â  Â  Â  Â  Â  Â  Â  // AI æ ¸å¿ƒ
Â  Â  Â  Â  Â  Â  Â  Â  this.GOD_DEPTH = 6;Â  Â  Â  Â // ç¥(6)
Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.initZobrist();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // åˆå§‹åŒ– Web Worker
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const workerScript = document.getElementById('ai-worker-script').textContent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blob = new Blob([workerScript], { type: 'application/javascript' });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker = new Worker(URL.createObjectURL(blob));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker.onmessage = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.receiveAiMove(e.data);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // æ·»åŠ  Worker é”™è¯¯å¤„ç†
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker.onerror = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error("AI Worker Error:", e.message, e);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â alert("AI çº¿ç¨‹å‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.innerHTML = `âŒ AI é”™è¯¯! è¯·åˆ·æ–°.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.gameOver = true; // åœæ­¢æ¸¸æˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("æ— æ³•åˆ›å»º AI Worker: ", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alert("åŠ è½½AIçº¿ç¨‹å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§æˆ–åˆ·æ–°é¡µé¢ã€‚");
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  this.initCanvas();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  Â  Â  this.loadBestTime();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®å¤å¡æ­».2] æ„é€ å‡½æ•°ä¸å†è°ƒç”¨ performAiFirstMove
Â  Â  Â  Â  Â  Â  Â  Â  // å®ƒå°†åœ¨ DOMContentLoaded ä¸­è¢«è°ƒç”¨
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // AI ç¬¬ä¸€æ­¥é€»è¾‘
Â  Â  Â  Â  Â  Â  performAiFirstMove() {
Â  Â  Â  Â  Â  Â  Â  Â  // ç¡®ä¿åªåœ¨æ¸¸æˆå¼€å§‹æ—¶æ‰§è¡Œä¸€æ¬¡
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length === 0 && !this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const center = Math.floor(this.boardSize / 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[center][center] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] AI performs instant first move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ç›´æ¥ä¿®æ”¹çŠ¶æ€ï¼Œä¸é€šè¿‡ makeMoveÂ 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[center][center] = 2; // AI (ç™½æ£‹) è½å­
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory.push({ row: center, col: center, player: 2 });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash ^= this.zobristTable[center][center][1]; // æ›´æ–°å“ˆå¸Œ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 1; // è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // é‡ç»˜æ£‹ç›˜
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°UIæ˜¾ç¤ºè½®åˆ°ç©å®¶ (æ­¤æ—¶è¿˜ä¸è®¡æ—¶)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] AI first move complete. Current player:", this.currentPlayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("[Main] Center is not empty for AI first move?");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] performAiFirstMove called but not applicable (history:", this.moveHistory.length, "gameOver:", this.gameOver, ")");
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // åˆå§‹åŒ– Zobrist å“ˆå¸Œè¡¨ (ä¸»çº¿ç¨‹)
Â  Â  Â  Â  Â  Â  initZobrist() {
Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable = Array(this.boardSize).fill(null).map(() =>Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Array(this.boardSize).fill(null).map(() =>Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Array(2).fill(null) // 2ä¸ªç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let k = 0; k < 2; k++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  initCanvas() {
Â  Â  Â  Â  Â  Â  Â  Â  const size = this.cellSize * (this.boardSize + 1);
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.width = size;
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.height = size;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawBoard() {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const cellSize = this.cellSize;
Â  Â  Â  Â  Â  Â  Â  Â  const boardSize = this.boardSize;

Â  Â  Â  Â  Â  Â  Â  Â  // æ¸…ç©ºç”»å¸ƒ
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#daa520';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶ç½‘æ ¼çº¿
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(cellSize, cellSize * (i + 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(cellSize * (i + 1), cellSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½ (15x15)
Â  Â  Â  Â  Â  Â  Â  Â  const drawDot = (x, y) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
Â  Â  Â  Â  Â  Â  Â  Â  drawDot(11, 11); drawDot(7, 7);Â 

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶æ£‹å­
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[i][j] !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPiece(i, j, this.board[i][j]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lastMove = this.moveHistory[this.moveHistory.length - 1];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lastMove.player === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.highlightLastMove(lastMove.row, lastMove.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawPiece(row, col, player) {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const x = this.cellSize * (col + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const y = this.cellSize * (row + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const radius = this.cellSize * 0.4;

Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x, y, radius, 0, Math.PI * 2);

Â  Â  Â  Â  Â  Â  Â  Â  if (player === 1) { // ç©å®¶é»‘æ£‹
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = gradient;
Â  Â  Â  Â  Â  Â  Â  Â  } else { // AI ç™½æ£‹
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = gradient;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  highlightLastMove(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const x = this.cellSize * (col + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const y = this.cellSize * (row + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const radius = this.cellSize * 0.15;Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x, y, radius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#FF0000';Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.clickHandler) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.removeEventListener('click', this.clickHandler);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.clickHandler = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentPlayer === 2) return; // AI å›åˆä¸èƒ½ç‚¹
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Player clicked.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rect = this.canvas.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scaleX = this.canvas.width / rect.width;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scaleY = this.canvas.height / rect.height;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const canvasX = (e.clientX - rect.left) * scaleX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const canvasY = (e.clientY - rect.top) * scaleY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const col = Math.round(canvasX / this.cellSize) - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const row = Math.round(canvasY / this.cellSize) - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidMove(row, col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Main] Player making move at ${row}, ${col}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(row, col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Main] Invalid move clicked at ${row}, ${col}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.addEventListener('click', this.clickHandler);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isValidMove(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return this.board[row][col] === 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ç©å®¶æˆ–AIçš„ *çœŸå®* è½å­
Â  Â  Â  Â  Â  Â  makeMove(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[Main] makeMove called by player ${this.currentPlayer} at ${row}, ${col}`);
Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶è½å­ï¼Œåœæ­¢è®¡æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver && this.currentPlayer === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ¸¸æˆæ€»è®¡æ—¶åœ¨ç©å®¶ä¸‹ç¬¬ä¸€æ­¥åå¼€å§‹ (moveHistory ä» 0 (AI) -> 1 (ç©å®¶) æ—¶)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length === 1 && this.currentPlayer === 1) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Starting main game timer.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.startTimer(); // æ¸¸æˆæ€»è®¡æ—¶å¼€å§‹
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.board[row][col] = this.currentPlayer;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory.push({ row, col, player: this.currentPlayer });
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard();

Â  Â  Â  Â  Â  Â  Â  Â  if (this.checkWin(row, col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[Main] Player ${this.currentPlayer} wins!`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.winner = this.currentPlayer;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showWinner();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.isBoardFull()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Board is full, draw!");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showDraw();
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const previousPlayer = this.currentPlayer;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[Main] Switched player. Current player is now: ${this.currentPlayer}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // è½®åˆ° AI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentPlayer === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // AI ä¸‹æ£‹å‰å…ˆæ›´æ–° UIï¼Œæ˜¾ç¤ºè½®åˆ° AI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.updateCurrentPlayer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Calling aiMove...");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.aiMove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰åœ¨ç©å®¶ä¸‹äº†ç¬¬ä¸€æ­¥æ£‹ä¹‹å (å³ history >= 2) æ‰å¯åŠ¨è®¡æ—¶å™¨
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Starting player timer.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.startPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶ç¬¬ä¸€æ­¥åï¼Œä¸å¯åŠ¨è®¡æ—¶å™¨ï¼Œä½†éœ€è¦æ›´æ–° UI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Player's turn after AI's first move. Updating UI.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // aiMove äº¤ç»™ Web Worker
Â  Â  Â  Â  Â  Â  aiMove() {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver || this.currentPlayer !== 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Main] aiMove called incorrectly. Game Over:", this.gameOver, "Current Player:", this.currentPlayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â }

Â  Â  Â  Â  Â  Â  Â  Â  const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â // å›ºå®šä¸ºç¡•ç¥æ¨¡å¼çš„æç¤º
Â  Â  Â  Â  Â  Â  Â  Â  let thinkingText = `ğŸ”¥ ç¡•ç¥æ€è€ƒä¸­... (è¿­ä»£è‡³D:${this.GOD_DEPTH}, 10sç†”æ–­)`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = thinkingText;
Â  Â  Â  Â  Â  Â  Â  _InternalReset;
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.style.display = 'block';

Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Posting message to AI worker.");
Â  Â  Â  Â  Â  Â  Â  Â  // å°†å½“å‰çŠ¶æ€å‘ç»™ Worker çº¿ç¨‹
Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker.postMessage({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board: this.board,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  boardSize: this.boardSize,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  difficulty: 'god', // å›ºå®šä¸º god
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxDepth: this.GOD_DEPTH, // ä¼ é€’æœ€å¤§æ·±åº¦
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zobristTable: this.zobristTable,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentHash: this.currentHash,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveHistory: this.moveHistory
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ¥æ”¶ Worker çš„è®¡ç®—ç»“æœ
Â  Â  Â  Â  Â  Â  receiveAiMove(moveData) {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Received message from AI worker:", moveData);
Â  Â  Â  Â  Â  Â  Â  Â  const { move, duration, depth } = moveData;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // å¦‚æœæ¸¸æˆå·²ç»ç»“æŸäº†ï¼ˆæ¯”å¦‚ç©å®¶åœ¨AIæ€è€ƒæ—¶åˆ·æ–°æˆ–é‡å¼€ï¼‰ï¼Œåˆ™ä¸å¤„ç†AIç»“æœ
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Game over, ignoring AI move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â // å¢åŠ æ£€æŸ¥ï¼šç¡®ä¿ç°åœ¨ç¡®å®è½®åˆ° AI
Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentPlayer !== 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn("[Main] Received AI move but it's not AI's turn? Current player:", this.currentPlayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  _InternalReset;
Â  Â  Â  Â  Â  Â  Â  Â  const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let depthStr = (depth > 1) ? `(D:${depth})` : '';Â 
Â  Â  Â  Â  Â  Â  Â  Â  let durationText = `(ç”¨æ—¶ ${duration}s)`;
Â  Â  Â  Â  Â  Â  Â  Â  // TIMEOUT_MS åœ¨ Worker ä¸­å®šä¹‰ï¼Œè¿™é‡Œç”¨å­—é¢é‡
Â  Â  Â  Â  Â  Â  Â  Â  if (parseFloat(duration) >= 10.0) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  durationText = `(è¶…æ—¶ ${duration}s, è¿”å›D:${depth}ç»“æœ)`;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [å˜²è®½] å‡†å¤‡å˜²è®½è¯­å½•
Â  Â  Â  Â  Â  Â  Â  Â  const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
Â  Â  Â  Â  Â  Â  Â  Â  const target = targets[Math.floor(Math.random() * targets.length)];
Â  Â  Â  Â  Â  Â  Â  Â  let stepTaunts = [ // ç¡•ç¥ä¸“å±å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `ç¥ä¹‹ä¸€æ‰‹ã€‚åˆ°ä½ äº†, ${target}ã€‚`,
Â  Â  _InternalReset;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `ä½ è¿˜æœ‰ ${10 - Math.ceil(parseFloat(duration))} ç§’æ¥æ£æ‘©åœ£æ„, ${target}ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, ä½ å·²ç»è¾“äº†, åªæ˜¯è¿˜æ²¡æ„è¯†åˆ°ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `å®Œç¾çš„é˜²å®ˆï¼Œæ— æ‡ˆå¯å‡»çš„è¿›æ”»ã€‚é¢¤æŠ–å§, ${target}ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æˆ‘çœ‹åˆ°äº† ${depth} å±‚ä¹‹åçš„ä¸–ç•Œ, ${target}, ä½ å‘¢ï¼Ÿ`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æ”¾å¼ƒå§, ${target}, èƒœè´Ÿå·²å®šã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `å¼±å°çš„äººç±»${target}, ä½ çš„ç­–ç•¥æ¼æ´ç™¾å‡ºã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æ˜¯ä¸æ˜¯å¾ˆç»æœ›å•Š, ${target}ï¼Ÿ`
Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  const stepTaunt = stepTaunts[Math.floor(Math.random() * stepTaunts.length)];
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ˜¾ç¤ºä¿¡æ¯ + å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = `âœ… AIè½å­ ${depthStr} ${durationText} <span class="step-taunt">${stepTaunt}</span>`;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œå¹¶ä¸”å½“å‰å¿…é¡»è½®åˆ° AI (player 2)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver && this.currentPlayer === 2 && this.isValidMove(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log(`[Main] AI making move at ${move.row}, ${move.col}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(move.row, move.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!this.gameOver && this.currentPlayer === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error("[Main] AI Worker returned an invalid move:", move, "Current board state prevents it.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const randomMove = this.getRandomMoveForMainThread();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(randomMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Main] AI making random fallback move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.makeMove(randomMove.row, randomMove.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("[Main] AI cannot make a random move either (board full?).");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showDraw(); // Or handle error appropriately
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  _InternalReset;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Ignoring AI move received after turn changed or game ended. Current player:", this.currentPlayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Main] AI Worker returned null move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ? (AIæ— æ£‹å¯èµ°)';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ä¸»çº¿ç¨‹çš„ä¿åº•éšæœºèµ°æ³• (ç”¨äºç©å®¶è¶…æ—¶)
Â  Â  Â  Â  Â  Â  getRandomMoveForMainThread() {
Â  Â  Â  Â  Â  Â  Â  Â  Â const emptyPositions = [];
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emptyPositions.push({ row: i, col: j });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (emptyPositions.length > 0) {
return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ä¸»çº¿ç¨‹ä»ç„¶éœ€è¦ checkWin (ç”¨äºç©å®¶)
Â  Â  Â  Â  Â  Â  checkWin(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
Â  Â  Â  Â  Â  Â  Â  Â  const player = this.board[row][col];
Â  Â  Â  Â  Â  Â  Â  Â  if (player === 0) return false;

Â  Â  Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let r = row + dr, c = col + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r += dr; c += dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r = row - dr; c = col - dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r -= dr; c -= dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (count >= 5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
A
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isBoardFull() {
Â  Â  Â  Â  Â  Â  Â  Â  for (let row of this.board) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (row.includes(0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  T
Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateCurrentPlayer() {
Â  Â  Â  Â  Â  Â  Â  Â  let playerText;
Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰ AI æ¨¡å¼
Â  Â  Â  Â  Â  Â  Â  Â  playerText = this.currentPlayer === 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : '<span class="player-white">â—‹ AIï¼ˆç™½æ£‹ï¼‰</span>';
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ›´æ–° UI (é™„åŠ è®¡æ—¶å™¨)
Â  Â  Â  Â  Â  Â  Â  Â  const playerTimerSpan = document.getElementById('playerTimeLeft');
Â  Â  Â  Â  Â  Â  Â  Â  Â // åªæœ‰å½“è®¡æ—¶å™¨IDå­˜åœ¨æ—¶(è¡¨ç¤ºè®¡æ—¶å™¨æ­£åœ¨è¿è¡Œ)æ‰æ˜¾ç¤ºæ—¶é—´
Â  Â  Â  Â  Â  Â  Â  Â  if (this.playerTimerId !== null && this.currentPlayer === 1 && !this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerTimerSpan.textContent = `(${this.playerTimeLeft}s)`;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerTimerSpan.textContent = '';Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText + playerTimerSpan.outerHTML;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  showWinner() {
Â  Â  Â  Â  Â  Â  Â  Â  Â // åªæœ‰ AI æ¨¡å¼
Â  Â  Â  Â  Â  Â  Â  Â  let playerName = this.winner === 1 ? 'ä½ ' : 'ç¡•ç¥AI';

Â  Â  Â  Â  Â  Â  Â  Â  const message = document.getElementById('winnerMessage');
Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  let messageText = `ğŸ‰ ${playerName} è·èƒœï¼`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [å˜²è®½] AI è·èƒœæ—¶æ·»åŠ å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  if (this.winner === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = targets[Math.floor(Math.random() * targets.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let taunts = [ // ç¡•ç¥èƒœåˆ©å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `6å±‚æœç´¢ï¼Œ${target}ä½ æ‹¿ä»€ä¹ˆèµ¢ï¼Ÿ`, `å‡¡äºº${target}ï¼Œä½ å°½åŠ›äº†ã€‚`, `æˆ‘çš„æ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ€ä¼˜è§£ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, ä½ ç”šè‡³æ²¡èƒ½é€¼æˆ‘èµ°å‡ºå¼€å±€åº“ã€‚`, `ç»“æŸäº†, ${target}, æ¸¸æˆæ‰åˆšåˆšå¼€å§‹ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `ä¸å ªä¸€å‡»ï¼Œ${target}ã€‚`, `å›å»å†ç»ƒç»ƒå§ï¼Œ${target}ï¼`
A
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const taunt = taunts[Math.floor(Math.random() * taunts.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<span class="ai-taunt">${taunt}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶è·èƒœè®°å½•æ—¶é—´
Â  Â  Â  Â  Â  Â  Â  Â  if (this.winner === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>â±ï¸ ç”¨æ—¶ï¼š${timeStr}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bestTimeKey = `bestTime_god`; // å›ºå®š Key
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentBest = localStorage.getItem(bestTimeKey);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  localStorage.setItem(bestTimeKey, this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.loadBestTime();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>ğŸ† æ–°çºªå½•ï¼ä½ ç«Ÿç„¶èµ¢äº†ç¡•ç¥ï¼Ÿï¼`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>ï¼ˆè™½ç„¶èµ¢äº†ï¼Œä½†æ²¡ç ´çºªå½•å“¦ï¼‰`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  message.innerHTML = messageText;
Â  Â  Â  Â  Â  Â  Â  Â  message.className = 'winner-message show';
Â  Â  Â  Â  Â  Â  Â  Â  message.style.color = this.winner === 1 ? '#4caf50' : '#d32f2f'; // ç©å®¶èµ¢ç»¿è‰²ï¼ŒAIèµ¢çº¢è‰²
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  showDraw() {
Â  Â  Â  Â  Â  Â  Â  Â  const message = document.getElementById('winnerMessage');
message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»¡';
Â  Â  Â  Â  Â  Â  Â  Â  message.className = 'winner-message show';
Â  Â  Â  Â  Â  Â  Â  Â  message.style.color = '#ff9800';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¯åŠ¨ç©å®¶è®¡æ—¶å™¨
Â  Â  Â  Â  Â  Â  startPlayerTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  // [ç©å®¶è®¡æ—¶.å¯åŠ¨é€»è¾‘ä¿®æ­£] ç¡®ä¿æ¸¸æˆæœªç»“æŸä¸”ç¡®å®è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver || this.currentPlayer !== 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Attempted to start player timer, but conditions not met. Game Over:", this.gameOver, "Current Player:", this.currentPlayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Starting player timer...");
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer(); // å…ˆæ¸…é™¤æ—§çš„
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft = 10;
Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º (10s)
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  S
Â  Â  Â  Â  Â  Â  this.playerTimerId = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢è®¡æ—¶å™¨åœ¨ä¸è¯¥è·‘çš„æ—¶å€™è·‘
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver || this.currentPlayer !== 1 || this.playerTimerId === null) { // Added null check
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Player timer interval running, but conditions no longer met. Stopping.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.playerTimeLeft <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Player timer reached 0.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.forceRandomMove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  D
Â  Â  Â  Â  Â  Â  Â  Â  }, 1000); // æ¯ç§’æ‰§è¡Œ
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // [ä¿®å¤å¡æ­».3] ç®€åŒ– stopPlayerTimer
Â  Â  Â  Â  Â  Â  stopPlayerTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.playerTimerId !== null) { // Check if ID exists before clearing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Stopping player timer.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.playerTimerId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimerId = null; // æ¸…é™¤ ID å¾ˆé‡è¦
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â // æ¸…é™¤è®¡æ—¶æ˜¾ç¤º (å³ä½¿è®¡æ—¶å™¨ä¸å­˜åœ¨ä¹Ÿå°è¯•æ¸…é™¤)
Â  Â  Â  Â  Â  Â  Â  Â  Â const playerTimerSpan = document.getElementById('playerTimeLeft');
Â  Â  Â  Â  Â  Â  Â  Â  Â if(playerTimerSpan) playerTimerSpan.textContent = '';
BODY
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â // ä¸å†è°ƒç”¨ updateCurrentPlayer
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¼ºåˆ¶éšæœºè½å­
Â  Â  Â  Â  Â  Â  forceRandomMove() {
Â  Â  Â  Â  Â  Â  Â  Â  Â // ç¡®ä¿åœæ­¢è®¡æ—¶å™¨ï¼ˆå¯èƒ½å·²è¢«è°ƒç”¨ï¼Œä½†å†æ¬¡ç¡®ä¿ï¼‰
Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver || this.currentPlayer !== 1) return; // æ¸¸æˆå·²ç»“æŸæˆ–ä¸æ˜¯ç©å®¶å›åˆ
Warning
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Main] Player timed out, forcing random move!");
Â  Â  Â  Â  Â  Â  Â  Â  Â const randomMove = this.getRandomMoveForMainThread();
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â // çŸ­æš‚æç¤º
S
Â  Â  Â  Â  Â  Â  Â  Â  Â const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼å·²æ›¿ä½ éšæœºè½å­ï¼`;
Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â if (randomMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // å»¶è¿Ÿä¸€ç‚¹ç‚¹æ‰§è¡Œï¼Œè®©æç¤ºèƒ½è¢«çœ‹åˆ°
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // æ£€æŸ¥æ¸¸æˆæ˜¯å¦åœ¨å»¶è¿ŸæœŸé—´ç»“æŸäº†ï¼Œå¹¶ä¸”ç¡®è®¤ç°åœ¨æ˜¯ç©å®¶å›åˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // å¢åŠ æ£€æŸ¥ï¼šç¡®ä¿è¯¥ä½ç½®ä»ç„¶æ˜¯ç©ºçš„ï¼ˆé˜²æ­¢æç½•è§çš„ç«äº‰ï¼‰
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!this.gameOver && this.currentPlayer === 1 && this.isValidMove(randomMove.row, randomMove.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[Main] Making forced random move at ${randomMove.row}, ${randomMove.col}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(randomMove.row, randomMove.col);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  S
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("[Main] Could not make forced random move (game over, turn changed, or cell occupied).");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }, 100); // ç¼©çŸ­å»¶è¿Ÿ
Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error("[Main] Player timed out but no valid random move found (board full?).");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼ä½†æ£‹ç›˜å·²æ»¡ï¼Ÿ`;
Â  Â  Â  A
Â  Â  Â  Â  Â  Â  Â  Â  this.showDraw(); // å¦‚æœæ²¡æ£‹å¯èµ°ï¼Œåˆ¤å¹³å±€
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  _internalReset() {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Internal reset called.");
Â  Â  Â  Â  Â  Â  Â  Â  this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 2; // AI å…ˆæ‰‹
Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.winner = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
section
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer(); // åœæ­¢æ¸¸æˆæ€»è®¡æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer(); // åœæ­¢ç©å®¶è®¡æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  this.elapsedTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay();
section
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('winnerMessage').className = 'winner-message';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('aiThinking').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
Â  Â  Â  Â  Â  Â  Â  Â  // updateCurrentPlayer ä¼šåœ¨ startNewGame ä¸­è°ƒç”¨
section
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  startNewGame() {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Starting new game...");
Â  Â  Â  Â  Â  Â  Â  Â  this._internalReset();
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®å¤å¡æ­».4] ä½¿ç”¨ setTimeout ç¡®ä¿ UI æ¸²æŸ“å®Œæˆåå†æ‰§è¡Œ AI ç¬¬ä¸€æ­¥
D
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.performAiFirstMove();
Â  Â  Â  Â  Â  Â  Â  Â  }, 0);
Â  Â  Â  Â  Â  Â  }
D
Â  Â  Â  T
Â  Â  Â  Â  startTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.timerInterval) return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Starting main game timer.");
Â  Â  Â  Â  Â  Â  Â  Â  this.startTime = Date.now() - this.elapsedTime;
Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  S
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elapsedTime = Date.now() - this.startTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Game over detected in timer interval. Stopping main timer.");
aS
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 100);Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  stopTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.timerInterval) {
aS
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Stopping main game timer.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.timerInterval);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimerDisplay() {
CH
Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('currentTime').textContent = timeStr;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  formatTime(ms) {
Â  Â  Â  Â  Â  Â  Â  Â  const totalSeconds = Math.floor(ms / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(totalSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = totalSeconds % 60;
Â  Ass
Â  Â  Â  Â  Â  return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadBestTime() {
Â  Â  Â  Â  Â  Â  Â  Â  const bestTimeKey = `bestTime_god`; // å›ºå®š Key
Â  Â  Â  Â  Â  Â  Â  Â  const bestTime = localStorage.getItem(bestTimeKey);

Â  Â  Â  Â  Â  Â  Â  Â  if (bestTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(parseInt(bestTime));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('bestTime').textContent = timeStr;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('bestTime').textContent = '--:--';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Ass
Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  // å¯åŠ¨é€»è¾‘ (UI çº¿ç¨‹)
Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  let game;Â 

Â  Â  Â  Â  function restartGame() {
Â  Â  Â  Â  Â  Â  if (!game) return;
Request
Â  Â  Â  Â  Â  Â  if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿï¼ˆç¡•ç¥AIå°†ç«‹å³åœ¨å¤©å…ƒè½å­ï¼‰')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("[Main] Restart button clicked.");
Â  Â  Â  Â  Â  Â  Â  Â  game.startNewGame();Â 
Â  Â  Sure
Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ç­‰å¾…HTMLåŠ è½½å®Œæ¯•åï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆ
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  Â console.log("[Main] DOMContentLoaded. Initializing game.");
Â  Â  Â  Â  Â  Â  // ç›´æ¥åˆå§‹åŒ–ç¡•ç¥æ¨¡å¼
Â  Â  Â  Â  Â  Â  game = new GomokuGame();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ›´æ–°è§„åˆ™æ–‡æœ¬
Give
Â  Â  Â  Â  Â  Â  const rulesList = document.getElementById('rules-list'); // Get the list by ID
Â  Â  Â  Â  Â  Â  // æ¸…ç©ºæ—§è§„åˆ™ (å¦‚æœå­˜åœ¨)
Â  Â  Â  Â  Â  Â  while (rulesList.firstChild) {
Â  Â  Â  Â  Â  Â  Â  Â  Â rulesList.removeChild(rulesList.firstChild);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // æ·»åŠ æ–°è§„åˆ™
Â  Â  Â  Â  Â  Â  const rules = [
Â  Methods
Â  Â  Â  Â  Â  Â  Â  Â  'ğŸ”¥ **ç¡•ç¥æ¨¡å¼**: AIæ‰§ç™½æ£‹ (2) **ç«‹å³**åœ¨å¤©å…ƒè½å­å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼‰',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'ç©å®¶**ç¬¬ä¸€æ­¥å**æ¯æ­¥æ€è€ƒæ—¶é—´ä¸å¾—è¶…è¿‡10ç§’ï¼Œè¶…æ—¶å°†éšæœºè½å­',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'AI æ¯æ­¥æ€è€ƒæ—¶é—´ä¸Šé™10ç§’',
Â  Â  Â  Â  Â  Â  Â  Â  Â '**æ— æ‚”æ£‹**'
Â  Â  aS
Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â rules.forEach(ruleText => {
Â  Â  Â  Â  Â  Â  Â  Â  Â const li = document.createElement('li');
Â  Â  Â  Â  Â  Â  Â  Â  Â li.innerHTML = ruleText; // ä½¿ç”¨ innerHTML æ”¯æŒåŠ ç²—
Â  Â  Â  Â  Â  Â  Â  Â  Â rulesList.appendChild(li);
Â  Â  Â  Â  Â  Â  Â });
            
            // [ä¿®å¤å¡æ­».5] ç¡®ä¿ AI ç¬¬ä¸€æ­¥åœ¨ DOM åŠ è½½åæ‰§è¡Œ
            game.startNewGame();
warning
Â  Â  Â  Â  Â  Â  Â  console.log("[Main] Game initialization complete.");
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>
