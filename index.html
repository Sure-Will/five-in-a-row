<!DOCTYPE html>
<html lang="zh-CN">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>äº”å­æ£‹æ¸¸æˆ?- æŒ‘æˆ˜ç¡•ç¥</title>
Â  Â  <style>
Â  Â  Â  Â  * { margin: 0; padding: 0; box-sizing: border-box; }
Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  font-family: 'Arial', 'Microsoft YaHei', sans-serif;
Â  Â  Â  Â  Â  Â  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
Â  Â  Â  Â  Â  Â  display: flex; justify-content: center; align-items: center;
Â  Â  Â  Â  Â  Â  min-height: 100vh; padding: 20px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .container {
Â  Â  Â  Â  Â  Â  background: white; border-radius: 20px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
Â  Â  Â  Â  Â  Â  padding: 30px; max-width: 850px; width: 100%;
Â  Â  Â  Â  }
Â  Â  Â  Â  h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
Â  Â  Â  Â  .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 1.1em; }
Â  Â  Â  Â  .difficulty-selector { display: flex; justify-content: center; margin-bottom: 20px; align-items: center; }
Â  Â  Â  Â  .diff-label { font-weight: bold; margin-right: 10px; font-size: 1.1em;}
Â  Â  Â  Â  .god-mode-active {
Â  Â  Â  Â  Â  Â  Â padding: 10px 20px; font-size: 1.1em; border-radius: 10px;
Â  Â  Â  Â  Â  Â  Â background: #f44336; color: white; font-weight: bold;
Â  Â  Â  Â  Â  Â  Â box-shadow: 0 2px 4px rgba(0,0,0,0.2);
Â  Â  Â  Â  }
Â  Â  Â  Â  .game-info {
Â  Â  Â  Â  Â  Â  display: flex; justify-content: space-between; align-items: center;
Â  Â  Â  Â  Â  Â  margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .current-player { font-size: 1.3em; font-weight: bold; color: #333; }
Â  Â  Â  Â  #playerTimeLeft { font-size: 0.8em; color: #f44336; margin-left: 8px; font-weight: normal; }
Â  Â  Â  Â  .player-black { color: #000; }
Â  Â  Â  Â  .player-white { color: #666; }
Â  Â  Â  Â  .controls { display: flex; gap: 10px; }
Â  Â  Â  Â  button {
Â  Â  Â  Â  Â  Â  padding: 10px 20px; font-size: 1em; border: none; border-radius: 8px;
Â  Â  Â  Â  Â  Â  cursor: pointer; transition: all 0.3s; font-weight: bold;
Â  Â  Â  Â  }
Â  Â  Â  Â  .btn-restart { background: #4caf50; color: white; }
Â  Â  Â  Â  .btn-restart:hover { background: #45a049; }
Â  Â  Â  Â  button:disabled { opacity: 0.5; cursor: not-allowed; }
Â  Â  Â  Â  .board-container { display: flex; justify-content: center; margin: 20px 0; }
Â  Â  Â  Â  #gameBoard {
Â  Â  Â  Â  Â  Â  background: #daa520; border: 3px solid #8b6914;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); cursor: pointer;
Â  Â  Â  Â  Â  Â  max-width: 100%; height: auto;
Â  Â  Â  Â  }
Â  Â  Â  Â  .winner-message {
Â  Â  Â  Â  Â  Â  text-align: center; font-size: 1.5em; font-weight: bold; color: #4caf50;
Â  Â  Â  Â  Â  Â  margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 10px; display: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  .winner-message.show { display: block; animation: slideDown 0.5s ease; }
Â  Â  Â  Â  @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
Â  Â  Â  Â  .instructions { background: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; }
Â  Â  Â  Â  .instructions h3 { color: #1976d2; margin-bottom: 10px; }
Â  Â  Â  Â  .instructions ul { list-style-position: inside; color: #333; line-height: 1.8; }
        
Â  Â  Â  Â  /* [UI ä¼˜åŒ–] ä¿®å¤æ£‹ç›˜æŠ–åŠ¨ */
Â  Â  Â  Â  .ai-thinking { 
Â  Â  Â  Â  Â  Â  text-align: center; 
Â  Â  Â  Â  Â  Â  font-size: 1.1em; 
Â  Â  Â  Â  Â  Â  color: #ff9800; 
Â  Â  Â  Â  Â  Â  margin: 10px 0; 
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  /* ç»™äºˆæœ€å°é«˜åº¦ï¼Œç¡®ä¿å®¹çº³ä¸¤è¡Œæ–‡å­—ï¼ˆçŠ¶æ€?+ å˜²è®½ï¼?/
Â  Â  Â  Â  Â  Â  min-height: 3.5em; 
Â  Â  Â  Â  Â  Â  /* é»˜è®¤éšè—ï¼Œä½†å æ®ç©ºé—´ï¼Œé˜²æ­¢æŠ–åŠ?*/
Â  Â  Â  Â  Â  Â  visibility: hidden; 
Â  Â  Â  Â  Â  Â  display: block; /* å§‹ç»ˆå æ®ç©ºé—´ */
Â  Â  Â  Â  }
        
Â  Â  Â  Â  .step-taunt { display: block; font-size: 0.9em; color: #e91e63; margin-top: 5px; }
Â  Â  Â  Â  .timer-container {
Â  Â  Â  Â  Â  Â  display: flex; justify-content: center; align-items: center; gap: 20px;
Â  Â  Â  Â  Â  Â  margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
Â  Â  Â  Â  Â  Â  border-radius: 10px; color: white;
Â  Â  Â  Â  }
Â  Â  Â  Â  .timer-item { text-align: center; }
Â  Â  Â  Â  .timer-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
Â  Â  Â  Â  .timer-value { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
Â  Â  Â  Â  .best-time { color: #ffd700; }
Â  Â  Â  Â  .ai-taunt { font-size: 0.8em; color: #f44336; font-weight: bold; display: block; margin-top: 10px; }
Â  Â  Â  Â  @media (max-width: 600px) {
Â  Â  Â  Â  Â  Â  .container { padding: 15px; } h1 { font-size: 1.8em; }
Â  Â  Â  Â  Â  Â  .game-info { flex-direction: column; gap: 10px; }
Â  Â  Â  Â  Â  Â  .controls { flex-wrap: wrap; justify-content: center; }
Â  Â  Â  Â  Â  Â  .timer-container { flex-direction: column; gap: 10px; } .timer-value { font-size: 1.8em; }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <div class="container">
Â  Â  Â  Â  <h1>ğŸ® äº”å­æ£?/h1>
Â  Â  Â  Â  <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

Â  Â  Â  Â  Â <div class="difficulty-selector">
Â  Â  Â  Â  Â  Â  <span class="diff-label">å½“å‰æ¨¡å¼ï¼?/span>
Â  Â  Â  Â  Â  Â  <span class="god-mode-active">ğŸ”¥ ç¡•ç¥åœ°ç‹±æ¨¡å¼</span>
Â  Â  Â  Â  </div>


Â  Â  Â  Â  <div class="game-info">
Â  Â  Â  Â  Â  Â  <div class="current-player" id="currentPlayer">
Â  Â  Â  Â  Â  Â  Â  Â  å½“å‰ç©å®¶ï¼?span class="player-black">â—?ä½ ï¼ˆé»‘æ£‹ï¼?/span> <span id="playerTimeLeft"></span>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="controls">
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§?/button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div class="ai-thinking" id="aiThinking">ğŸ¤– AIæ€è€ƒä¸­...</div>

Â  Â  Â  Â  <div class="timer-container">
Â  Â  Â  Â  Â  Â  <div class="timer-item">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-value" id="currentTime">00:00</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="timer-item">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-label">ğŸ† æœ€ä½³è®°å½?(ç¡•ç¥åœ°ç‹±æ¨¡å¼)</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="timer-value best-time" id="bestTime">--:--</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="winner-message" id="winnerMessage"></div>

Â  Â  Â  Â  <div class="board-container">
Â  Â  Â  Â  Â  Â  <canvas id="gameBoard"></canvas>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="instructions">
Â  Â  Â  Â  Â  Â  <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
Â  Â  Â  Â  Â  Â  <ul id="rules-list"> 
Â  Â  Â  Â  Â  Â  Â  Â  <!-- Rules will be added by JS -->
Â  Â  Â  Â  Â  Â  </ul>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <script id="ai-worker-script" type="text/worker-script">
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- Worker å†…çš„å…¨å±€å˜é‡ ---
Â  Â  Â  Â  let board, boardSize, maxDepth; // ç§»é™¤äº?difficulty
Â  Â  Â  Â  let zobristTable, currentHash, moveHistory;
Â  Â  Â  Â  let transpositionTable = new Map();

Â  Â  Â  Â  const TIMEOUT_MS = 5000; // 5 ç§?AI ç†”æ–­ï¼ˆåœ°ç‹±æ¨¡å¼ï¼‰

Â  Â  Â  Â  // --- æ ¸å¿ƒå…¥å£ï¼šæ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯ ---
Â  Â  Â  Â  self.onmessage = function(e) {
Â  Â  Â  Â  Â  Â  const data = e.data;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 1. æ›´æ–° Worker çš„å†…éƒ¨çŠ¶æ€?
Â  Â  Â  Â  Â  Â  board = data.board;
Â  Â  Â  Â  Â  Â  boardSize = data.boardSize;
Â  Â  Â  Â  Â  Â  maxDepth = data.maxDepth; // ç¡•ç¥(8)
Â  Â  Â  Â  Â  Â  zobristTable = data.zobristTable;
Â  Â  Â  Â  Â  Â  currentHash = data.currentHash;
Â  Â  Â  Â  Â  Â  moveHistory = data.moveHistory;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. æ¯æ¬¡ AI æ€è€ƒæ—¶ï¼Œéƒ½é‡ç½®ç½®æ¢è¡?
Â  Â  Â  Â  Â  Â  transpositionTable.clear();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const startTime = performance.now();
Â  Â  Â  Â  Â  Â  let moveResult = {};

Â  Â  Â  Â  Â  Â  // 3. å§‹ç»ˆè°ƒç”¨ç¡•ç¥æ¨¡å¼çš„è¿­ä»£åŠ æ·?
Â  Â  Â  Â  Â  Â  moveResult = getBestMoveIDDFS(startTime, maxDepth);

Â  Â  Â  Â  Â  Â  const endTime = performance.now();
Â  Â  Â  Â  Â  Â  const duration = ((endTime - startTime) / 1000).toFixed(2);

Â  Â  Â  Â  Â  Â  // 4. å°†ç»“æœå‘å›ä¸»çº¿ç¨‹
Â  Â  Â  Â  Â  Â  self.postMessage({
Â  Â  Â  Â  Â  Â  Â  Â  move: moveResult.move,
Â  Â  Â  Â  Â  Â  Â  Â  duration: duration,
Â  Â  Â  Â  Â  Â  Â  Â  depth: moveResult.depth,
Â  Â  Â  Â  Â  Â  Â  Â  type: moveResult.type || 'Minimax' // ç®—æ³•ç±»å‹
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- AI ç®—æ³• ---
Â  Â  Â  Â Â 
Â  Â  Â  Â  // [ç®—æ³•ä¼˜åŒ–] ä¼˜åŒ–åçš„ getHardMoveï¼Œä½œä¸?Minimax è¶…æ—¶çš„ä¿åº?
Â  Â  Â  Â  // å®ƒä¸å†æ£€æŸ¥å¿…èƒ?å¿…é˜²ï¼Œå› ä¸?getBestMoveIDDFS å·²ç»ä¼˜å…ˆå¤„ç†äº?
Â  Â  Â  Â  function getHardMove() { 
Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  let bestMove = null;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 1. æ­£å¸¸è¯„åˆ†
Â  Â  Â  Â  Â  Â  const validMoves = getValidMoves(false); // è·å–æ‰€æœ‰å¯èµ°ä½ç½?
Â  Â  Â  Â  Â  Â  if (validMoves.length === 0) return null;

Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  const score = evaluatePositionAdvanced(move.row, move.col);
Â  Â  Â  Â  Â  Â  Â  Â  if (score > bestScore) { 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = score; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = move; 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  return bestMove || (validMoves.length > 0 ? validMoves[0] : null);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // [ç®—æ³•åŠ å¼º æ–°å¢] è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ä¸€æ­¥å¿…èƒ?å¿…é˜²
Â  Â  Â  Â  function findImmediateThreats(player) {
Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = player;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(i, j)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { row: i, col: j }; // æ‰¾åˆ°å¿…èƒœ/å¿…é˜²ç‚?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[i][j] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  // [ç®—æ³•åŠ å¼º æ›¿æ¢] è¿­ä»£åŠ æ·± (IDDFS) å…¥å£ - ç¡•ç¥æ¨¡å¼ä¸“ç”¨ + VCF/VCT å¨èƒæœç´¢
Â  Â  Â  Â  function getBestMoveIDDFS(startTime, maxDepth) {
Â  Â  Â  Â  Â  Â  const openingMove = getOpeningMove();
Â  Â  Â  Â  Â  Â  if (openingMove) {
Â  Â  Â  Â  Â  Â  Â  Â  return { move: openingMove, depth: 1, timedOut: false, type: 'Opening' };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?1: æ£€æŸ?AI (2) å¿…èƒœ (Win-in-1) ==========
Â  Â  Â  Â  Â  Â  const aiWinMove = findImmediateThreats(2); // AI=2
Â  Â  Â  Â  Â  Â  if (aiWinMove) {
Â  Â  Â  Â  Â  Â  Â  Â  return { move: aiWinMove, depth: 1, type: 'WIN_IN_1' };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?2: æ£€æŸ?ç©å®¶ (1) å¿…èƒœ (Block Win-in-1) ==========
Â  Â  Â  Â  Â  Â  const playerWinMove = findImmediateThreats(1); // Player=1
Â  Â  Â  Â  Â  Â  if (playerWinMove) {
Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶æœ‰å¿…èƒœæ£‹ï¼ŒAI å¿…é¡»å µä¸Š
Â  Â  Â  Â  Â  Â  Â  Â  return { move: playerWinMove, depth: 1, type: 'BLOCK_WIN_IN_1' };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?3ï¼šVCF æœç´¢ï¼ˆAI è¿›æ”»ï¼?=========
Â  Â  Â  Â  Â  Â  const vcfResult = searchVCF(20, 2, startTime); // AI=2
Â  Â  Â  Â  Â  Â  if (vcfResult && vcfResult.move) {
Â  Â  Â  Â  Â  Â  Â  Â  return { move: vcfResult.move, depth: vcfResult.depth, type: 'VCF_Attack' };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?4ï¼šVCF æœç´¢ï¼ˆç©å®?è¿›æ”» -> AI é˜²å®ˆï¼?=========
Â  Â  Â  Â  Â  Â  const playerVCF = searchVCF(20, 1, startTime); // Player=1
Â  Â  Â  Â  Â  Â  if (playerVCF && playerVCF.move) {
Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶æœ?VCFï¼ŒAI å¿…é¡»é˜²å®ˆã€?
Â  Â  Â  Â  Â  Â  Â  Â  // ç®€å•é˜²å®ˆï¼šç›´æ¥å µåœ¨ç©å®¶çš?VCF èµ·å§‹ç‚¹ã€?
Â  Â  Â  Â  Â  Â  Â  Â  if (board[playerVCF.move.row][playerVCF.move.col] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return { move: playerVCF.move, depth: playerVCF.depth, type: 'VCF_Block' };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?5ï¼šVCT æœç´¢ï¼ˆAI è¿›æ”»ï¼?=========
Â  Â  Â  Â  Â  Â  const vctResult = searchVCT(15, 2, startTime); // AI=2
Â  Â  Â  Â  Â  Â  if (vctResult && vctResult.move) {
Â  Â  Â  Â  Â  Â  Â  Â  return { move: vctResult.move, depth: vctResult.depth, type: 'VCT_Attack' };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?6ï¼šVCT æœç´¢ï¼ˆç©å®?è¿›æ”» -> AI é˜²å®ˆï¼?=========
Â  Â  Â  Â  Â  Â  const playerVCT = searchVCT(15, 1, startTime); // Player=1
Â  Â  Â  Â  Â  Â  if (playerVCT && playerVCT.move) {
Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶æœ?VCTï¼ŒAI å¿…é¡»é˜²å®ˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[playerVCT.move.row][playerVCT.move.col] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: playerVCT.move, depth: playerVCT.depth, type: 'VCT_Block' };
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // ========== ä¼˜å…ˆçº?7ï¼šä¼ ç»?Minimax ==========
Â  Â  Â  Â  Â  Â  let bestMove = null;
Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  let completedDepth = 0;

Â  Â  Â  Â  Â  Â  // è¿­ä»£åŠ æ·±: æœç´¢æ·±åº¦ 2, 4, 6, ... ç›´åˆ° maxDepth
Â  Â  Â  Â  Â  Â  for (let d = 2; d <= maxDepth; d += 2) {

Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥å‰©ä½™æ—¶é—´æ˜¯å¦è¶³å¤Ÿè¿›è¡Œä¸‹ä¸€è½®æœç´¢ï¼ˆä¿å®ˆä¼°è®¡ï¼?
Â  Â  Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > (TIMEOUT_MS * 0.8)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // å¦‚æœå‰©ä½™æ—¶é—´ä¸å¤šï¼Œåœæ­¢åŠ æ·±ï¼Œä½¿ç”¨ä¸Šä¸€è½®ç»“æ?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

Â  Â  Â  Â  Â  Â  Â  Â  if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // è¶…æ—¶ï¼Œä½¿ç”¨ä¸Šä¸€è½®ç»“æ?
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰åœ¨æœªè¶…æ—¶æ—¶æ‰æ›´æ–°
Â  Â  Â  Â  Â  Â  Â  Â  bestMove = result.move;
Â  Â  Â  Â  Â  Â  Â  Â  bestScore = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  completedDepth = d;

Â  Â  Â  Â  Â  Â  Â  Â  // å¦‚æœæ‰¾åˆ°äº†å¿…èƒœï¼ˆæˆ–å¿…è´¥ï¼‰ï¼Œæå‰ç»ˆæ­?
Â  Â  Â  Â  Â  Â  Â  Â  if (bestScore > 9000000 || bestScore < -9000000) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // å¦‚æœè¶…æ—¶æˆ–æœç´¢æœªå®Œæˆ
Â  Â  Â  Â  Â  Â  if (bestMove === null) {
Â  Â  Â  Â  Â  Â  Â  Â  // æ­¤æ—¶ 1 çº§å¨èƒå·²æ£€æŸ¥è¿‡ï¼ŒMinimax æœç´¢å¤±è´¥ï¼ˆå¯èƒ½æ˜¯æ—¶é—´å¤ªçŸ­ï¼?
Â  Â  Â  Â  Â  Â  Â  Â  // ä½¿ç”¨ getHardMove ä½œä¸ºæœ€åçš„ä¿åº•ï¼ˆå®ƒä¼šæ‰¾ä¸€ä¸ªé™æ€æœ€é«˜åˆ†ï¼?
Â  Â  Â  Â  Â  Â  Â  Â  bestMove = getHardMove(); 
Â  Â  Â  Â  Â  Â  Â  Â  completedDepth = completedDepth || 1; // è‡³å°‘ç®?å±?
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return { move: bestMove, score: bestScore, depth: completedDepth, type: 'Minimax' };
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ ¸å¿ƒï¼šå¸¦ Alpha-Beta å‰ªæçš?Minimax
Â  Â  Â  Â  function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > TIMEOUT_MS) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: 0, timedOut: true };Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const hash = currentHash;
Â  Â  Â  Â  Â  Â  const cached = transpositionTable.get(hash);
Â  Â  Â  Â  Â  Â  if (cached && cached.depth >= depth) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: cached.score, timedOut: false };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (depth === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const score = evaluateBoardHeuristic();
Â  Â  Â  Â  Â  Â  Â  Â  return { score: score, timedOut: false };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const validMoves = getValidMoves(true); // true = å¸¦æ’åº?

Â  Â  Â  Â  Â  Â  if (validMoves.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  return { score: 0, timedOut: false }; // å¹³å±€
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  let bestMove = null;
Â  Â  Â  Â  Â  Â  let timedOut = false;

Â  Â  Â  Â  Â  Â  if (isMaximizingPlayer) {
Â  Â  Â  Â  Â  Â  Â  Â  let bestScore = -Infinity;
Â  Â  Â  Â  Â  Â  Â  Â  bestMove = validMoves[0];Â 

Â  Â  Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, 2); // AI (2)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 10000000 + depth; // å¿…èƒœ (10M)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timedOut = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score > bestScore) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alpha = Math.max(alpha, bestScore);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (beta <= alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // å‰ªæ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  transpositionTable.set(hash, { depth: depth, score: bestScore });
Â  Â  Â  Â  Â  Â  Â  Â  return { score: bestScore, move: bestMove, timedOut: false };
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } else { // è½®åˆ° Min (ç©å®¶)
Â  Â  Â  Â  Â  Â  Â  Â  let bestScore = +Infinity;
Â  Â  Â  Â  Â  Â  Â  Â  bestMove = validMoves[0];

Â  Â  Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, 1); // ç©å®¶ (1)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = -10000000 - depth; // å¿…è´¥ (-10M)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (result.timedOut) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timedOut = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = result.score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, 1);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score < bestScore) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestScore = score;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bestMove = move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  beta = Math.min(beta, bestScore);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (beta <= alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // å‰ªæ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  transpositionTable.set(hash, { depth: depth, score: bestScore });
Â  Â  Â  Â  Â  Â  Â  Â  return { score: bestScore, move: bestMove, timedOut: false };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ¨¡æ‹Ÿè½å­ (åªæ”¹æ£‹ç›˜å’Œå“ˆå¸?
Â  Â  Â  Â  function _simulateMove(row, col, player) {
Â  Â  Â  Â  Â  Â  board[row][col] = player;
Â  Â  Â  Â  Â  Â  currentHash ^= zobristTable[row][col][player - 1];
Â  Â  Â  Â  }
Â  Â  Â  Â  // æ¨¡æ‹Ÿæ‚”æ£‹
Â  Â  Â  Â  function _simulateUndo(row, col, player) {
Â  Â  Â  Â  Â  Â  board[row][col] = 0;
Â  Â  Â  Â  Â  Â  currentHash ^= zobristTable[row][col][player - 1];
Â  Â  Â  Â  }

Â  Â  Â  Â  // å¼€å±€åº?- ç¡•ç¥æ¨¡å¼ä¸“ç”¨ (AI å…ˆæ‰‹)
Â  Â  Â  Â  function getOpeningMove() {
Â  Â  Â  Â  Â  Â  const center = Math.floor(boardSize / 2);
Â  Â  Â  Â  Â  Â  // AI ç¬¬ä¸€æ­¥ï¼šèµ°å¤©å…?(æ­¤é€»è¾‘åœ¨ä¸»çº¿ç¨‹å¤„ç†äº†ï¼ŒWorkerä¸éœ€è¦?
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // AI ç¬¬äºŒæ­?(åº”å¯¹ç©å®¶çš„ç¬¬1æ­?
Â  Â  Â  Â  Â  Â  if (boardSize === 15 && moveHistory.length === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  const centerMove = moveHistory[0]; // AI (2)
Â  Â  Â  Â  Â  Â  Â  Â  const userMove = moveHistory[1];Â  Â // Player (1)
Â  Â  Â  Â  Â  Â  Â  Â  // ç¡®ä¿AIç¬¬ä¸€æ­¥æ˜¯å¤©å…ƒÂ 
Â  Â  Â  Â  Â  Â  Â  Â  if (centerMove.row !== center || centerMove.col !== center) return null;Â 

Â  Â  Â  Â  Â  Â  Â  Â  const dr = userMove.row - centerMove.row;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const dc = userMove.col - centerMove.col;

Â  Â  Â  Â  Â  Â  Â  Â  let aiMove = null;
Â  Â  Â  Â  Â  Â  Â  Â  // è§„åˆ™1: ç©å®¶èµ°æ–œè§?-> AIèµ°ç›´çº¿ç›¸é‚?
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(dr) === 1 && Math.abs(dc) === 1) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiMove = { row: centerMove.row + dr, col: centerMove.col };Â 
Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â  // è§„åˆ™2: ç©å®¶èµ°ç›´çº¿ç›¸é‚?-> AIèµ°æ–œè§’ç›¸é‚?
Â  Â  Â  Â  Â  Â  Â  Â  else if ((Math.abs(dr) === 1 && dc === 0) || (dr === 0 && Math.abs(dc) === 1)) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiMove = { row: centerMove.row + dc, col: centerMove.col + dr };Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥è®¡ç®—å‡ºçš„ä½ç½®æ˜¯å¦åœ¨æ£‹ç›˜å†…ä¸”ä¸ºç©º
Â  Â  Â  Â  Â  Â  Â  Â  if (aiMove &&Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiMove.row >= 0 && aiMove.row < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiMove.col >= 0 && aiMove.col < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[aiMove.row][aiMove.col] === 0) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return aiMove;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  // è·å–æœ‰æ•ˆèµ°æ³• (å¯å¸¦æ’åº)
Â  Â  Â  Â  function getValidMoves(withOrdering = false) {
Â  Â  Â  Â  Â  Â  const moveSet = new Set();
Â  Â  Â  Â  Â  Â  const center = Math.floor(boardSize / 2);

Â  Â  Â  Â  Â  Â  // åˆå§‹çŠ¶æ€ï¼ˆè™½ç„¶AIå·²èµ°å¤©å…ƒï¼Œä½†ä»¥é˜²ä¸‡ä¸€ï¼?
Â  Â  Â  Â  Â  Â  if (moveHistory.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â return [{ row: center, col: center }];
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // ç©å®¶ç¬¬ä¸€æ­¥ï¼ˆAIå·²èµ°å¤©å…ƒï¼?
Â  Â  Â  Â  Â  Â  if (moveHistory.length === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â // ç©å®¶ç¬¬ä¸€æ­¥å¯ä»¥åœ¨å¤©å…ƒé™„è¿‘ä»»æ„ä½ç½®
Â  Â  Â  Â  Â  Â  Â  Â  Â const moves = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â for(let dr = -1; dr <= 1; dr++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â for(let dc = -1; dc <=1; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const r = center + dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const c = center + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â moves.push({row: r, col: c});
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â // [å¼€å±€ä¼˜åŒ–] é™åˆ¶ç©å®¶ç¬¬ä¸€æ­¥åœ¨å¤©å…ƒæ—?(å¯é€?
Â  Â  Â  Â  Â  Â  Â  Â  Â // return moves;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ­£å¸¸æœç´¢
Â  Â  Â  Â  Â  Â  const radius = 2; // åªæœç´¢æ£‹å­å‘¨å›?æ ?
Â  Â  Â  Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[r][c] === 0) continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dr = -radius; dr <= radius; dr++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dc = -radius; dc <= radius; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize &&Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nc >= 0 && nc < boardSize &&Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[nr][nc] === 0)Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveSet.add(`${nr},${nc}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¦‚æœæ²¡æœ‰ä»»ä½•é‚»è¿‘çš„ç©ºç‚?(æ£‹ç›˜å‡ ä¹æ»¡äº†?)ï¼Œè¿”å›æ‰€æœ‰ç©ºç‚?
Â  Â  Â  Â  Â  Â  if (moveSet.size === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[r][c] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â moveSet.add(`${r},${c}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const moves = Array.from(moveSet).map(s => {
Â  Â  Â  Â  Â  Â  Â  Â  const [row, col] = s.split(',').map(Number);
Â  Â  Â  Â  Â  Â  Â  Â  return { row, col };
Â  S: Â  Â  Â  });

Â  Â  Â  Â  Â  Â  if (withOrdering) {
Â  Â  Â  Â  Â  Â  Â  Â  const scoredMoves = moves.map(move => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const score = evaluatePositionAdvanced(move.row, move.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move, score };
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  scoredMoves.sort((a, b) => b.score - a.score);
Â  Â  Â  Â  Â  Â  Â  Â  return scoredMoves.map(item => item.move);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return moves;
Â  Â  Â  Â  }

Â  Â  Â  Â  // é™æ€æ£‹ç›˜è¯„ä¼?(Minimax å¶èŠ‚ç‚¹ç”¨)
Â  Â  Â  Â  function evaluateBoardHeuristic() {
Â  Â  Â  Â  Â  Â  let totalScore = 0;
Â  Â  Â  Â  Â  Â  const validMoves = getValidMoves(false);Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  for (const move of validMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  totalScore += evaluatePositionAdvanced(move.row, move.col);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return totalScore;
Â  Â  Â  Â  }

Â  Â  Â  Â  // è¯„ä¼° (r, c) è¿™ä¸ª *ç©ºç‚¹* çš„ä»·å€?(æ”?é˜?
Â  Â  Â  Â  function evaluatePositionAdvanced(row, col) {
Â  Â  Â  Â  Â  Â  let score = 0;
Â  Â  Â  Â  Â  Â  const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  const aiScore = evaluateLine(row, col, dr, dc, 2); // AI åœ¨æ­¤è½å­
Â  Â  Â  Â  Â  Â  Â  Â  const playerScore = evaluateLine(row, col, dr, dc, 1); // ç©å®¶åœ¨æ­¤è½å­
Â  Â  Â  Â  Â  Â  Â  Â  score += aiScore + (playerScore * 1.1);Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const center = Math.floor(boardSize / 2);
Â  Â  Â  Â  Â  Â  const distToCenter = Math.abs(row - center) + Math.abs(col - center);
Â  Â  Â  Â  Â  Â  score += (boardSize - distToCenter) * 0.5;

Â  Â  Â  Â  Â  Â  return score;
Â  Â  Â  Â  }

Â  Â  Â  Â  // è¯„ä¼°åœ?(r, c) è½å­åï¼Œåœ?[dr, dc] æ–¹å‘ä¸Šçš„è¿ç æƒ…å†µ
Â  Â  Â  Â  function evaluateLine(row, col, dr, dc, player) {
Â  Â  Â  Â  Â  Â  let count = 0;Â 
Â  Â  _internalReset(); Â  Â  Â  Â  Â  let blocks = 0;Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ‰«ææ­£æ–¹å?
Â  Â  Â  Â  Â  Â  for (let i = 1; i <= 4; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = row + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const c = col + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break; }
Â  Â  Â  Â  Â  Â  Â  Â  if (board[r][c] === player) { count++; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (board[r][c] === 0) { break; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else { blocks++; break; }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // æ‰«æåæ–¹å?
Â  Â  Â  Â  Â  Â  for (let i = 1; i <= 4; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = row - dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const c = col - dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break; }
Â  Â  Â  Â  Â  Â  Â  Â  if (board[r][c] === player) { count++; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (board[r][c] === 0) { break; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else { blocks++; break; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // --- è¯„åˆ†è¡?---
Â  Â  Â  Â  Â  Â  if (count >= 4) return 10000000; // æˆäº” (10M)
Â  Â  Â  Â  Â  Â  if (count === 3 && blocks === 0) return 1000000; // æ´»å›› (1M)
Â  Â  Â  Â  Â  Â  if (count === 2 && blocks === 0) return 50000;Â  Â // æ´»ä¸‰ (50K)
Â  Â  Â  Â  Â  Â  if (count === 3 && blocks === 1) return 10000;Â  // å†²å›› (10K)
Â  Â  Â  Â  Â  Â  if (count === 2 && blocks === 1) return 500;Â  Â // çœ ä¸‰
Â  Â  Â  Â  Â  Â  if (count === 1 && blocks === 0) return 100;s: Â  Â  // æ´»äºŒ
Â  Â  Â  Â  Â  Â  if (count === 1 && blocks === 1) return 10;Â  Â  // çœ äºŒ
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  return 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ£€æŸ¥èƒœåˆ?
Â  Â  Â  Â  function checkWin(row, col) {
Â  Â  Â  Â  Â  Â  const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
Â  Â  Â  Â  Â  Â  const player = board[row][col];
Â  Â  Â  Â  Â  Â  if (player === 0) return false;

Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  let r = row + dr, c = col + dc;
Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r += dr; c += dc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  r = row - dr; c = col - dc;
Â  Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r -= dr; c -= dc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (count >= 5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  // ============================================================
Â  Â  Â  Â  // VCF/VCT å¨èƒæœç´¢ç®—æ³•
Â  Â  Â  Â  // ============================================================

Â  Â  Â  Â  // è·å–æŸä¸ªä½ç½®åœ¨æŸä¸ªæ–¹å‘çš„æ¨¡å¼ç±»å‹
Â  Â  Â  Â  function getPatternType(row, col, dr, dc, player) {
Â  Â  Â  Â  Â  Â  if (board[row][col] !== 0) return 'NONE';

Â  Â  Â  Â  Â  Â  let count = 0;
Â  Â  Â  Â  Â  Â  let blocks = 0;
Â  Â  Â  Â  Â  Â  let spaces = 0; // ç©ºä½æ•°ï¼ˆç”¨äºæ£€æµ‹è·³æ£‹ï¼‰

Â  Â  Â  Â  Â  Â  // æ‰«ææ­£æ–¹å?
Â  Â  Â  Â  Â  Â  for (let i = 1; i <= 4; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = row + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const c = col + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  S: Â  Â  Â  Â  Â  Â  if (board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (board[r][c] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spaces++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (spaces > 1) break; // è·³ä¸€æ ¼åç»§ç»­ï¼Œè·³ä¸¤æ ¼åœæ­¢
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // æ‰«æåæ–¹å?
Â  Â  Â  Â  Â  Â  for (let i = 1; i <= 4; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = row - dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const c = col - dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (board[r][c] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spaces++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (spaces > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blocks++; break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // åˆ¤æ–­æ¨¡å¼
Â  Â  Â  Â  Â  Â  if (count >= 4) return 'WIN';
Â  Â  Â  Â  Â  Â  if (count === 3 && blocks === 0) return 'LIVE_FOUR';
Â  Â  Â  Â  Â  Â  if (count === 3 && blocks === 1) return 'RUSH_FOUR';
Â  Â  Â  Â  Â  Â  if (count === 2 && blocks === 0) return 'LIVE_THREE';
Â  Â  Â  Â  Â  Â  if (count === 2 && blocks === 1) return 'SLEEP_THREE';
Â  Â  Â  Â  Â  Â  if (count === 1 && blocks === 0) return 'LIVE_TWO';

Â  Â  Â  Â  Â  Â  return 'NONE';
Â  Â  Â  Â  }

Â  Â  Â  Â  // æ£€æŸ¥æŸä¸ªä½ç½®æ˜¯å¦èƒ½å½¢æˆæŒ‡å®šçº§åˆ«çš„å¨èƒ?
Â  Â  Â  Â  function hasPattern(row, col, player, threatLevel) {
Â  Â  Â  Â  Â  Â  if (board[row][col] !== 0) return false;

Â  Â  Â  Â  Â  Â  const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  const pattern = getPatternType(row, col, dr, dc, player);

Â  Â  Â  Â  Â  Â  Â  Â  if (threatLevel === 'VCF') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // VCF: åªæ£€æµ‹æ´»å››å’Œå†²å››
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' || pattern === 'WIN') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else if (threatLevel === 'VCT') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // VCT: æ£€æµ‹æ´»ä¸‰åŠä»¥ä¸Š
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' ||
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pattern === 'LIVE_THREE' || pattern === 'WIN') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  // ç”Ÿæˆå¨èƒèµ°æ³•
Â  Â  Â  Â  function generateThreatMoves(player, threatLevel) {
Â  Â  Â  Â  Â  Â  const threats = [];
Â  Â  Â  Â  Â  Â  const moveSet = new Set();

Â  Â  Â  Â  Â  Â  // åªæœç´¢å·²æœ‰æ£‹å­å‘¨å›?æ ?
Â  Â  Â  Â  Â  Â  const radius = 2;
Â  Â  Â  Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (board[r][c] === 0) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dr = -radius; dr <= radius; dr++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dc = -radius; dc <= radius; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[nr][nc] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const key = `${nr},${nc}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!moveSet.has(key) && hasPattern(nr, nc, player, threatLevel)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  threats.push({ row: nr, col: nc });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  S: Â  Â  Â  moveSet.add(key);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  S: Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return threats;
Â  Â  Â  Â  }

Â  Â  Â  Â  // ç”Ÿæˆé˜²å®ˆèµ°æ³•ï¼ˆé˜²å®ˆæŸä¸ªå¨èƒç‚¹ï¼? åœ°ç‹±æ¨¡å¼ä¼˜åŒ–
Â  Â  Â  Â  function generateDefenseMoves(threatMove, opponent) {
Â  Â  Â  Â  Â  Â  const defMoves = [];
Â  Â  Â  Â  Â  Â  const player = (opponent === 1) ? 2 : 1; // å¨èƒæ–?

Â  Â  Â  Â  Â  Â  // ç­–ç•¥1ï¼šåœ¨å¨èƒç‚¹å‘¨å›?æ ¼å†…æ‰¾é˜²å®ˆç‚¹ï¼Œå¹¶è¯„åˆ†
Â  Â  Â  Â  Â  Â  const radius = 2;
Â  Â  Â  Â  Â  Â  const candidateDefenses = [];

Â  Â  Â  Â  Â  Â  for (let dr = -radius; dr <= radius; dr++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let dc = -radius; dc <= radius; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const r = threatMove.row + dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const c = threatMove.col + dc;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[r][c] === 0) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥è¿™ä¸ªç‚¹æ˜¯å¦èƒ½é˜»æ­¢å¨èƒæ–¹å½¢æˆäº”è¿
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[r][c] = opponent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[threatMove.row][threatMove.col] = player;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const stillThreat = checkWin(threatMove.row, threatMove.col);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!stillThreat) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // è¯„ä¼°è¿™ä¸ªé˜²å®ˆç‚¹çš„ä»·å€¼ï¼ˆæ˜¯å¦èƒ½å½¢æˆè‡ªå·±çš„å¨èƒï¼?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const defScore = evaluatePositionAdvanced(r, c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  candidateDefenses.push({ row: r, col: c, score: defScore });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[r][c] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[threatMove.row][threatMove.col] = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // æŒ‰é˜²å®ˆä»·å€¼æ’åºï¼ˆä¼˜å…ˆé€‰æ‹©èƒ½å½¢æˆåå‡»çš„é˜²å®ˆç‚¹ï¼‰
Â  Â  Â  Â  Â  Â  candidateDefenses.sort((a, b) => b.score - a.score);

Â  Â  Â  Â  Â  Â  // é™åˆ¶é˜²å®ˆèµ°æ³•æ•°é‡ï¼ˆé¿å…åˆ†æ”¯çˆ†ç‚¸ï¼‰ï¼Œä½†è‡³å°‘ä¿ç•™å‰?ä¸?
Â  Â  Â  Â  Â  Â  const maxDefenses = Math.min(candidateDefenses.length, 5);
Â  Â  Â  Â  Â  Â  for (let i = 0; i < maxDefenses; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  defMoves.push(candidateDefenses[i]);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é˜²å®ˆç‚¹ï¼Œè¿”å›å¨èƒç‚¹æœ¬èº?
Â  Â  Â  Â  Â  if (defMoves.length === 0 && board[threatMove.row][threatMove.col] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  defMoves.push(threatMove);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return defMoves;
Â  Â  Â  Â  }

Â  Â  Â  Â  // VCF æ±‚è§£å™¨ï¼šæœç´¢æ´»å››/å†²å››çš„å¿…æ€åºåˆ—
Â  Â  Â  Â  function searchVCF(depth, player, startTime) {
Â  Â  Â  Â  Â  Â  if (depth <= 0) return null;

Â  Â  Â  Â  Â  Â  // è¶…æ—¶æ£€æŸ?
Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > TIMEOUT_MS) {
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const opponent = (player === 1) ? 2 : 1;

Â  Â  Â  Â  Â  Â  // 1. ç”Ÿæˆæ‰€æœ?å›?çš„å¨èƒ?
Â  Â  Â  Â  Â  Â  const fourMoves = generateThreatMoves(player, 'VCF');

Â  Â  Â  Â  Â  Â  if (fourMoves.length === 0) return null;

Â  Â  Â  Â  Â  Â  for (const move of fourMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, player);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. å¦‚æœç›´æ¥æˆäº”ï¼Œæ‰¾åˆ°VCF
Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. å¯¹æ‰‹å¿…é¡»é˜²å®ˆ
Â  Â  Â  Â  Â  Â  Â  Â  const defMoves = generateDefenseMoves(move, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  // 4. æ£€æŸ¥å¯¹æ‰‹çš„æ¯ä¸ªé˜²å®ˆï¼ŒAIæ˜¯å¦éƒ½èƒ½ç»§ç»­VCF
Â  Â  Â  Â  Â  Â  Â  Â  let allDefLeadToVCF = true;

Â  Â  Â  Â  Â  Â  Â  Â  if (defMoves.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  // æ— æ³•é˜²å®ˆï¼Œè¯´æ˜å·²ç»å¿…èƒ?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  for (const def of defMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(def.row, def.col, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nextVCF = searchVCF(depth - 1, player, startTime);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(def.row, def.col, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!nextVCF) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allDefLeadToVCF = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);

Â  Â  Â  Â  Â  Â  Â  Â  if (allDefLeadToVCF && defMoves.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return null;
Â  Â  }

Â  Â  Â  Â  // VCT æ±‚è§£å™¨ï¼šæœç´¢æ´»ä¸‰+æ´»å››çš„å¨èƒåºåˆ—ï¼ˆç®€åŒ–ç‰ˆï¼?
Â  Â  Â  Â  function searchVCT(depth, player, startTime) {
Â  Â  Â  Â  Â  Â  if (depth <= 0) return null;

Â  Â  Â  Â  Â  Â  // è¶…æ—¶æ£€æŸ?
Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  if ((currentTime - startTime) > TIMEOUT_MS) {
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const opponent = (player === 1) ? 2 : 1;

Â  Â  Â  Â  Â  Â  // 1. ç”Ÿæˆå¨èƒèµ°æ³•ï¼ˆæ´»ä¸‰åŠä»¥ä¸Šï¼?
Â  Â  Â  Â  Â  Â  const threatMoves = generateThreatMoves(player, 'VCT');

Â  Â  Â  Â  Â  Â  if (threatMoves.length === 0) return null;

Â  Â  Â  Â  // ä¼˜å…ˆé€‰æ‹©æ›´å¼ºçš„å¨èƒï¼ˆæ´»å›› > å†²å›› > æ´»ä¸‰ï¼?
Â  Â  Â  Â  Â  Â  threatMoves.sort((a, b) => {
Â  Â  Â  Â  Â  Â  Â  Â  const scoreA = evaluatePositionAdvanced(a.row, a.col);
Â  Â  Â  Â  Â  Â  Â  Â  const scoreB = evaluatePositionAdvanced(b.row, b.col);
Â  Â  Â  Â  Â  Â  Â  Â  return scoreB - scoreA;
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  // åœ°ç‹±æ¨¡å¼ï¼šå°è¯•å‰5ä¸ªæœ€å¼ºå¨èƒï¼ˆæé«˜å¨èƒè¦†ç›–ç‡ï¼‰
Â  Â  Â  Â  Â  Â  const topMoves = threatMoves.slice(0, 5);

Â  Â  Â  Â  Â  Â  for (const move of topMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(move.row, move.col, player);

Â  Â  Â  Â  Â  Â  Â  Â  // å¦‚æœç›´æ¥æˆäº”
Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // æ£€æŸ¥æ˜¯å¦å½¢æˆVCFï¼ˆæ´»å›?å†²å››ï¼?
Â  Â  Â  Â  Â  Â  Â  Â  const vcfAfterThis = searchVCF(depth - 1, player, startTime);
Â  Â  Â  Â  Â  Â  Â  Â  if (vcfAfterThis) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // å¯¹æ‰‹é˜²å®ˆ
Â  Â  Â  Â  Â  Â  Â  Â  const defMoves = generateDefenseMoves(move, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  if (defMoves.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  S: Â  _simulateUndo(move.row, move.col, player);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  let allDefLeadToVCT = true;

Â  Â  Â  Â  Â  Â  Â  Â  for (const def of defMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateMove(def.row, def.col, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  // é€’å½’æ£€æŸ¥VCTæˆ–VCF
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nextThreat = searchVCF(depth - 1, player, startTime) ||
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  s: Â  Â  Â  searchVCT(depth - 1, player, startTime);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(def.row, def.col, opponent);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!nextThreat) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allDefLeadToVCT = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  S: Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  _simulateUndo(move.row, move.col, player);

Â  Â  Â  Â  Â  Â  Â  Â  if (allDefLeadToVCT && defMoves.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { move: move, depth: depth };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  </script>
Â  Â Â 
Â  Â  <script>
Â  Â  Â  Â  class GomokuGame {
Â  Â  Â  Â  Â  Â  constructor() {Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.boardSize = 15; // å›ºå®šä¸?15
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const maxCanvasWidth = 500;
Â  Â  Â  Â  Â  Â  Â  Â  this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

Â  Â  Â  Â  Â  Â  Â  Â  this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
Â  Â  Â  Â  Â  Â  Â  Â  // [AIç¬æ—¶å¼€å±€] åˆå§‹ currentPlayer è®¾ä¸º 2 (AI)ï¼Œä½† UI ä¸Šä¼šæ˜¾ç¤ºç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.winner = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.gameMode = 'ai'; // å›ºå®šä¸?AI
Â  Â  Â  Â  Â  Â  Â  Â  this.difficulty = 'god'; // å›ºå®šä¸?god
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // è®¡æ—¶å™¨ç›¸å…?
Â  Â  Â  Â  Â  Â  Â  Â  this.startTime = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.elapsedTime = 0;

Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimerId = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft = 5; // ç§?

Â  Â  Â  Â  Â  Â  Â  Â  this.canvas = document.getElementById('gameBoard');
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = this.canvas.getContext('2d');

Â  Â  Â  Â  Â  Â  Â  Â  // AI æ ¸å¿ƒï¼ˆåœ°ç‹±éš¾åº¦ï¼‰
Â  Â  Â  Â  Â  Â  Â  Â  this.GOD_DEPTH = 8;Â  Â  Â  Â // ç¥?8) - åœ°ç‹±æ¨¡å¼
Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.initZobrist();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // åˆå§‹åŒ?Web Worker
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const workerScript = document.getElementById('ai-worker-script').textContent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blob = new Blob([workerScript], { type: 'application/javascript' });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker = new Worker(URL.createObjectURL(blob));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker.onmessage = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.receiveAiMove(e.data);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  S: Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("æ— æ³•åˆ›å»º AI Worker: ", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alert("åŠ è½½AIçº¿ç¨‹å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§æˆ–åˆ·æ–°é¡µé¢ã€?);
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  this.initCanvas();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  Â  Â  this.loadBestTime();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [AIç¬æ—¶å¼€å±€.1] å»¶è¿Ÿæ‰§è¡Œ AI çš„ç¬¬ä¸€æ­¥ï¼Œç¡®ä¿ UI å…ˆæ¸²æŸ?
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.performAiFirstMove();Â 
Â  Â  Â  Â  Â  Â  Â  Â  }, 0);Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // [AIç¬æ—¶å¼€å±€.2] (æ–°å¢) AI ç¬¬ä¸€æ­¥é€»è¾‘
Â  Â  Â  Â  Â  Â  performAiFirstMove() {
Â  Â  Â  Â  Â  Â  Â  Â  // ç¡®ä¿åªåœ¨æ¸¸æˆå¼€å§‹æ—¶æ‰§è¡Œä¸€æ¬?
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length === 0 && !this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const center = Math.floor(this.boardSize / 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[center][center] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("AI performs instant first move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ç›´æ¥ä¿®æ”¹çŠ¶æ€ï¼Œä¸é€šè¿‡ makeMove (é¿å…è§¦å‘è®¡æ—¶å™¨ç­‰)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[center][center] = 2; // AI (ç™½æ£‹) è½å­
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory.push({ row: center, col: center, player: 2 });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash ^= this.zobristTable[center][center][1]; // æ›´æ–°å“ˆå¸Œ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 1; // è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // é‡ç»˜æ£‹ç›˜ï¼Œæ˜¾ç¤ºAIçš„ç¬¬ä¸€é¢—å­
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°UIæ˜¾ç¤ºè½®åˆ°ç©å®¶ (æ­¤æ—¶è¿˜ä¸è®¡æ—¶)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // åˆå§‹åŒ?Zobrist å“ˆå¸Œè¡?(ä¸»çº¿ç¨?
Â  Â  Â  Â  Â  Â  initZobrist() {
Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable = Array(this.boardSize).fill(null).map(() =>Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Array(this.boardSize).fill(null).map(() =>Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Array(2).fill(null) // 2ä¸ªç©å®?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let k = 0; k < 2; k++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  initCanvas() {
Â  Â  Â  Â  Â  Â  Â  Â  const size = this.cellSize * (this.boardSize + 1);
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.width = size;
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.height = size;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawBoard() {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const cellSize = this.cellSize;
Â  Â  Â  Â  Â  Â  Â  Â  const boardSize = this.boardSize;

Â  Â  Â  Â  Â  Â  Â  Â  // æ¸…ç©ºç”»å¸ƒ
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#daa520';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶ç½‘æ ¼çº?
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(cellSize, cellSize * (i + 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(cellSize * (i + 1), cellSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½?(15x15)
Â  Â  Â  Â  Â  Â  Â  Â  const drawDot = (x, y) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
Â  Â  Â  Â  Â  Â  Â  Â  drawDot(11, 11); drawDot(7, 7);Â 

Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶æ£‹å­
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < boardSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[i][j] !== 0) {
Â  Â  Â  Â  Â  Â  Â  S: Â  Â  Â  Â  Â  Â  this.drawPiece(i, j, this.board[i][j]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lastMove = this.moveHistory[this.moveHistory.length - 1];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lastMove.player === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.highlightLastMove(lastMove.row, lastMove.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawPiece(row, col, player) {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const x = this.cellSize * (col + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const y = this.cellSize * (row + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const radius = this.cellSize * 0.4;

Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x, y, radius, 0, Math.PI * 2);

Â  Â  Â  Â  Â  Â  Â  Â  if (player === 1) { // ç©å®¶é»‘æ£‹
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = gradient;
Â  Â  Â  Â  Â  Â  Â  Â  } else { // AI ç™½æ£‹
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = gradient;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  highlightLastMove(row, col) {
Â  Â  Â  Â  Â  Â  const ctx = this.ctx;
Â  Â  Â  Â  Â  Â  Â  Â  const x = this.cellSize * (col + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const y = this.cellSize * (row + 1);
Â  Â  Â  Â  Â  Â  Â  Â  const radius = this.cellSize * 0.15;Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(x, y, radius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#FF0000';Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.clickHandler) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.removeEventListener('click', this.clickHandler);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.clickHandler = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentPlayer === 2) return; // AI å›åˆä¸èƒ½ç‚?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rect = this.canvas.getBoundingClientRect();
Â  Â  Â  Â  S: Â  Â  Â  Â  Â  const scaleX = this.canvas.width / rect.width;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scaleY = this.canvas.height / rect.height;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const canvasX = (e.clientX - rect.left) * scaleX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const canvasY = (e.clientY - rect.top) * scaleY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const col = Math.round(canvasX / this.cellSize) - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const row = Math.round(canvasY / this.cellSize) - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidMove(row, col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(row, col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.canvas.addEventListener('click', this.clickHandler);
Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isValidMove(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return this.board[row][col] === 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ç©å®¶æˆ–AIçš?*çœŸå®* è½å­
Â  Â  Â  Â  Â  Â  makeMove(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶è½å­ï¼Œåœæ­¢è®¡æ—?
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver && this.currentPlayer === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ¸¸æˆæ€»è®¡æ—¶åœ¨ç©å®¶ä¸‹ç¬¬ä¸€æ­¥åå¼€å§?(moveHistory ä»?0 (AI) -> 1 (ç©å®¶) æ—?
Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length === 1) { // AI å·²èµ°ä¸€æ­¥ï¼Œè¿™æ˜¯ç©å®¶ç¬¬ä¸€æ­?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.startTimer(); // æ¸¸æˆæ€»è®¡æ—¶å¼€å§?
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.board[row][col] = this.currentPlayer;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory.push({ row, col, player: this.currentPlayer });
Â  Â  Â  Â  Â  Â  Â  Â  this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard();

Â  Â  Â  Â  Â  Â  Â  Â  if (this.checkWin(row, col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.winner = this.currentPlayer;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showWinner();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.isBoardFull()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showDraw();
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // è½®åˆ° AI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentPlayer === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // AI ä¸‹æ£‹å‰å…ˆæ›´æ–° UIï¼Œæ˜¾ç¤ºè½®åˆ?AI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.updateCurrentPlayer();
Â  Â  Â  Â  Â  S: Â  Â  Â  Â  Â  Â  Â this.aiMove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰åœ¨ç©å®¶ä¸‹äº†ç¬¬ä¸€æ­¥æ£‹ä¹‹å (å?history >= 2) æ‰å¯åŠ¨è®¡æ—¶å™¨
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.moveHistory.length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.startPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  S: Â  Â  Â  Â  Â  Â  Â  // ç©å®¶ç¬¬ä¸€æ­¥åï¼Œä¸å¯åŠ¨è®¡æ—¶å™¨ï¼Œä½†éœ€è¦æ›´æ–?UI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // aiMove äº¤ç»™ Web Worker
Â  Â  Â  Â  Â  Â  aiMove() {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver) return; // é˜²æ­¢æ¸¸æˆç»“æŸå?AI ä»ç„¶æ€è€?

Â  Â  Â  Â  Â  Â  Â  Â  const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â // å›ºå®šä¸ºç¡•ç¥æ¨¡å¼çš„æç¤º
Â  Â  Â  Â  Â  Â  Â  Â  let thinkingText = `ğŸ”¥ ç¡•ç¥æ€è€ƒä¸­... (åœ°ç‹±æ¨¡å¼ D:${this.GOD_DEPTH}, 5sç†”æ–­)`;

Â  Â  Â  Â  Â  Â  Â  Â  // [UI ä¼˜åŒ–] å…ˆè®¾ç½®æ–‡å­—ï¼Œå†è®¾ä¸ºå¯è§?
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = thinkingText;
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.style.visibility = 'visible';

Â  Â  Â  Â  Â  Â  Â  Â  // å°†å½“å‰çŠ¶æ€å‘ç»?Worker çº¿ç¨‹
Â  Â  Â  Â  Â  Â  Â  Â  this.aiWorker.postMessage({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board: this.board,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  boardSize: this.boardSize,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  difficulty: 'god', // å›ºå®šä¸?god
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxDepth: this.GOD_DEPTH, // ä¼ é€’æœ€å¤§æ·±åº?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zobristTable: this.zobristTable,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentHash: this.currentHash,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveHistory: this.moveHistory
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ¥æ”¶ Worker çš„è®¡ç®—ç»“æ?
Â  Â  Â  Â  Â  Â  receiveAiMove(moveData) {
Â  Â  Â  Â  Â  Â  Â  Â  const { move, duration, depth, type } = moveData;

Â  Â  Â  Â  Â  Â  Â  Â  // å¦‚æœæ¸¸æˆå·²ç»ç»“æŸäº†ï¼ˆæ¯”å¦‚ç©å®¶åœ¨AIæ€è€ƒæ—¶åˆ·æ–°æˆ–é‡å¼€ï¼‰ï¼Œåˆ™ä¸å¤„ç†AIç»“æœ
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("Game over, ignoring AI move.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const aiThinkingEl = document.getElementById('aiThinking');

Â  Â  Â  Â  Â  Â  Â  Â  // [UI ä¼˜åŒ–] ç¡®ä¿ aiThinkingEl æ˜¯å¯è§çš„ï¼Œä»¥æ˜¾ç¤ºç»“æœ
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.style.visibility = 'visible';

Â  Â  Â  Â  Â  Â  Â  Â  // æ˜¾ç¤ºç®—æ³•ç±»å‹
Â  Â  Â  Â  Â  Â  Â  Â  let typeStr = '';
Â  Â  Â  Â  Â  Â  Â  Â  switch (type) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'WIN_IN_1': typeStr = 'ğŸ‘‘ [ä¸€æ­¥ç»æ€]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'BLOCK_WIN_IN_1': typeStr = 'ğŸ›¡ï¸?[è¢«è¿«é˜²å¾¡]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'VCF_Attack': typeStr = 'ğŸ”¥ [VCF å¿…æ€]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'VCF_Block': typeStr = 'ğŸ§± [VCF é˜²å¾¡]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'VCT_Attack': typeStr = 'âš?[VCT å¨èƒ]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'VCT_Block': typeStr = 'âœ?[VCT é˜²å¾¡]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'Opening': typeStr = 'ğŸ“š [å¼€å±€åº“]'; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  default: typeStr = `(D:${depth})`;
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  let durationText = `(ç”¨æ—¶ ${duration}s)`;
Â  Â  Â  Â  Â  Â  Â  Â  // TIMEOUT_MS åœ?Worker ä¸­å®šä¹‰ï¼Œè¿™é‡Œç”¨å­—é¢é‡
Â  Â  Â  Â  Â  Â  Â  Â  if (parseFloat(duration) >= 5.0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  durationText = `(è¶…æ—¶ ${duration}s, è¿”å›D:${depth}ç»“æœ)`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // [å˜²è®½] å‡†å¤‡å˜²è®½è¯­å½•
Â  Â  Â  Â  Â  Â  Â  Â  const targets = ["å°å¼ºå¼?, "å°è¾‰è¾?];
Â  Â  Â  Â  Â  Â  Â  Â  const target = targets[Math.floor(Math.random() * targets.length)];
Â  Â  Â  Â  Â  Â  Â  Â  let stepTaunts = [];

Â  Â  Â  Â  Â  Â  Â  Â  if (type === 'VCF_Attack' || type === 'WIN_IN_1') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stepTaunts = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, è¿™æ˜¯å¿…æ€åºåˆ—ï¼ä½ å·²ç»è¾“äº†ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `VCFæ‰¾åˆ°äº†ï¼Œ${target}ï¼Œä½ æ— è·¯å¯é€ƒã€‚`,
Â  Â  Â  Â  Â  Â  Â  S: Â  Â  Â  `å®Œç¾çš„å››è¿å¨èƒï¼Œ${target}ï¼Œè®¤è¾“å§ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, æˆ‘å·²ç»ç®—åˆ°äº†ä½ çš„æ­»æœŸã€‚`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  } else if (type === 'BLOCK_WIN_IN_1' || type === 'VCF_Block' || type === 'VCT_Block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stepTaunts = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `ä½ ä»¥ä¸ºæˆ‘æ²¡çœ‹åˆ°å—, ${target}ï¼Ÿ`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `é›•è™«å°æŠ€ï¼?{target}ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `é˜²ä½ä½ äº†, ${target}ï¼Œåˆ°æ­¤ä¸ºæ­¢äº†ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `è¿™ç§ä½çº§é™·é˜±... ${target}ï¼Œä½ å¤ªå«©äº†ã€‚`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  } else if (type === 'VCT_Attack') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stepTaunts = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, å¨èƒåºåˆ—å·²å¯åŠ¨ï¼Œä½ èƒ½æ’‘å‡ æ­¥ï¼Ÿ`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `VCTé”å®šï¼?{target}ï¼Œæ„Ÿå—ç»æœ›å§ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, è¿™æ˜¯è¿ç»­å¨èƒï¼Œä½ é˜²ä¸ä½çš„ã€‚`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stepTaunts = [ // ç¡•ç¥ä¸“å±å˜²è®½ï¼ˆåœ°ç‹±æ¨¡å¼ï¼‰
Â  Â  Â  Â  Â  Â  Â  Â  Â  `ç¥ä¹‹ä¸€æ‰‹ã€‚åˆ°ä½ äº†, ${target}ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æˆ‘ç®—äº?${depth} å±‚ï¼Œä½ è¿˜æœ‰èƒœç®—å—, ${target}ï¼Ÿ`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, ä½ å·²ç»è¾“äº? åªæ˜¯è¿˜æ²¡æ„è¯†åˆ°ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  S: Â  `å®Œç¾çš„é˜²å®ˆï¼Œæ— æ‡ˆå¯å‡»çš„è¿›æ”»ã€‚é¢¤æŠ–å§, ${target}ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æˆ‘çœ‹åˆ°äº† ${depth} å±‚ä¹‹åçš„ä¸–ç•Œ, ${target}, ä½ å‘¢ï¼Ÿ`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æ”¾å¼ƒå? ${target}, èƒœè´Ÿå·²å®šã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `å¼±å°çš„äººç±?{target}, ä½ çš„ç­–ç•¥æ¼æ´ç™¾å‡ºã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `åœ°ç‹±éš¾åº¦ä¸æ˜¯å¼€ç©ç¬‘çš? ${target}ï¼`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `æ˜¯ä¸æ˜¯å¾ˆç»æœ›å•? ${target}ï¼Ÿ`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const stepTaunt = stepTaunts[Math.floor(Math.random() * stepTaunts.length)];

Â  Â  Â  Â  Â  Â  // æ˜¾ç¤ºä¿¡æ¯ + å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = `âœ?AIè½å­ ${typeStr} ${durationText} <span class="step-taunt">${stepTaunt}</span>`;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œå¹¶ä¸”å½“å‰å¿…é¡»è½®åˆ° AI (player 2)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver && this.currentPlayer === 2 && this.isValidMove(move.row, move.col)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(move.row, move.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!this.gameOver && this.currentPlayer === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error("AI Worker è¿”å›äº†ä¸€ä¸ªæ— æ•ˆèµ°æ³? ", move);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const randomMove = this.getRandomMoveForMainThread();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(randomMove) this.makeMove(randomMove.row, randomMove.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.log("Ignoring AI move received after turn changed or game ended.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  S: Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ? (AIæ— æ£‹å¯èµ°)';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ä¸»çº¿ç¨‹çš„ä¿åº•éšæœºèµ°æ³• (ç”¨äºç©å®¶è¶…æ—¶)
Â  Â  Â  Â  Â  Â  getRandomMoveForMainThread() {
Â  Â  Â  Â  Â  Â  Â  Â  Â const emptyPositions = [];
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.boardSize; j++) {
Â  Â  Â  S: Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[i][j] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emptyPositions.push({ row: i, col: j });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (emptyPositions.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ä¸»çº¿ç¨‹ä»ç„¶éœ€è¦?checkWin (ç”¨äºç©å®¶)
Â  Â  Â  checkWin(row, col) {
Â  Â  Â  Â  Â  Â  Â  Â  const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
Â  Â  Â  Â  Â  Â  Â  Â  const player = this.board[row][col];
Â  Â  Â  Â  Â  Â  Â  Â  if (player === 0) return false;

Â  Â  Â  Â  Â  Â  Â  Â  for (let [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let r = row + dr, c = col + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < this.boardSize && c >= 0 && c < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r += dr; c += dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r = row - dr; c = col - dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.board[r][c] === player) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; r -= dr; c -= dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (count >= 5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isBoardFull() {
Â  Â  Â  Â  Â  Â  Â  Â  for (let row of this.board) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (row.includes(0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateCurrentPlayer() {
Â  Â  Â  Â  Â  Â  Â  Â  let playerText;
Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰ AI æ¨¡å¼
Â  Â  Â  Â  Â  Â  Â  Â  playerText = this.currentPlayer === 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? '<span class="player-black">â—?ä½ ï¼ˆé»‘æ£‹ï¼?/span>'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : '<span class="player-white">â—?AIï¼ˆç™½æ£‹ï¼‰</span>';
Â  Â  Â  Â  Â  Â  Â  S: Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ›´æ–° UI (é™„åŠ è®¡æ—¶å™?
Â  Â  Â  Â  Â  Â  Â  Â  const playerTimerSpan = document.getElementById('playerTimeLeft');
Â  Â  Â  Â  Â  Â  Â  Â  Â // åªæœ‰å½“è®¡æ—¶å™¨IDå­˜åœ¨æ—?è¡¨ç¤ºè®¡æ—¶å™¨æ­£åœ¨è¿è¡?æ‰æ˜¾ç¤ºæ—¶é—?
Â  Â  Â  Â  Â  Â  Â  Â  if (this.playerTimerId !== null && this.currentPlayer === 1 && !this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerTimerSpan.textContent = `(${this.playerTimeLeft}s)`;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerTimerSpan.textContent = '';s: 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼? + playerText + playerTimerSpan.outerHTML;
Â  Â  Â  Â  Â  S: }

Â  Â  Â  Â  Â  Â  showWinner() {
Â  Â  Â  Â  Â  Â  Â  Â  Â // åªæœ‰ AI æ¨¡å¼
Â  Â  Â  Â  Â  Â  Â  Â  let playerName = this.winner === 1 ? 'ä½? : 'ç¡•ç¥AI';

Â  Â  Â  Â  Â  Â  Â  Â  const message = document.getElementById('winnerMessage');
Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  let messageText = `ğŸ‰ ${playerName} è·èƒœï¼`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [å˜²è®½] AI è·èƒœæ—¶æ·»åŠ å˜²è®?
Â  Â  Â  Â  Â  Â  if (this.winner === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targets = ["å°å¼ºå¼?, "å°è¾‰è¾?];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = targets[Math.floor(Math.random() * targets.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let taunts = [ // ç¡•ç¥èƒœåˆ©å˜²è®½
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `8å±‚æœç´¢ï¼Œ${target}ä½ æ‹¿ä»€ä¹ˆèµ¢ï¼Ÿ`, `å‡¡äºº${target}ï¼Œä½ å°½åŠ›äº†ã€‚`, `æˆ‘çš„æ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ€ä¼˜è§£ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${target}, ä½ ç”šè‡³æ²¡èƒ½é€¼æˆ‘èµ°å‡ºå¼€å±€åº“ã€‚`, `ç»“æŸäº? ${target}, æ¸¸æˆæ‰åˆšåˆšå¼€å§‹ã€‚`,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `ä¸å ªä¸€å‡»ï¼Œ${target}ã€‚`, `å›å»å†ç»ƒç»ƒå§ï¼?{target}ï¼`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const taunt = taunts[Math.floor(Math.random() * taunts.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<span class="ai-taunt">${taunt}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // ç©å®¶è·èƒœè®°å½•æ—¶é—´
Â  Â  Â  Â  Â  Â  if (this.winner === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>â±ï¸ ç”¨æ—¶ï¼?{timeStr}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bestTimeKey = `bestTime_god`; // å›ºå®š Key
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentBest = localStorage.getItem(bestTimeKey);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
Â  Â  Â  Â  Â  S: Â  Â  Â  Â  Â  Â  localStorage.setItem(bestTimeKey, this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.loadBestTime();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>ğŸ† æ–°çºªå½•ï¼ä½ ç«Ÿç„¶æˆ˜èƒœäº†ç¡•ç¥åœ°ç‹±æ¨¡å¼ï¼Ÿï¼ä¼ è¯´è¯ç”Ÿï¼`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageText += `<br>ï¼ˆè™½ç„¶èµ¢äº†åœ°ç‹±æ¨¡å¼ï¼Œä½†æ²¡ç ´çºªå½•å“¦ï¼‰`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  message.innerHTML = messageText;
Â  Â  Â  Â  Â  Â  Â  Â  message.className = 'winner-message show';
Â  Â  Â  Â  Â  Â  Â  Â  message.style.color = this.winner === 1 ? '#4caf50' : '#d32f2f'; // ç©å®¶èµ¢ç»¿è‰²ï¼ŒAIèµ¢çº¢è‰?
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  showDraw() {
Â  Â  Â  Â  Â  Â  Â  Â  const message = document.getElementById('winnerMessage');
Â  Â  Â  Â  Â  Â  Â  message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»?;
Â  Â  Â  Â  Â  Â  Â  Â  message.className = 'winner-message show';
Â  Â  A: Â  Â  Â  Â  Â  message.style.color = '#ff9800';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¯åŠ¨ç©å®¶è®¡æ—¶å™?
Â  Â  Â  Â  Â  Â  startPlayerTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  // [ç©å®¶è®¡æ—¶.å¯åŠ¨é€»è¾‘ä¿®æ­£] ç¡®ä¿æ¸¸æˆæœªç»“æŸä¸”ç¡®å®è½®åˆ°ç©å®¶
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gameOver || this.currentPlayer !== 1) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer(); // å…ˆæ¸…é™¤æ—§çš?
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft = 5;
Â  Â  Â  Â  S: Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º (5s)
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimerId = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢è®¡æ—¶å™¨åœ¨ä¸è¯¥è·‘çš„æ—¶å€™è·‘
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver || this.currentPlayer !== 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  A: Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimeLeft--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.playerTimeLeft <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.forceRandomMove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 1000); // æ¯ç§’æ‰§è¡Œ
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  S: Â  Â  // åœæ­¢ç©å®¶è®¡æ—¶å™?
Â  Â  Â  Â  Â  Â  stopPlayerTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.playerTimerId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.playerTimerId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.playerTimerId = null; // æ¸…é™¤ ID å¾ˆé‡è¦?
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â // æ¸…é™¤è®¡æ—¶æ˜¾ç¤ºÂ 
Â  Â  Â  Â  Â  Â  Â  Â  Â const playerTimerSpan = document.getElementById('playerTimeLeft');
Â  Â  Â  Â  Â  Â  Â if(playerTimerSpan) playerTimerSpan.textContent = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â // ç¡®ä¿UIç«‹å³æ›´æ–°ä¸ºä¸å¸¦è®¡æ—¶å™¨çŠ¶æ€?(å¦‚æœå½“å‰æ˜¯ç©å®¶å›å?
Â  Â  Â  Â  Â  Â  Â  Â  Â if (!this.gameOver && this.currentPlayer === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.updateCurrentPlayer();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // å¼ºåˆ¶éšæœºè½å­
Â  Â  Â  Â  Â  Â  forceRandomMove() {
Â  Â  Â  Â  Â  Â  Â  Â  Â this.stopPlayerTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.gameOver || this.currentPlayer !== 1) return; // æ¸¸æˆå·²ç»“æŸæˆ–ä¸æ˜¯ç©å®¶å›åˆ
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("ç©å®¶è¶…æ—¶ï¼Œå¼ºåˆ¶éšæœºè½å­ï¼");
Â  Â  Â  Â  Â  Â  Â  Â  Â const randomMove = this.getRandomMoveForMainThread();
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â // çŸ­æš‚æç¤º
Â  Â  Â  Â  Â  Â  Â  Â  Â const aiThinkingEl = document.getElementById('aiThinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.innerHTML = `â?æ—¶é—´åˆ°ï¼å·²æ›¿ä½ éšæœºè½å­ï¼`;
Â  Â  Â  Â  Â  Â  Â  Â  Â // [UI ä¼˜åŒ–]
Â  Â  Â  Â  Â  Â  Â  Â  Â aiThinkingEl.style.visibility = 'visible';
Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â if (randomMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // å»¶è¿Ÿä¸€ç‚¹ç‚¹æ‰§è¡Œï¼Œè®©æç¤ºèƒ½è¢«çœ‹åˆ°
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // æ£€æŸ¥æ¸¸æˆæ˜¯å¦åœ¨å»¶è¿ŸæœŸé—´ç»“æŸäº†ï¼Œå¹¶ä¸”ç¡®è®¤ç°åœ¨æ˜¯ç©å®¶å›å?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver && this.currentPlayer === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.makeMove(randomMove.row, randomMove.col);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }, 500);
Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  s: aiThinkingEl.innerHTML = `â?æ—¶é—´åˆ°ï¼ä½†æ£‹ç›˜å·²æ»¡ï¼Ÿ`;
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  _internalReset() {
Â  Â  Â  Â  Â  Â  Â  Â  this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
Â  Â  Â  Â  Â  Â  Â  Â  this.currentPlayer = 2; // AI å…ˆæ‰‹
Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.winner = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.moveHistory = [];
Â  Â  Â  Â  Â  Â  Â  this.currentHash = 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer(); // åœæ­¢æ¸¸æˆæ€»è®¡æ—?
Â  Â  Â  Â  Â  Â  Â  Â  this.stopPlayerTimer(); // åœæ­¢ç©å®¶è®¡æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  this.elapsedTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay();
Â  Â  Â  Â  Â  Â  Â  document.getElementById('winnerMessage').className = 'winner-message';
Â  Â  Â  Â  Â  Â  Â  Â  // [UI ä¼˜åŒ–]
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('aiThinking').style.visibility = 'hidden';
Â  Â  Â  Â  Â  Â  Â  Â  this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
Â  Â  Â  Â  Â  Â  Â  Â  // updateCurrentPlayer ä¼šåœ¨ startNewGame ä¸­è°ƒç”?
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  startNewGame() {Â 
Â  Â  Â  Â  Â  Â  Â  Â  this._internalReset();
Â  Â  Â  Â  Â  Â  Â  Â  // [AIç¬æ—¶å¼€å±€.3] é‡å¼€æ¸¸æˆæ—¶ï¼Œä¹Ÿç«‹å³æ‰§è¡?AI ç¬¬ä¸€æ­?
Â  Â  Â  Â  Â  Â  Â  Â  Â // ä½¿ç”¨ setTimeout ç¡®ä¿ UI æ¸²æŸ“å®Œæˆåå†æ‰§è¡Œ
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  D: Â  Â  Â  Â  Â  Â  Â  Â this.performAiFirstMove();
Â  Â  Â  Â  Â  Â  Â  Â  }, 0);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  startTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.timerInterval) return; // é˜²æ­¢é‡å¤å¯åŠ¨
Â  Â  Â  Â  Â  Â  Â  Â  this.startTime = Date.now() - this.elapsedTime;
Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // åªæœ‰æ¸¸æˆè¿›è¡Œä¸­æ‰è®¡æ—¶
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.gameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  s: this.elapsedTime = Date.now() - this.startTime;
Â  Â  Â  Â  Â  Â  Â  S: Â  Â  Â  Â  this.updateTimerDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopTimer(); // æ¸¸æˆç»“æŸï¼Œåœæ­¢è®¡æ—?
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 100);Â 
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  stopTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.timerInterval) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.timerInterval);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.timerInterval = null;
Â  g: Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimerDisplay() {
Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(this.elapsedTime);
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('currentTime').textContent = timeStr;
Â  Â  css: Â  Â  }

Â  Â  Â  Â  Â  Â  formatTime(ms) {
Â  Â  Â  Â  Â  Â  Â  Â  const totalSeconds = Math.floor(ms / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(totalSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = totalSeconds % 60;
Â  Â  Â  Â  Â  Â  Â  Â  return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadBestTime() {
Â  Â  Â  Â  Â  Â  Â  Â  const bestTimeKey = `bestTime_god`; // å›ºå®š Key
Â  Â  Â  Â  Â  Â  Â  Â  const bestTime = localStorage.getItem(bestTimeKey);

Â  Â  Â  Â  Â  Â  Â  Â  if (bestTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const timeStr = this.formatTime(parseInt(bestTime));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('bestTime').textContent = timeStr;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('bestTime').textContent = '--:--';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  // å¯åŠ¨é€»è¾‘ (UI çº¿ç¨‹)
Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  let game;Â 

Â  Â  Â  Â  function restartGame() {
Â  Â  Â  Â  Â  Â  if (!game) return;
Â  Â  Â  Â  Â  Â  if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿï¼ˆç¡•ç¥åœ°ç‹±æ¨¡å¼AIå°†ç«‹å³åœ¨å¤©å…ƒè½å­ï¼?)) {
Â  Â  Â  Â  Â  Â  Â  Â  game.startNewGame();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ç­‰å¾…HTMLåŠ è½½å®Œæ¯•åï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆ
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  // ç›´æ¥åˆå§‹åŒ–ç¡•ç¥æ¨¡å¼?
Â  Â  Â  Â  Â  Â  game = new GomokuGame();
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // æ›´æ–°è§„åˆ™æ–‡æœ¬
Â  Â  Â  Â  Â  Â  const rulesList = document.getElementById('rules-list'); // Get the list by ID
Â  Â  Â  Â  Â  Â  // æ¸…ç©ºæ—§è§„åˆ?(å¦‚æœå­˜åœ¨)
Â  Â  Â  Â  Â  Â  while (rulesList.firstChild) {
Â  g: Â  Â  Â  Â  Â  Â  Â rulesList.removeChild(rulesList.firstChild);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // æ·»åŠ æ–°è§„åˆ?
Â  Â  Â  Â  Â  Â  const rules = [
Â  Â  Â  Â  Â  Â  Â  Â  Â 'ğŸ”¥ **ç¡•ç¥åœ°ç‹±æ¨¡å¼**: AIæ‰§ç™½æ£?(2) **ç«‹å³**åœ¨å¤©å…ƒè½å­å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­?,
Â  Â  Â  Â  Â  Â  Â  Â  Â 'å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼?,
Â  Â  Â  Â  Â  Â  Â  Â 'ç©å®¶**ç¬¬ä¸€æ­¥å**æ¯æ­¥æ€è€ƒæ—¶é—´ä¸å¾—è¶…è¿?ç§’ï¼Œè¶…æ—¶å°†éšæœºè½å­?,
Â  Â  Â  Â  Â  Â  Â  Â  Â 'AI æ¯æ­¥æ€è€ƒæ—¶é—´ä¸Šé™?ç§’ï¼ˆVCFæ·±åº¦20ï¼ŒVCTæ·±åº¦15ï¼ŒMinimaxæ·±åº¦8ï¼?,
Â  Â  Â  Â  Â  Â  Â  Â '**æ— æ‚”æ£?*'
Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  Â rules.forEach(ruleText => {
Â  Â  Â  Â  Â  Â  Â  Â  Â const li = document.createElement('li');
Â  Â  Â  Â  Â  Â  Â  Â  Â li.innerHTML = ruleText; // ä½¿ç”¨ innerHTML æ”¯æŒåŠ ç²—
Â  Â  Â  Â  Â  Â  Â  Â  Â rulesList.appendChild(li);
Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>