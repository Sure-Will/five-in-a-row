<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹æ¸¸æˆ - æŒ‘æˆ˜ç¡•ç¥</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 20px;
        }
        .container {
            background: white; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px; max-width: 850px; width: 100%;
        }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 1.1em; }
        .difficulty-selector { display: flex; justify-content: center; margin-bottom: 20px; align-items: center; }
        .diff-label { font-weight: bold; margin-right: 10px; font-size: 1.1em;}
        .god-mode-active {
             padding: 10px 20px; font-size: 1.1em; border-radius: 10px;
             background: #f44336; color: white; font-weight: bold;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .game-info {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px;
        }
        .current-player { font-size: 1.3em; font-weight: bold; color: #333; }
        #playerTimeLeft { font-size: 0.8em; color: #f44336; margin-left: 8px; font-weight: normal; }
        .player-black { color: #000; }
        .player-white { color: #666; }
        .controls { display: flex; gap: 10px; }
        button {
            padding: 10px 20px; font-size: 1em; border: none; border-radius: 8px;
            cursor: pointer; transition: all 0.3s; font-weight: bold;
        }
        .btn-restart { background: #4caf50; color: white; }
        .btn-restart:hover { background: #45a049; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .board-container { display: flex; justify-content: center; margin: 20px 0; }
        #gameBoard {
            background: #daa520; border: 3px solid #8b6914;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); cursor: pointer;
            max-width: 100%; height: auto;
        }
        .winner-message {
            text-align: center; font-size: 1.5em; font-weight: bold; color: #4caf50;
            margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 10px; display: none;
        }
        .winner-message.show { display: block; animation: slideDown 0.5s ease; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .instructions { background: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; }
        .instructions h3 { color: #1976d2; margin-bottom: 10px; }
        .instructions ul { list-style-position: inside; color: #333; line-height: 1.8; }
        .ai-thinking { text-align: center; font-size: 1.1em; color: #ff9800; margin: 10px 0; font-weight: bold; }
        .step-taunt { display: block; font-size: 0.9em; color: #e91e63; margin-top: 5px; }
        .timer-container {
            display: flex; justify-content: center; align-items: center; gap: 20px;
            margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px; color: white;
        }
        .timer-item { text-align: center; }
        .timer-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
        .timer-value { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
        .best-time { color: #ffd700; }
        .ai-taunt { font-size: 0.8em; color: #f44336; font-weight: bold; display: block; margin-top: 10px; }
        @media (max-width: 600px) {
            .container { padding: 15px; } h1 { font-size: 1.8em; }
            .game-info { flex-direction: column; gap: 10px; }
            .controls { flex-wrap: wrap; justify-content: center; }
            .timer-container { flex-direction: column; gap: 10px; } .timer-value { font-size: 1.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® äº”å­æ£‹</h1>
        <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

         <div class="difficulty-selector">
            <span class="diff-label">å½“å‰æ¨¡å¼ï¼š</span>
            <span class="god-mode-active">ğŸ”¥ ç¡•ç¥æ¨¡å¼</span>
        </div>


        <div class="game-info">
            <div class="current-player" id="currentPlayer">
                å½“å‰ç©å®¶ï¼š<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span> <span id="playerTimeLeft"></span>
            </div>
            <div class="controls">
                <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
        </div>

        <div class="ai-thinking" id="aiThinking" style="display: none;">ğŸ¤– AIæ€è€ƒä¸­...</div>

        <div class="timer-container">
            <div class="timer-item">
                <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
                <div class="timer-value" id="currentTime">00:00</div>
            </div>
            <div class="timer-item">
                <div class="timer-label">ğŸ† æœ€ä½³è®°å½• (ç¡•ç¥æ¨¡å¼)</div>
                <div class="timer-value best-time" id="bestTime">--:--</div>
            </div>
        </div>

        <div class="winner-message" id="winnerMessage"></div>

        <div class="board-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="instructions">
            <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
            <ul id="rules-list"> {/* Gave the list an ID for easier modification */}
                {/* Rules will be added by JS */}
            </ul>
        </div>
    </div>
    
    <script id="ai-worker-script" type="text/worker-script">
        
        // --- Worker å†…çš„å…¨å±€å˜é‡ ---
        let board, boardSize, maxDepth; // ç§»é™¤äº† difficulty
        let zobristTable, currentHash, moveHistory;
        let transpositionTable = new Map();
        
        const TIMEOUT_MS = 10000; // 10 ç§’ AI ç†”æ–­

        // --- æ ¸å¿ƒå…¥å£ï¼šæ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯ ---
        self.onmessage = function(e) {
            const data = e.data;
            
            // 1. æ›´æ–° Worker çš„å†…éƒ¨çŠ¶æ€
            board = data.board;
            boardSize = data.boardSize;
            maxDepth = data.maxDepth; // ç¡•ç¥(6)
            zobristTable = data.zobristTable;
            currentHash = data.currentHash;
            moveHistory = data.moveHistory;
            
            // 2. æ¯æ¬¡ AI æ€è€ƒæ—¶ï¼Œéƒ½é‡ç½®ç½®æ¢è¡¨
            transpositionTable.clear();
            
            const startTime = performance.now();
            let moveResult = {};

            // 3. å§‹ç»ˆè°ƒç”¨ç¡•ç¥æ¨¡å¼çš„è¿­ä»£åŠ æ·±
            moveResult = getBestMoveIDDFS(startTime, maxDepth);

            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);

            // 4. å°†ç»“æœå‘å›ä¸»çº¿ç¨‹
            self.postMessage({
                move: moveResult.move,
                duration: duration,
                depth: moveResult.depth,
                type: moveResult.type || 'Minimax' // ç®—æ³•ç±»å‹: VCF, VCT, Minimax
            });
        };
        
        // --- AI ç®—æ³• ---
        
        function getHardMove() { // ä¿ç•™ä½œä¸º IDDFS è¶…æ—¶çš„å¤‡ç”¨é€»è¾‘
            let bestScore = -Infinity;
            let bestMove = null;
            // 1. æ£€æŸ¥AIå¿…èƒœ
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = 2; // AI
                        if (checkWin(i, j)) { board[i][j] = 0; return { row: i, col: j }; }
                        board[i][j] = 0;
                    }
                }
            }
            // 2. æ£€æŸ¥ç©å®¶å¿…èƒœ (é˜²å®ˆ)
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = 1; // ç©å®¶
                        if (checkWin(i, j)) { board[i][j] = 0; return { row: i, col: j }; }
                        board[i][j] = 0;
                    }
                }
            }
            // 3. æ­£å¸¸è¯„åˆ†
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        const score = evaluatePositionAdvanced(i, j);
                        if (score > bestScore) { bestScore = score; bestMove = { row: i, col: j }; }
                    }
                }
            }
             // å›°éš¾æ¨¡å¼å¢åŠ éšæœºæ€§ï¼Œé¿å…å®Œå…¨ä¸€æ ·
            const emptyPositions = [];
            for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) emptyPositions.push({ row: i, col: j }); } }
            return bestMove || (emptyPositions.length > 0 ? emptyPositions[Math.floor(Math.random() * emptyPositions.length)] : null);
        }
        
        // è¿­ä»£åŠ æ·± (IDDFS) å…¥å£ - ç¡•ç¥æ¨¡å¼ä¸“ç”¨ + VCF/VCT å¨èƒæœç´¢
        function getBestMoveIDDFS(startTime, maxDepth) {
            const openingMove = getOpeningMove();
            if (openingMove) {
                return { move: openingMove, depth: 1, timedOut: false };
            }

            // ========== ä¼˜å…ˆçº§1ï¼šVCF æœç´¢ï¼ˆæ´»å››/å†²å››å¿…æ€ï¼‰==========
            const vcfResult = searchVCF(10, 2, startTime); // AI=2, æœ€å¤§æ·±åº¦10
            if (vcfResult && vcfResult.move) {
                return { move: vcfResult.move, depth: vcfResult.depth, type: 'VCF', score: 10000000 };
            }

            // ========== ä¼˜å…ˆçº§2ï¼šVCT æœç´¢ï¼ˆæ´»ä¸‰å¨èƒåºåˆ—ï¼‰==========
            const vctResult = searchVCT(8, 2, startTime); // AI=2, æœ€å¤§æ·±åº¦8
            if (vctResult && vctResult.move) {
                return { move: vctResult.move, depth: vctResult.depth, type: 'VCT', score: 5000000 };
            }

            // ========== ä¼˜å…ˆçº§3ï¼šä¼ ç»Ÿ Minimax ==========
            let bestMove = null;
            let bestScore = -Infinity;
            let completedDepth = 0;

            // è¿­ä»£åŠ æ·±: æœç´¢æ·±åº¦ 2, 4, 6, ... ç›´åˆ° maxDepth
            for (let d = 2; d <= maxDepth; d += 2) {

                const currentTime = performance.now();
                if ((currentTime - startTime) > TIMEOUT_MS) {
                    break;
                }

                const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

                if (result.timedOut) {
                    break;
                }

                bestMove = result.move;
                bestScore = result.score;
                completedDepth = d;

                if (bestScore > 9000000) {
                    break;
                }
            }

            // å¦‚æœè¶…æ—¶æˆ–æœç´¢æœªå®Œæˆ
            if (bestMove === null) {
                bestMove = getHardMove(); // ä½¿ç”¨å›°éš¾æ¨¡å¼æ‰¾ä¸€æ­¥æ£‹
                completedDepth = completedDepth || 1; // è‡³å°‘ç®—1å±‚ï¼ˆå›°éš¾æ¨¡å¼ï¼‰
            }

            return { move: bestMove, score: bestScore, depth: completedDepth, type: 'Minimax' };
        }

        // æ ¸å¿ƒï¼šå¸¦ Alpha-Beta å‰ªæçš„ Minimax
        function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
            
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return { score: 0, timedOut: true }; 
            }

            const hash = currentHash;
            const cached = transpositionTable.get(hash);
            if (cached && cached.depth >= depth) {
                return { score: cached.score, timedOut: false };
            }

            if (depth === 0) {
                const score = evaluateBoardHeuristic();
                return { score: score, timedOut: false };
            }

            const validMoves = getValidMoves(true); // true = å¸¦æ’åº

            if (validMoves.length === 0) {
                return { score: 0, timedOut: false }; // å¹³å±€
            }

            let bestMove = null;
            let timedOut = false;

            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                bestMove = validMoves[0]; 

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 2); // AI (2)
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = 10000000 + depth; // å¿…èƒœ (10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
                        if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 2);
                    
                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            
            } else { // è½®åˆ° Min (ç©å®¶)
                let bestScore = +Infinity;
                bestMove = validMoves[0];

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 1); // ç©å®¶ (1)
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = -10000000 - depth; // å¿…è´¥ (-10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
                         if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 1);

                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            }
        }

        // æ¨¡æ‹Ÿè½å­ (åªæ”¹æ£‹ç›˜å’Œå“ˆå¸Œ)
        function _simulateMove(row, col, player) {
            board[row][col] = player;
            currentHash ^= zobristTable[row][col][player - 1];
        }
        // æ¨¡æ‹Ÿæ‚”æ£‹
        function _simulateUndo(row, col, player) {
            board[row][col] = 0;
            currentHash ^= zobristTable[row][col][player - 1];
        }

        // å¼€å±€åº“ - ç¡•ç¥æ¨¡å¼ä¸“ç”¨ (AI å…ˆæ‰‹)
        function getOpeningMove() {
            const center = Math.floor(boardSize / 2);
            // AI ç¬¬ä¸€æ­¥ï¼šèµ°å¤©å…ƒ (æ­¤é€»è¾‘åœ¨ä¸»çº¿ç¨‹å¤„ç†äº†ï¼ŒWorkerä¸éœ€è¦)
            
            // AI ç¬¬äºŒæ­¥ (åº”å¯¹ç©å®¶çš„ç¬¬1æ­¥)
            if (boardSize === 15 && moveHistory.length === 2) {
                const centerMove = moveHistory[0]; // AI (2)
                const userMove = moveHistory[1];   // Player (1)
                // ç¡®ä¿AIç¬¬ä¸€æ­¥æ˜¯å¤©å…ƒ 
                if (centerMove.row !== center || centerMove.col !== center) return null; 

                const dr = userMove.row - centerMove.row; 
                const dc = userMove.col - centerMove.col; 

                let aiMove = null;
                // è§„åˆ™1: ç©å®¶èµ°æ–œè§’ -> AIèµ°ç›´çº¿ç›¸é‚»
                if (Math.abs(dr) === 1 && Math.abs(dc) === 1) { 
                    aiMove = { row: centerMove.row + dr, col: centerMove.col }; 
                } 
                // è§„åˆ™2: ç©å®¶èµ°ç›´çº¿ç›¸é‚» -> AIèµ°æ–œè§’ç›¸é‚»
                else if ((Math.abs(dr) === 1 && dc === 0) || (dr === 0 && Math.abs(dc) === 1)) { 
                    aiMove = { row: centerMove.row + dc, col: centerMove.col + dr }; 
                }
                // æ£€æŸ¥è®¡ç®—å‡ºçš„ä½ç½®æ˜¯å¦åœ¨æ£‹ç›˜å†…ä¸”ä¸ºç©º
                if (aiMove && 
                    aiMove.row >= 0 && aiMove.row < boardSize &&
                    aiMove.col >= 0 && aiMove.col < boardSize &&
                    board[aiMove.row][aiMove.col] === 0) { 
                    return aiMove;
                }
            }
            return null;
        }

        // è·å–æœ‰æ•ˆèµ°æ³• (å¯å¸¦æ’åº)
        function getValidMoves(withOrdering = false) {
            const moveSet = new Set();
            const center = Math.floor(boardSize / 2);

            // åˆå§‹çŠ¶æ€ï¼ˆè™½ç„¶AIå·²èµ°å¤©å…ƒï¼Œä½†ä»¥é˜²ä¸‡ä¸€ï¼‰
            if (moveHistory.length === 0) {
                 return [{ row: center, col: center }];
            }
            // ç©å®¶ç¬¬ä¸€æ­¥ï¼ˆAIå·²èµ°å¤©å…ƒï¼‰
            if (moveHistory.length === 1) {
                 // ç©å®¶ç¬¬ä¸€æ­¥å¯ä»¥åœ¨å¤©å…ƒé™„è¿‘ä»»æ„ä½ç½®
                 const moves = [];
                 for(let dr = -1; dr <= 1; dr++) {
                     for(let dc = -1; dc <=1; dc++) {
                         if (dr === 0 && dc === 0) continue;
                         const r = center + dr;
                         const c = center + dc;
                         if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) {
                             moves.push({row: r, col: c});
                         }
                     }
                 }
                 // [å¼€å±€ä¼˜åŒ–] é™åˆ¶ç©å®¶ç¬¬ä¸€æ­¥åœ¨å¤©å…ƒæ— (å¯é€‰)
                 // return moves; 
            }
            
            // æ­£å¸¸æœç´¢
            const radius = 2; // åªæœç´¢æ£‹å­å‘¨å›´2æ ¼
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] === 0) continue; 
                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = r + dr;
                            const nc = c + dc;
                            
                            if (nr >= 0 && nr < boardSize && 
                                nc >= 0 && nc < boardSize && 
                                board[nr][nc] === 0) 
                            {
                                moveSet.add(`${nr},${nc}`);
                            }
                        }
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰ä»»ä½•é‚»è¿‘çš„ç©ºç‚¹ (æ£‹ç›˜å‡ ä¹æ»¡äº†?)ï¼Œè¿”å›æ‰€æœ‰ç©ºç‚¹
            if (moveSet.size === 0) {
                 for (let r = 0; r < boardSize; r++) {
                     for (let c = 0; c < boardSize; c++) {
                         if (board[r][c] === 0) {
                             moveSet.add(`${r},${c}`);
                         }
                     }
                 }
            }

            
            const moves = Array.from(moveSet).map(s => {
                const [row, col] = s.split(',').map(Number);
                return { row, col };
            });

            if (withOrdering) {
                const scoredMoves = moves.map(move => {
                    const score = evaluatePositionAdvanced(move.row, move.col);
                    return { move, score };
                });
                scoredMoves.sort((a, b) => b.score - a.score);
                return scoredMoves.map(item => item.move);
            }
            return moves;
        }

        // é™æ€æ£‹ç›˜è¯„ä¼° (Minimax å¶èŠ‚ç‚¹ç”¨)
        function evaluateBoardHeuristic() {
            let totalScore = 0;
            const validMoves = getValidMoves(false); 
            
            for (const move of validMoves) {
                totalScore += evaluatePositionAdvanced(move.row, move.col);
            }
            return totalScore;
        }

        // è¯„ä¼° (r, c) è¿™ä¸ª *ç©ºç‚¹* çš„ä»·å€¼ (æ”»+é˜²)
        function evaluatePositionAdvanced(row, col) {
            let score = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (let [dr, dc] of directions) {
                const aiScore = evaluateLine(row, col, dr, dc, 2); // AI åœ¨æ­¤è½å­
                const playerScore = evaluateLine(row, col, dr, dc, 1); // ç©å®¶åœ¨æ­¤è½å­
                score += aiScore + (playerScore * 1.1); 
            }

            const center = Math.floor(boardSize / 2);
            const distToCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (boardSize - distToCenter) * 0.5;

            return score;
        }

        // è¯„ä¼°åœ¨ (r, c) è½å­åï¼Œåœ¨ [dr, dc] æ–¹å‘ä¸Šçš„è¿ç æƒ…å†µ
        function evaluateLine(row, col, dr, dc, player) {
            let count = 0; 
            let blocks = 0; 
            
            // æ‰«ææ­£æ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row + dr * i;
                const c = col + dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++; break; }
                if (board[r][c] === player) { count++; } 
                else if (board[r][c] === 0) { break; } 
                else { blocks++; break; }
            }

            // æ‰«æåæ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row - dr * i;
                const c = col - dc * i;
                 if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++; break; }
                if (board[r][c] === player) { count++; } 
                else if (board[r][c] === 0) { break; } 
                else { blocks++; break; }
            }
            
            // --- è¯„åˆ†è¡¨ ---
            if (count >= 4) return 10000000; // æˆäº” (10M)
            if (count === 3 && blocks === 0) return 1000000; // æ´»å›› (1M)
            if (count === 2 && blocks === 0) return 50000;   // æ´»ä¸‰ (50K)
            if (count === 3 && blocks === 1) return 10000;  // å†²å›› (10K)
            if (count === 2 && blocks === 1) return 500;   // çœ ä¸‰
            if (count === 1 && blocks === 0) return 100;    // æ´»äºŒ
            if (count === 1 && blocks === 1) return 10;    // çœ äºŒ
            
            return 0;
        }

        // æ£€æŸ¥èƒœåˆ©
        function checkWin(row, col) {
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            const player = board[row][col];
            if (player === 0) return false;

            for (let [dr, dc] of directions) {
                let count = 1;
                let r = row + dr, c = col + dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
                       board[r][c] === player) {
                    count++; r += dr; c += dc;
                }
                r = row - dr; c = col - dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
                       board[r][c] === player) {
                    count++; r -= dr; c -= dc;
                }
                if (count >= 5) {
                    return true;
                }
            }
            return false;
        }

        // ============================================================
        // VCF/VCT å¨èƒæœç´¢ç®—æ³•
        // ============================================================

        // è·å–æŸä¸ªä½ç½®åœ¨æŸä¸ªæ–¹å‘çš„æ¨¡å¼ç±»å‹
        function getPatternType(row, col, dr, dc, player) {
            if (board[row][col] !== 0) return 'NONE';

            let count = 0;
            let blocks = 0;
            let spaces = 0; // ç©ºä½æ•°ï¼ˆç”¨äºæ£€æµ‹è·³æ£‹ï¼‰

            // æ‰«ææ­£æ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row + dr * i;
                const c = col + dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++; break;
                }
                if (board[r][c] === player) {
                    count++;
                } else if (board[r][c] === 0) {
                    spaces++;
                    if (spaces > 1) break; // è·³ä¸€æ ¼åç»§ç»­ï¼Œè·³ä¸¤æ ¼åœæ­¢
                } else {
                    blocks++; break;
                }
            }

            // æ‰«æåæ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row - dr * i;
                const c = col - dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++; break;
                }
                if (board[r][c] === player) {
                    count++;
                } else if (board[r][c] === 0) {
                    spaces++;
                    if (spaces > 1) break;
                } else {
                    blocks++; break;
                }
            }

            // åˆ¤æ–­æ¨¡å¼
            if (count >= 4) return 'WIN';
            if (count === 3 && blocks === 0) return 'LIVE_FOUR';
            if (count === 3 && blocks === 1) return 'RUSH_FOUR';
            if (count === 2 && blocks === 0) return 'LIVE_THREE';
            if (count === 2 && blocks === 1) return 'SLEEP_THREE';
            if (count === 1 && blocks === 0) return 'LIVE_TWO';

            return 'NONE';
        }

        // æ£€æŸ¥æŸä¸ªä½ç½®æ˜¯å¦èƒ½å½¢æˆæŒ‡å®šçº§åˆ«çš„å¨èƒ
        function hasPattern(row, col, player, threatLevel) {
            if (board[row][col] !== 0) return false;

            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (let [dr, dc] of directions) {
                const pattern = getPatternType(row, col, dr, dc, player);

                if (threatLevel === 'VCF') {
                    // VCF: åªæ£€æµ‹æ´»å››å’Œå†²å››
                    if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' || pattern === 'WIN') {
                        return true;
                    }
                } else if (threatLevel === 'VCT') {
                    // VCT: æ£€æµ‹æ´»ä¸‰åŠä»¥ä¸Š
                    if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' ||
                        pattern === 'LIVE_THREE' || pattern === 'WIN') {
                        return true;
                    }
                }
            }
            return false;
        }

        // ç”Ÿæˆå¨èƒèµ°æ³•
        function generateThreatMoves(player, threatLevel) {
            const threats = [];
            const moveSet = new Set();

            // åªæœç´¢å·²æœ‰æ£‹å­å‘¨å›´2æ ¼
            const radius = 2;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] === 0) continue;

                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            const nr = r + dr;
                            const nc = c + dc;

                            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize &&
                                board[nr][nc] === 0) {
                                const key = `${nr},${nc}`;
                                if (!moveSet.has(key) && hasPattern(nr, nc, player, threatLevel)) {
                                    threats.push({ row: nr, col: nc });
                                    moveSet.add(key);
                                }
                            }
                        }
                    }
                }
            }

            return threats;
        }

        // ç”Ÿæˆé˜²å®ˆèµ°æ³•ï¼ˆé˜²å®ˆæŸä¸ªå¨èƒç‚¹ï¼‰
        function generateDefenseMoves(threatMove, opponent) {
            const defMoves = [];
            const player = (opponent === 1) ? 2 : 1; // å¨èƒæ–¹

            // ç®€åŒ–ç­–ç•¥ï¼šåœ¨å¨èƒç‚¹å‘¨å›´1-2æ ¼å†…æ‰¾é˜²å®ˆç‚¹
            const radius = 2;
            for (let dr = -radius; dr <= radius; dr++) {
                for (let dc = -radius; dc <= radius; dc++) {
                    const r = threatMove.row + dr;
                    const c = threatMove.col + dc;

                    if (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
                        board[r][c] === 0) {

                        // æ£€æŸ¥è¿™ä¸ªç‚¹æ˜¯å¦èƒ½é˜»æ­¢å¨èƒæ–¹å½¢æˆäº”è¿
                        board[r][c] = opponent;
                        board[threatMove.row][threatMove.col] = player;
                        const stillThreat = checkWin(threatMove.row, threatMove.col);
                        board[r][c] = 0;
                        board[threatMove.row][threatMove.col] = 0;

                        if (!stillThreat) {
                            defMoves.push({ row: r, col: c });
                        }
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é˜²å®ˆç‚¹ï¼Œè¿”å›å¨èƒç‚¹æœ¬èº«
            if (defMoves.length === 0 && board[threatMove.row][threatMove.col] === 0) {
                defMoves.push(threatMove);
            }

            return defMoves;
        }

        // VCF æ±‚è§£å™¨ï¼šæœç´¢æ´»å››/å†²å››çš„å¿…æ€åºåˆ—
        function searchVCF(depth, player, startTime) {
            if (depth <= 0) return null;

            // è¶…æ—¶æ£€æŸ¥
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return null;
            }

            const opponent = (player === 1) ? 2 : 1;

            // 1. ç”Ÿæˆæ‰€æœ‰"å››"çš„å¨èƒ
            const fourMoves = generateThreatMoves(player, 'VCF');

            if (fourMoves.length === 0) return null;

            for (const move of fourMoves) {
                _simulateMove(move.row, move.col, player);

                // 2. å¦‚æœç›´æ¥æˆäº”ï¼Œæ‰¾åˆ°VCF
                if (checkWin(move.row, move.col)) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }

                // 3. å¯¹æ‰‹å¿…é¡»é˜²å®ˆ
                const defMoves = generateDefenseMoves(move, opponent);

                // 4. æ£€æŸ¥å¯¹æ‰‹çš„æ¯ä¸ªé˜²å®ˆï¼ŒAIæ˜¯å¦éƒ½èƒ½ç»§ç»­VCF
                let allDefLeadToVCF = true;

                if (defMoves.length === 0) {
                    // æ— æ³•é˜²å®ˆï¼Œè¯´æ˜å·²ç»å¿…èƒœ
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }

                for (const def of defMoves) {
                    _simulateMove(def.row, def.col, opponent);

                    const nextVCF = searchVCF(depth - 1, player, startTime);

                    _simulateUndo(def.row, def.col, opponent);

                    if (!nextVCF) {
                        allDefLeadToVCF = false;
                        break;
                    }
                }

                _simulateUndo(move.row, move.col, player);

                if (allDefLeadToVCF && defMoves.length > 0) {
                    return { move: move, depth: depth };
                }
            }

            return null;
        }

        // VCT æ±‚è§£å™¨ï¼šæœç´¢æ´»ä¸‰+æ´»å››çš„å¨èƒåºåˆ—ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function searchVCT(depth, player, startTime) {
            if (depth <= 0) return null;

            // è¶…æ—¶æ£€æŸ¥
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return null;
            }

            const opponent = (player === 1) ? 2 : 1;

            // 1. ç”Ÿæˆå¨èƒèµ°æ³•ï¼ˆæ´»ä¸‰åŠä»¥ä¸Šï¼‰
            const threatMoves = generateThreatMoves(player, 'VCT');

            if (threatMoves.length === 0) return null;

            // ä¼˜å…ˆé€‰æ‹©æ›´å¼ºçš„å¨èƒï¼ˆæ´»å›› > å†²å›› > æ´»ä¸‰ï¼‰
            threatMoves.sort((a, b) => {
                const scoreA = evaluatePositionAdvanced(a.row, a.col);
                const scoreB = evaluatePositionAdvanced(b.row, b.col);
                return scoreB - scoreA;
            });

            // åªå°è¯•å‰3ä¸ªæœ€å¼ºå¨èƒï¼ˆé¿å…åˆ†æ”¯çˆ†ç‚¸ï¼‰
            const topMoves = threatMoves.slice(0, 3);

            for (const move of topMoves) {
                _simulateMove(move.row, move.col, player);

                // å¦‚æœç›´æ¥æˆäº”
                if (checkWin(move.row, move.col)) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }

                // æ£€æŸ¥æ˜¯å¦å½¢æˆVCFï¼ˆæ´»å››/å†²å››ï¼‰
                const vcfAfterThis = searchVCF(depth - 1, player, startTime);
                if (vcfAfterThis) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }

                // å¯¹æ‰‹é˜²å®ˆ
                const defMoves = generateDefenseMoves(move, opponent);

                if (defMoves.length === 0) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }

                let allDefLeadToVCT = true;

                for (const def of defMoves) {
                    _simulateMove(def.row, def.col, opponent);

                    // é€’å½’æ£€æŸ¥VCTæˆ–VCF
                    const nextThreat = searchVCF(depth - 1, player, startTime) ||
                                      searchVCT(depth - 1, player, startTime);

                    _simulateUndo(def.row, def.col, opponent);

                    if (!nextThreat) {
                        allDefLeadToVCT = false;
                        break;
                    }
                }

                _simulateUndo(move.row, move.col, player);

                if (allDefLeadToVCT && defMoves.length > 0) {
                    return { move: move, depth: depth };
                }
            }

            return null;
        }

    </script>
    
    <script>
        class GomokuGame {
            constructor() { 
                this.boardSize = 15; // å›ºå®šä¸º 15
                
                const maxCanvasWidth = 500;
                this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                // [AIç¬æ—¶å¼€å±€] åˆå§‹ currentPlayer è®¾ä¸º 2 (AI)ï¼Œä½† UI ä¸Šä¼šæ˜¾ç¤ºç©å®¶
                this.currentPlayer = 2; 
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.gameMode = 'ai'; // å›ºå®šä¸º AI
                this.difficulty = 'god'; // å›ºå®šä¸º god
                
                // è®¡æ—¶å™¨ç›¸å…³
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;
                
                this.playerTimerId = null;
                this.playerTimeLeft = 10; // ç§’

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                // AI æ ¸å¿ƒ
                this.GOD_DEPTH = 6;       // ç¥(6)
                this.zobristTable = [];
                this.currentHash = 0;
                this.initZobrist();
                
                // åˆå§‹åŒ– Web Worker
                try {
                    const workerScript = document.getElementById('ai-worker-script').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    this.aiWorker = new Worker(URL.createObjectURL(blob));
                    
                    this.aiWorker.onmessage = (e) => {
                        this.receiveAiMove(e.data);
                    };
                } catch (error) {
                    console.error("æ— æ³•åˆ›å»º AI Worker: ", error);
                    alert("åŠ è½½AIçº¿ç¨‹å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§æˆ–åˆ·æ–°é¡µé¢ã€‚");
                }


                this.initCanvas();
                this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
                this.setupEventListeners();
                this.loadBestTime();
                
                // [AIç¬æ—¶å¼€å±€.1] å»¶è¿Ÿæ‰§è¡Œ AI çš„ç¬¬ä¸€æ­¥ï¼Œç¡®ä¿ UI å…ˆæ¸²æŸ“
                setTimeout(() => {
                    this.performAiFirstMove(); 
                }, 0); 
            }
            
            // [AIç¬æ—¶å¼€å±€.2] (æ–°å¢) AI ç¬¬ä¸€æ­¥é€»è¾‘
            performAiFirstMove() {
                // ç¡®ä¿åªåœ¨æ¸¸æˆå¼€å§‹æ—¶æ‰§è¡Œä¸€æ¬¡
                if (this.moveHistory.length === 0 && !this.gameOver) {
                    const center = Math.floor(this.boardSize / 2);
                    if (this.board[center][center] === 0) {
                        
                        console.log("AI performs instant first move.");
                        
                        // ç›´æ¥ä¿®æ”¹çŠ¶æ€ï¼Œä¸é€šè¿‡ makeMove (é¿å…è§¦å‘è®¡æ—¶å™¨ç­‰)
                        this.board[center][center] = 2; // AI (ç™½æ£‹) è½å­
                        this.moveHistory.push({ row: center, col: center, player: 2 });
                        this.currentHash ^= this.zobristTable[center][center][1]; // æ›´æ–°å“ˆå¸Œ
                        this.currentPlayer = 1; // è½®åˆ°ç©å®¶
                        
                        this.drawBoard(); // é‡ç»˜æ£‹ç›˜ï¼Œæ˜¾ç¤ºAIçš„ç¬¬ä¸€é¢—å­
                        this.updateCurrentPlayer(); // æ›´æ–°UIæ˜¾ç¤ºè½®åˆ°ç©å®¶ (æ­¤æ—¶è¿˜ä¸è®¡æ—¶)
                    }
                }
            }

            
            // åˆå§‹åŒ– Zobrist å“ˆå¸Œè¡¨ (ä¸»çº¿ç¨‹)
            initZobrist() {
                this.zobristTable = Array(this.boardSize).fill(null).map(() => 
                    Array(this.boardSize).fill(null).map(() => 
                        Array(2).fill(null) // 2ä¸ªç©å®¶
                    )
                );
                
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        for (let k = 0; k < 2; k++) {
                            this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        }
                    }
                }
                this.currentHash = 0;
            }


            initCanvas() {
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
            }

            drawBoard() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const boardSize = this.boardSize;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#daa520';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < boardSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
                    ctx.stroke();
                }

                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½ (15x15)
                const drawDot = (x, y) => {
                    ctx.beginPath();
                    ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                };
                
                drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
                drawDot(11, 11); drawDot(7, 7); 

                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }
                
                // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    if (lastMove.player === 2) {
                        this.highlightLastMove(lastMove.row, lastMove.col);
                    }
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                if (player === 1) { // ç©å®¶é»‘æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else { // AI ç™½æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                }
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            highlightLastMove(row, col) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.15; 
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; 
                ctx.fill();
            }

            setupEventListeners() {
                if (this.clickHandler) {
                    this.canvas.removeEventListener('click', this.clickHandler);
                }
                this.clickHandler = (e) => {
                    if (this.gameOver) return;
                    if (this.currentPlayer === 2) return; // AI å›åˆä¸èƒ½ç‚¹
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const col = Math.round(canvasX / this.cellSize) - 1;
                    const row = Math.round(canvasY / this.cellSize) - 1;
                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                };
                this.canvas.addEventListener('click', this.clickHandler);
            }

            isValidMove(row, col) {
                if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
                    return false;
                }
                return this.board[row][col] === 0;
            }

            // ç©å®¶æˆ–AIçš„ *çœŸå®* è½å­
            makeMove(row, col) {
                // ç©å®¶è½å­ï¼Œåœæ­¢è®¡æ—¶
                if (!this.gameOver && this.currentPlayer === 1) {
                   this.stopPlayerTimer();
                }
                
                // æ¸¸æˆæ€»è®¡æ—¶åœ¨ç©å®¶ä¸‹ç¬¬ä¸€æ­¥åå¼€å§‹ (moveHistory ä» 0 (AI) -> 1 (ç©å®¶) æ—¶)
                if (this.moveHistory.length === 1) { // AI å·²èµ°ä¸€æ­¥ï¼Œè¿™æ˜¯ç©å®¶ç¬¬ä¸€æ­¥
                    this.startTimer(); // æ¸¸æˆæ€»è®¡æ—¶å¼€å§‹
                }

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showWinner();
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showDraw();
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    
                    // è½®åˆ° AI
                    if (this.currentPlayer === 2) {
                         // AI ä¸‹æ£‹å‰å…ˆæ›´æ–° UIï¼Œæ˜¾ç¤ºè½®åˆ° AI
                         this.updateCurrentPlayer();
                         this.aiMove();
                    } 
                    // è½®åˆ°ç©å®¶
                    else {
                        // åªæœ‰åœ¨ç©å®¶ä¸‹äº†ç¬¬ä¸€æ­¥æ£‹ä¹‹å (å³ history >= 2) æ‰å¯åŠ¨è®¡æ—¶å™¨
                        if (this.moveHistory.length >= 2) {
                            this.startPlayerTimer();
                        } else {
                            // ç©å®¶ç¬¬ä¸€æ­¥åï¼Œä¸å¯åŠ¨è®¡æ—¶å™¨ï¼Œä½†éœ€è¦æ›´æ–° UI
                            this.updateCurrentPlayer(); 
                        }
                    }
                }
            }
            
            // aiMove äº¤ç»™ Web Worker
            aiMove() {
                 if (this.gameOver) return; // é˜²æ­¢æ¸¸æˆç»“æŸå AI ä»ç„¶æ€è€ƒ

                const aiThinkingEl = document.getElementById('aiThinking');
                 // å›ºå®šä¸ºç¡•ç¥æ¨¡å¼çš„æç¤º
                let thinkingText = `ğŸ”¥ ç¡•ç¥æ€è€ƒä¸­... (è¿­ä»£è‡³D:${this.GOD_DEPTH}, 10sç†”æ–­)`;
                
                aiThinkingEl.innerHTML = thinkingText;
                aiThinkingEl.style.display = 'block';

                // å°†å½“å‰çŠ¶æ€å‘ç»™ Worker çº¿ç¨‹
                this.aiWorker.postMessage({
                    board: this.board,
                    boardSize: this.boardSize,
                    difficulty: 'god', // å›ºå®šä¸º god
                    maxDepth: this.GOD_DEPTH, // ä¼ é€’æœ€å¤§æ·±åº¦
                    zobristTable: this.zobristTable,
                    currentHash: this.currentHash,
                    moveHistory: this.moveHistory
                });
            }
            
            // æ¥æ”¶ Worker çš„è®¡ç®—ç»“æœ
            receiveAiMove(moveData) {
                const { move, duration, depth, type } = moveData;

                // å¦‚æœæ¸¸æˆå·²ç»ç»“æŸäº†ï¼ˆæ¯”å¦‚ç©å®¶åœ¨AIæ€è€ƒæ—¶åˆ·æ–°æˆ–é‡å¼€ï¼‰ï¼Œåˆ™ä¸å¤„ç†AIç»“æœ
                if (this.gameOver) {
                    console.log("Game over, ignoring AI move.");
                    return;
                }

                const aiThinkingEl = document.getElementById('aiThinking');

                // æ˜¾ç¤ºç®—æ³•ç±»å‹
                let typeStr = '';
                if (type === 'VCF') {
                    typeStr = 'ğŸ”¥ [VCFå¿…æ€]';
                } else if (type === 'VCT') {
                    typeStr = 'âš¡ [VCTå¨èƒ]';
                } else {
                    typeStr = `(D:${depth})`;
                }

                let durationText = `(ç”¨æ—¶ ${duration}s)`;
                // TIMEOUT_MS åœ¨ Worker ä¸­å®šä¹‰ï¼Œè¿™é‡Œç”¨å­—é¢é‡
                if (parseFloat(duration) >= 10.0) {
                    durationText = `(è¶…æ—¶ ${duration}s, è¿”å›D:${depth}ç»“æœ)`;
                }

                // [å˜²è®½] å‡†å¤‡å˜²è®½è¯­å½•
                const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
                const target = targets[Math.floor(Math.random() * targets.length)];
                let stepTaunts = [];

                if (type === 'VCF') {
                    stepTaunts = [
                        `${target}, è¿™æ˜¯å¿…æ€åºåˆ—ï¼ä½ å·²ç»è¾“äº†ï¼`,
                        `VCFæ‰¾åˆ°äº†ï¼Œ${target}ï¼Œä½ æ— è·¯å¯é€ƒã€‚`,
                        `å®Œç¾çš„å››è¿å¨èƒï¼Œ${target}ï¼Œè®¤è¾“å§ï¼`,
                        `${target}, æˆ‘å·²ç»ç®—åˆ°äº†ä½ çš„æ­»æœŸã€‚`
                    ];
                } else if (type === 'VCT') {
                    stepTaunts = [
                        `${target}, å¨èƒåºåˆ—å·²å¯åŠ¨ï¼Œä½ èƒ½æ’‘å‡ æ­¥ï¼Ÿ`,
                        `VCTé”å®šï¼Œ${target}ï¼Œæ„Ÿå—ç»æœ›å§ï¼`,
                        `${target}, è¿™æ˜¯è¿ç»­å¨èƒï¼Œä½ é˜²ä¸ä½çš„ã€‚`
                    ];
                } else {
                    stepTaunts = [ // ç¡•ç¥ä¸“å±å˜²è®½
                        `ç¥ä¹‹ä¸€æ‰‹ã€‚åˆ°ä½ äº†, ${target}ã€‚`,
                        `ä½ è¿˜æœ‰ ${10 - Math.ceil(parseFloat(duration))} ç§’æ¥æ£æ‘©åœ£æ„, ${target}ã€‚`,
                        `${target}, ä½ å·²ç»è¾“äº†, åªæ˜¯è¿˜æ²¡æ„è¯†åˆ°ã€‚`,
                        `å®Œç¾çš„é˜²å®ˆï¼Œæ— æ‡ˆå¯å‡»çš„è¿›æ”»ã€‚é¢¤æŠ–å§, ${target}ï¼`,
                        `æˆ‘çœ‹åˆ°äº† ${depth} å±‚ä¹‹åçš„ä¸–ç•Œ, ${target}, ä½ å‘¢ï¼Ÿ`,
                        `æ”¾å¼ƒå§, ${target}, èƒœè´Ÿå·²å®šã€‚`,
                        `å¼±å°çš„äººç±»${target}, ä½ çš„ç­–ç•¥æ¼æ´ç™¾å‡ºã€‚`,
                        `æ˜¯ä¸æ˜¯å¾ˆç»æœ›å•Š, ${target}ï¼Ÿ`
                    ];
                }
                const stepTaunt = stepTaunts[Math.floor(Math.random() * stepTaunts.length)];

                // æ˜¾ç¤ºä¿¡æ¯ + å˜²è®½
                aiThinkingEl.innerHTML = `âœ… AIè½å­ ${typeStr} ${durationText} <span class="step-taunt">${stepTaunt}</span>`; 
                
                if (move) {
                    // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œå¹¶ä¸”å½“å‰å¿…é¡»è½®åˆ° AI (player 2)
                    if (!this.gameOver && this.currentPlayer === 2 && this.isValidMove(move.row, move.col)) {
                        this.makeMove(move.row, move.col);
                    } else if (!this.gameOver && this.currentPlayer === 2) {
                         console.error("AI Worker è¿”å›äº†ä¸€ä¸ªæ— æ•ˆèµ°æ³•: ", move);
                         const randomMove = this.getRandomMoveForMainThread();
                         if(randomMove) this.makeMove(randomMove.row, randomMove.col);
                    } else {
                         console.log("Ignoring AI move received after turn changed or game ended.");
                    }
                } else {
                    aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ? (AIæ— æ£‹å¯èµ°)';
                }
            }

            // ä¸»çº¿ç¨‹çš„ä¿åº•éšæœºèµ°æ³• (ç”¨äºç©å®¶è¶…æ—¶)
            getRandomMoveForMainThread() {
                 const emptyPositions = [];
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            emptyPositions.push({ row: i, col: j });
                        }
                    }
                }
                if (emptyPositions.length > 0) {
                    return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
                return null;
            }

            // ä¸»çº¿ç¨‹ä»ç„¶éœ€è¦ checkWin (ç”¨äºç©å®¶)
            checkWin(row, col) {
                const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
                const player = this.board[row][col];
                if (player === 0) return false;

                for (let [dr, dc] of directions) {
                    let count = 1;
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r += dr; c += dc;
                    }
                    r = row - dr; c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r -= dr; c -= dc;
                    }
                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            isBoardFull() {
                for (let row of this.board) {
                    if (row.includes(0)) {
                        return false;
                    }
                }
                return true;
            }

            updateCurrentPlayer() {
                let playerText;
                // åªæœ‰ AI æ¨¡å¼
                playerText = this.currentPlayer === 1
                    ? '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>'
                    : '<span class="player-white">â—‹ AIï¼ˆç™½æ£‹ï¼‰</span>';
                
                // æ›´æ–° UI (é™„åŠ è®¡æ—¶å™¨)
                const playerTimerSpan = document.getElementById('playerTimeLeft');
                 // åªæœ‰å½“è®¡æ—¶å™¨IDå­˜åœ¨æ—¶(è¡¨ç¤ºè®¡æ—¶å™¨æ­£åœ¨è¿è¡Œ)æ‰æ˜¾ç¤ºæ—¶é—´
                if (this.playerTimerId !== null && this.currentPlayer === 1 && !this.gameOver) {
                    playerTimerSpan.textContent = `(${this.playerTimeLeft}s)`;
                } else {
                    playerTimerSpan.textContent = ''; 
                }
                document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText + playerTimerSpan.outerHTML;
            }

            showWinner() {
                 // åªæœ‰ AI æ¨¡å¼
                let playerName = this.winner === 1 ? 'ä½ ' : 'ç¡•ç¥AI';

                const message = document.getElementById('winnerMessage');
                const timeStr = this.formatTime(this.elapsedTime);
                let messageText = `ğŸ‰ ${playerName} è·èƒœï¼`;
                
                // [å˜²è®½] AI è·èƒœæ—¶æ·»åŠ å˜²è®½
                if (this.winner === 2) {
                    const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    let taunts = [ // ç¡•ç¥èƒœåˆ©å˜²è®½
                        `6å±‚æœç´¢ï¼Œ${target}ä½ æ‹¿ä»€ä¹ˆèµ¢ï¼Ÿ`, `å‡¡äºº${target}ï¼Œä½ å°½åŠ›äº†ã€‚`, `æˆ‘çš„æ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ€ä¼˜è§£ã€‚`,
                        `${target}, ä½ ç”šè‡³æ²¡èƒ½é€¼æˆ‘èµ°å‡ºå¼€å±€åº“ã€‚`, `ç»“æŸäº†, ${target}, æ¸¸æˆæ‰åˆšåˆšå¼€å§‹ã€‚`,
                        `ä¸å ªä¸€å‡»ï¼Œ${target}ã€‚`, `å›å»å†ç»ƒç»ƒå§ï¼Œ${target}ï¼`
                    ];
                    const taunt = taunts[Math.floor(Math.random() * taunts.length)];
                    messageText += `<span class="ai-taunt">${taunt}</span>`;
                }

                // ç©å®¶è·èƒœè®°å½•æ—¶é—´
                if (this.winner === 1) {
                    messageText += `<br>â±ï¸ ç”¨æ—¶ï¼š${timeStr}`;
                    const bestTimeKey = `bestTime_god`; // å›ºå®š Key
                    const currentBest = localStorage.getItem(bestTimeKey);

                    if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
                        localStorage.setItem(bestTimeKey, this.elapsedTime);
                        this.loadBestTime();
                        messageText += `<br>ğŸ† æ–°çºªå½•ï¼ä½ ç«Ÿç„¶èµ¢äº†ç¡•ç¥ï¼Ÿï¼`;
                    } else {
                        messageText += `<br>ï¼ˆè™½ç„¶èµ¢äº†ï¼Œä½†æ²¡ç ´çºªå½•å“¦ï¼‰`;
                    }
                }

                message.innerHTML = messageText;
                message.className = 'winner-message show';
                message.style.color = this.winner === 1 ? '#4caf50' : '#d32f2f'; // ç©å®¶èµ¢ç»¿è‰²ï¼ŒAIèµ¢çº¢è‰²
            }

            showDraw() {
                const message = document.getElementById('winnerMessage');
                message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»¡';
                message.className = 'winner-message show';
                message.style.color = '#ff9800';
            }
            
            // å¯åŠ¨ç©å®¶è®¡æ—¶å™¨
            startPlayerTimer() {
                // [ç©å®¶è®¡æ—¶.å¯åŠ¨é€»è¾‘ä¿®æ­£] ç¡®ä¿æ¸¸æˆæœªç»“æŸä¸”ç¡®å®è½®åˆ°ç©å®¶
                if (this.gameOver || this.currentPlayer !== 1) return; 
                
                this.stopPlayerTimer(); // å…ˆæ¸…é™¤æ—§çš„
                this.playerTimeLeft = 10;
                this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º (10s)
                
                this.playerTimerId = setInterval(() => {
                    // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢è®¡æ—¶å™¨åœ¨ä¸è¯¥è·‘çš„æ—¶å€™è·‘
                     if (this.gameOver || this.currentPlayer !== 1) {
                         this.stopPlayerTimer();
                         return;
                     }
                    
                    this.playerTimeLeft--;
                    this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º
                    
                    if (this.playerTimeLeft <= 0) {
                        this.forceRandomMove();
                    }
                }, 1000); // æ¯ç§’æ‰§è¡Œ
            }
            
            // åœæ­¢ç©å®¶è®¡æ—¶å™¨
            stopPlayerTimer() {
                 if (this.playerTimerId) {
                    clearInterval(this.playerTimerId);
                    this.playerTimerId = null; // æ¸…é™¤ ID å¾ˆé‡è¦
                }
                 // æ¸…é™¤è®¡æ—¶æ˜¾ç¤º 
                 const playerTimerSpan = document.getElementById('playerTimeLeft');
                 if(playerTimerSpan) playerTimerSpan.textContent = '';
                 // ç¡®ä¿UIç«‹å³æ›´æ–°ä¸ºä¸å¸¦è®¡æ—¶å™¨çŠ¶æ€ (å¦‚æœå½“å‰æ˜¯ç©å®¶å›åˆ)
                 if (!this.gameOver && this.currentPlayer === 1) {
                     this.updateCurrentPlayer();
                 }
            }
            
            // å¼ºåˆ¶éšæœºè½å­
            forceRandomMove() {
                 this.stopPlayerTimer();
                 if (this.gameOver || this.currentPlayer !== 1) return; // æ¸¸æˆå·²ç»“æŸæˆ–ä¸æ˜¯ç©å®¶å›åˆ
                 
                 console.warn("ç©å®¶è¶…æ—¶ï¼Œå¼ºåˆ¶éšæœºè½å­ï¼");
                 const randomMove = this.getRandomMoveForMainThread();
                 
                 // çŸ­æš‚æç¤º
                 const aiThinkingEl = document.getElementById('aiThinking');
                 aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼å·²æ›¿ä½ éšæœºè½å­ï¼`;
                 aiThinkingEl.style.display = 'block';
                 
                 if (randomMove) {
                     // å»¶è¿Ÿä¸€ç‚¹ç‚¹æ‰§è¡Œï¼Œè®©æç¤ºèƒ½è¢«çœ‹åˆ°
                     setTimeout(() => {
                         // æ£€æŸ¥æ¸¸æˆæ˜¯å¦åœ¨å»¶è¿ŸæœŸé—´ç»“æŸäº†ï¼Œå¹¶ä¸”ç¡®è®¤ç°åœ¨æ˜¯ç©å®¶å›åˆ
                         if (!this.gameOver && this.currentPlayer === 1) {
                            this.makeMove(randomMove.row, randomMove.col);
                         }
                     }, 500);
                 } else {
                     aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼ä½†æ£‹ç›˜å·²æ»¡ï¼Ÿ`;
                 }
            }


            _internalReset() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 2; // AI å…ˆæ‰‹
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.currentHash = 0;
                
                this.stopTimer(); // åœæ­¢æ¸¸æˆæ€»è®¡æ—¶
                this.stopPlayerTimer(); // åœæ­¢ç©å®¶è®¡æ—¶
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
                // updateCurrentPlayer ä¼šåœ¨ startNewGame ä¸­è°ƒç”¨
            }
            
            startNewGame() { 
                this._internalReset();
                // [AIç¬æ—¶å¼€å±€.3] é‡å¼€æ¸¸æˆæ—¶ï¼Œä¹Ÿç«‹å³æ‰§è¡Œ AI ç¬¬ä¸€æ­¥
                 // ä½¿ç”¨ setTimeout ç¡®ä¿ UI æ¸²æŸ“å®Œæˆåå†æ‰§è¡Œ
                setTimeout(() => {
                     this.performAiFirstMove();
                }, 0);
            }

            startTimer() {
                if (this.timerInterval) return; // é˜²æ­¢é‡å¤å¯åŠ¨
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    // åªæœ‰æ¸¸æˆè¿›è¡Œä¸­æ‰è®¡æ—¶
                    if (!this.gameOver) {
                        this.elapsedTime = Date.now() - this.startTime;
                        this.updateTimerDisplay();
                    } else {
                        this.stopTimer(); // æ¸¸æˆç»“æŸï¼Œåœæ­¢è®¡æ—¶
                    }
                }, 100); 
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimerDisplay() {
                const timeStr = this.formatTime(this.elapsedTime);
                document.getElementById('currentTime').textContent = timeStr;
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            loadBestTime() {
                const bestTimeKey = `bestTime_god`; // å›ºå®š Key
                const bestTime = localStorage.getItem(bestTimeKey);

                if (bestTime) {
                    const timeStr = this.formatTime(parseInt(bestTime));
                    document.getElementById('bestTime').textContent = timeStr;
                } else {
                    document.getElementById('bestTime').textContent = '--:--';
                }
            }
        }

        // ===============================================
        // å¯åŠ¨é€»è¾‘ (UI çº¿ç¨‹)
        // ===============================================
        let game; 

        function restartGame() {
            if (!game) return;
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿï¼ˆç¡•ç¥AIå°†ç«‹å³åœ¨å¤©å…ƒè½å­ï¼‰')) {
                game.startNewGame(); 
            }
        }
        
        // ç­‰å¾…HTMLåŠ è½½å®Œæ¯•åï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            // ç›´æ¥åˆå§‹åŒ–ç¡•ç¥æ¨¡å¼
            game = new GomokuGame();
            
            // æ›´æ–°è§„åˆ™æ–‡æœ¬
            const rulesList = document.getElementById('rules-list'); // Get the list by ID
            // æ¸…ç©ºæ—§è§„åˆ™ (å¦‚æœå­˜åœ¨)
            while (rulesList.firstChild) {
                 rulesList.removeChild(rulesList.firstChild);
            }
            // æ·»åŠ æ–°è§„åˆ™
            const rules = [
                 'ğŸ”¥ **ç¡•ç¥æ¨¡å¼**: AIæ‰§ç™½æ£‹ (2) **ç«‹å³**åœ¨å¤©å…ƒè½å­å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)',
                 'ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­',
                 'å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼‰',
                 'ç©å®¶**ç¬¬ä¸€æ­¥å**æ¯æ­¥æ€è€ƒæ—¶é—´ä¸å¾—è¶…è¿‡10ç§’ï¼Œè¶…æ—¶å°†éšæœºè½å­',
                 'AI æ¯æ­¥æ€è€ƒæ—¶é—´ä¸Šé™10ç§’',
                 '**æ— æ‚”æ£‹**'
            ];
             rules.forEach(ruleText => {
                 const li = document.createElement('li');
                 li.innerHTML = ruleText; // ä½¿ç”¨ innerHTML æ”¯æŒåŠ ç²—
                 rulesList.appendChild(li);
             });
        });
    </script>
</body>
</html>
