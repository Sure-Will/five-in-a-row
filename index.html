<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋游戏 - 挑战硕神</title>
    <style>
        /* CSS 样式与上一版相同 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 20px;
        }
        .container {
            background: white; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px; max-width: 850px; width: 100%;
        }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 1.1em; }
        .difficulty-selector { display: flex; justify-content: center; margin-bottom: 20px; align-items: center; }
        .diff-label { font-weight: bold; margin-right: 10px; font-size: 1.1em;}
        .god-mode-active {
             padding: 10px 20px; font-size: 1.1em; border-radius: 10px;
             background: #f44336; color: white; font-weight: bold;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .game-info {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px;
        }
        .current-player { font-size: 1.3em; font-weight: bold; color: #333; }
        #playerTimeLeft { font-size: 0.8em; color: #f44336; margin-left: 8px; font-weight: normal; }
        .player-black { color: #000; }
        .player-white { color: #666; }
        .controls { display: flex; gap: 10px; }
        button {
            padding: 10px 20px; font-size: 1em; border: none; border-radius: 8px;
            cursor: pointer; transition: all 0.3s; font-weight: bold;
        }
        .btn-restart { background: #4caf50; color: white; }
        .btn-restart:hover { background: #45a049; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .board-container { display: flex; justify-content: center; margin: 20px 0; }
        #gameBoard {
            background: #daa520; border: 3px solid #8b6914;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); cursor: pointer;
            max-width: 100%; height: auto;
        }
        .winner-message {
            text-align: center; font-size: 1.5em; font-weight: bold; color: #4caf50;
            margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 10px; display: none;
        }
        .winner-message.show { display: block; animation: slideDown 0.5s ease; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .instructions { background: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; }
        .instructions h3 { color: #1976d2; margin-bottom: 10px; }
        .instructions ul { list-style-position: inside; color: #333; line-height: 1.8; }
        .ai-thinking { text-align: center; font-size: 1.1em; color: #ff9800; margin: 10px 0; font-weight: bold; }
        .step-taunt { display: block; font-size: 0.9em; color: #e91e63; margin-top: 5px; }
        .timer-container {
            display: flex; justify-content: center; align-items: center; gap: 20px;
            margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px; color: white;
        }
        .timer-item { text-align: center; }
        .timer-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
        .timer-value { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
        .best-time { color: #ffd700; }
        .ai-taunt { font-size: 0.8em; color: #f44336; font-weight: bold; display: block; margin-top: 10px; }
        @media (max-width: 600px) {
            .container { padding: 15px; } h1 { font-size: 1.8em; }
            .game-info { flex-direction: column; gap: 10px; }
            .controls { flex-wrap: wrap; justify-content: center; }
            .timer-container { flex-direction: column; gap: 10px; } .timer-value { font-size: 1.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎮 五子棋</h1>
        <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

         <div class="difficulty-selector">
            <span class="diff-label">当前模式：</span>
            <span class="god-mode-active">🔥 硕神模式</span>
        </div>


        <div class="game-info">
            <div class="current-player" id="currentPlayer">
                当前玩家：<span class="player-black">● 你（黑棋）</span>
                <span id="playerTimeLeft"></span>
            </div>
            <div class="controls">
                <button class="btn-restart" id="restartBtn" onclick="restartGame()">🔄 重新开始</button>
            </div>
        </div>

        <div class="ai-thinking" id="aiThinking" style="display: none;">🤖 AI思考中...</div>

        <div class="timer-container">
            <div class="timer-item">
                <div class="timer-label">⏱️ 用时</div>
                <div class="timer-value" id="currentTime">00:00</div>
            </div>
            <div class="timer-item">
                <div class="timer-label">🏆 最佳记录 (硕神模式)</div>
                <div class="timer-value best-time" id="bestTime">--:--</div>
            </div>
        </div>

        <div class="winner-message" id="winnerMessage"></div>

        <div class="board-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="instructions">
            <h3>📖 游戏规则</h3>
            <ul id="rules-list">
                {/* Rules will be added by JS */}
            </ul>
        </div>
    </div>
    
    <script id="ai-worker-script" type="text/worker-script">
        
        // --- Worker 内的全局变量 ---
        let board, boardSize, maxDepth; 
        let zobristTable, currentHash, moveHistory;
        let transpositionTable = new Map();
        
        const TIMEOUT_MS = 10000; // 10 秒 AI 熔断

        // [开局库.1] 定义开局库 (Map: hash -> move)
        const openingBook = new Map();
        // !!! 警告：下面的 hash 值是占位符，必须替换为真实计算值 !!!
        // 格式: openingBook.set(局面哈希值, { row: AI应走行, col: AI应走列 });
        // --- AI 白棋 (2) 先手 ---
        // 局面 1: AI (7,7) -> 玩家 (6,6) [玩家斜]
        const hash_p1_6_6 = 123456789012345; // <-- 替换!
        openingBook.set(hash_p1_6_6, { row: 6, col: 7 }); // AI 回应 (6,7) [AI直] (水月)
        // 局面 2: AI (7,7) -> 玩家 (7,6) [玩家直]
        const hash_p1_7_6 = 234567890123456; // <-- 替换!
        openingBook.set(hash_p1_7_6, { row: 6, col: 6 }); // AI 回应 (6,6) [AI斜] (花月)
         // 局面 3: AI (7,7) -> 玩家 (8,8) [玩家斜]
        const hash_p1_8_8 = 345678901234567; // <-- 替换!
        openingBook.set(hash_p1_8_8, { row: 8, col: 7 }); // AI 回应 (8,7) [AI直] (水月)
         // 局面 4: AI (7,7) -> 玩家 (6,7) [玩家直]
        const hash_p1_6_7 = 456789012345678; // <-- 替换!
        openingBook.set(hash_p1_6_7, { row: 6, col: 6 }); // AI 回应 (6,6) [AI斜] (花月)
        // --- 更多定式可以继续添加 ---
        // 局面 5: AI(7,7)->P(6,6)->AI(6,7)->P(7,6)
        const hash_p1_66_ai_67_p1_76 = 567890123456789; // <-- 替换!
        openingBook.set(hash_p1_66_ai_67_p1_76, { row: 5, col: 7 }); // AI 第 3 步示例
        // 局面 6: AI(7,7)->P(7,6)->AI(6,6)->P(6,7)
        const hash_p1_76_ai_66_p1_67 = 678901234567890; // <-- 替换!
        openingBook.set(hash_p1_76_ai_66_p1_67, { row: 5, col: 5 }); // AI 第 3 步示例

        // --- 核心入口：接收主线程消息 ---
        self.onmessage = function(e) {
            const data = e.data;
            
            // 1. 更新 Worker 的内部状态
            board = data.board;
            boardSize = data.boardSize;
            maxDepth = data.maxDepth; // 硕神(6)
            zobristTable = data.zobristTable;
            currentHash = data.currentHash;
            moveHistory = data.moveHistory;
            
            // 2. 每次 AI 思考时，都重置置换表
            transpositionTable.clear();
            
            const startTime = performance.now();
            let moveResult = {}; 
            
            // 3. 调用 AI 核心逻辑 (包含开局库和强制终结检查)
            moveResult = getBestMoveIDDFS(startTime, maxDepth); 
            
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // 4. 将结果发回主线程
            self.postMessage({ 
                move: moveResult.move, 
                duration: duration, 
                depth: moveResult.depth // 包含实际完成的深度
            });
        };
        
        // --- AI 算法 ---
        
        function getHardMove() { // 作为 IDDFS 超时或开局库/强制检查未命中时的备用
            let bestScore = -Infinity;
            let bestMove = null;
            // (代码与上一版 getHardMove 相同)
            // ... (省略以减少篇幅) ...
            const emptyPositions = []; // 保底随机走法
            for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) emptyPositions.push({ row: i, col: j }); } }
            return bestMove || (emptyPositions.length > 0 ? emptyPositions[Math.floor(Math.random() * emptyPositions.length)] : null);
        }
        
        // 迭代加深 (IDDFS) 入口 - 包含开局库和强制终结检查
        function getBestMoveIDDFS(startTime, maxDepth) {
            
            // [开局库.3] 检查开局库 (限制在 8 步内)
            const bookMove = openingBook.get(currentHash);
            if (bookMove && moveHistory.length < 8) {
                console.log("Using opening book move!");
                // 确保库里的走法当前是有效的 (以防万一)
                if (board[bookMove.row][bookMove.col] === 0) {
                     return { move: bookMove, depth: 1, timedOut: false };
                } else {
                     console.warn("Opening book move is invalid, recalculating.");
                }
            }

            // [强制终结.1] 检查 AI 是否能一步获胜或需要防守
            const validMoves = getValidMoves(false); // 获取无排序的走法用于检查
            let immediateAiWinMove = null;
            let immediatePlayerBlockMove = null;

            for (const move of validMoves) {
                // 检查 AI 获胜
                _simulateMove(move.row, move.col, 2); // 模拟 AI 落子
                if (checkWin(move.row, move.col)) {
                    immediateAiWinMove = { row: move.row, col: move.col };
                    _simulateUndo(move.row, move.col, 2); // 撤销模拟
                    break; // 找到一个即可
                }
                _simulateUndo(move.row, move.col, 2); // 撤销模拟

                // 检查玩家获胜 (AI 需要防守) - 仅当没找到 AI 必胜时检查
                if (!immediateAiWinMove) {
                     _simulateMove(move.row, move.col, 1); // 模拟玩家落子
                     if (checkWin(move.row, move.col)) {
                         immediatePlayerBlockMove = { row: move.row, col: move.col }; // AI 需要下在这里
                         _simulateUndo(move.row, move.col, 1); // 撤销模拟
                         // 继续检查，看后面是否有 AI 能直接赢的 (AI 赢优先)
                     } else {
                         _simulateUndo(move.row, move.col, 1); // 撤销模拟
                     }
                }
            }

            // 如果找到 AI 必胜棋
            if (immediateAiWinMove) {
                 console.log("Found immediate AI win!");
                 return { move: immediateAiWinMove, depth: 1, timedOut: false };
            }
            // 如果找到需要立即防守的棋
            if (immediatePlayerBlockMove) {
                 console.log("Found immediate block required!");
                 return { move: immediatePlayerBlockMove, depth: 1, timedOut: false };
            }

            // --- 如果没有开局库命中和强制终结，则开始 IDDFS ---
            let bestMove = null;
            let bestScore = -Infinity;
            let completedDepth = 0;

            // 迭代加深: 搜索深度 2, 4, 6, ... 直到 maxDepth
            for (let d = 2; d <= maxDepth; d += 2) {
                
                const currentTime = performance.now();
                if ((currentTime - startTime) > TIMEOUT_MS) {
                    break; 
                }

                const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

                if (result.timedOut) {
                    break; 
                }

                // 只有当 result.move 有效时才更新 bestMove
                if (result.move) {
                    bestMove = result.move;
                    bestScore = result.score;
                    completedDepth = d; 
                } else {
                    // 如果 minimax 返回了 null move (可能发生在根节点无法走棋?)，跳出循环
                    console.warn(`Minimax returned null move at depth ${d}`);
                    break;
                }
                
                if (bestScore > 9000000) { // 找到必胜
                    break; 
                }
            }
            
            // 如果超时或搜索未完成，返回上一个深度的结果或保底
            if (bestMove === null) {
                console.warn("IDDFS couldn't find a move (timeout likely), using hard move.");
                bestMove = getHardMove(); 
                completedDepth = completedDepth || 1; 
            }

            return { move: bestMove, score: bestScore, depth: completedDepth };
        }

        // 核心：带 Alpha-Beta 剪枝的 Minimax
        function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
            
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return { score: 0, timedOut: true }; 
            }

            const hash = currentHash;
            const cached = transpositionTable.get(hash);
            if (cached && cached.depth >= depth) {
                return { score: cached.score, timedOut: false };
            }

            if (depth === 0) {
                const score = evaluateBoardHeuristic();
                return { score: score, timedOut: false };
            }

            const validMoves = getValidMoves(true); // true = 带排序

            if (validMoves.length === 0) {
                return { score: 0, timedOut: false }; // 平局
            }

            let bestMove = null;
            let timedOut = false;

            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                bestMove = validMoves[0]; // 初始假设第一个是最好的

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 2); // AI (2)
                    let score;
                    // [强制终结.2] 检查模拟后的局面是否 AI 胜利
                    if (checkWin(move.row, move.col)) {
                        score = 10000000 + depth; // 必胜 (10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
                        if (result.timedOut) {
                            timedOut = true;
                            score = 0; // 这个分数无效
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 2);
                    
                    if (timedOut) return { score: 0, timedOut: true }; // 传播超时

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move; // 更新最佳走法
                    }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // 剪枝
                    }
                }
                // 确保 bestMove 不是 null (如果循环没有执行或所有走法都被剪枝?)
                 bestMove = bestMove || validMoves[0]; // 保底
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            
            } else { // 轮到 Min (玩家)
                let bestScore = +Infinity;
                bestMove = validMoves[0]; // 初始假设第一个是最好的

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 1); // 玩家 (1)
                    let score;
                     // [强制终结.3] 检查模拟后的局面是否玩家胜利
                    if (checkWin(move.row, move.col)) {
                        score = -10000000 - depth; // 必败 (-10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
                         if (result.timedOut) {
                            timedOut = true;
                            score = 0; // 这个分数无效
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 1);

                    if (timedOut) return { score: 0, timedOut: true }; // 传播超时

                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move; // 更新最佳走法 (对 Min 来说是分数最低的)
                    }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // 剪枝
                    }
                }
                 // 确保 bestMove 不是 null
                bestMove = bestMove || validMoves[0]; // 保底
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            }
        }

        // 模拟落子
        function _simulateMove(row, col, player) {
            board[row][col] = player;
            currentHash ^= zobristTable[row][col][player - 1];
        }
        // 模拟悔棋
        function _simulateUndo(row, col, player) {
            board[row][col] = 0;
            currentHash ^= zobristTable[row][col][player - 1];
        }

        // 获取有效走法 (代码与上一版相同)
        function getValidMoves(withOrdering = false) {
             // ... (省略以减少篇幅) ...
             const moveSet = new Set();
             const center = Math.floor(boardSize / 2);
             if (moveHistory.length === 0) return [{ row: center, col: center }];
             if (moveHistory.length === 1) { // 玩家第一步
                 const moves = [];
                 for(let dr = -1; dr <= 1; dr++) { for(let dc = -1; dc <=1; dc++) {
                      if (dr === 0 && dc === 0) continue;
                      const r = center + dr; const c = center + dc;
                      if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) moves.push({row: r, col: c});
                 }} return moves;
             }
             const radius = 2; // 正常搜索
             for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) {
                 if (board[r][c] === 0) continue; 
                 for (let dr = -radius; dr <= radius; dr++) { for (let dc = -radius; dc <= radius; dc++) {
                     if (dr === 0 && dc === 0) continue;
                     const nr = r + dr; const nc = c + dc;
                     if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc] === 0) moveSet.add(`${nr},${nc}`);
                 }}
             }}
             if (moveSet.size === 0) { // 保底：返回所有空点
                  for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { if (board[r][c] === 0) moveSet.add(`${r},${c}`); }}
             }
             const moves = Array.from(moveSet).map(s => { const [row, col] = s.split(',').map(Number); return { row, col }; });
             if (withOrdering) { // 排序
                 const scoredMoves = moves.map(move => ({ move, score: evaluatePositionAdvanced(move.row, move.col) }));
                 scoredMoves.sort((a, b) => b.score - a.score); return scoredMoves.map(item => item.move);
             } return moves;
        }

        // 静态棋盘评估 (代码与上一版相同)
        function evaluateBoardHeuristic() {
             // ... (省略以减少篇幅) ...
             let totalScore = 0; const validMoves = getValidMoves(false);
             for (const move of validMoves) { totalScore += evaluatePositionAdvanced(move.row, move.col); }
             return totalScore;
        }

        // 评估空点价值 (代码与上一版相同)
        function evaluatePositionAdvanced(row, col) {
            // ... (省略以减少篇幅) ...
            let score = 0; const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let [dr, dc] of directions) {
                const aiScore = evaluateLine(row, col, dr, dc, 2); const playerScore = evaluateLine(row, col, dr, dc, 1);
                score += aiScore + (playerScore * 1.1);
            }
            const center = Math.floor(boardSize / 2); const distToCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (boardSize - distToCenter) * 0.5; return score;
        }

        // 评估连珠情况 (代码与上一版相同)
        function evaluateLine(row, col, dr, dc, player) {
             // ... (省略以减少篇幅) ...
             let count = 0; let blocks = 0;
             for (let i = 1; i <= 4; i++) { // 正向
                 const r = row + dr * i; const c = col + dc * i;
                 if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                 if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
             }
             for (let i = 1; i <= 4; i++) { // 反向
                 const r = row - dr * i; const c = col - dc * i;
                 if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                 if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
             }
             if (count >= 4) return 10000000; if (count === 3 && blocks === 0) return 1000000;
             if (count === 2 && blocks === 0) return 50000; if (count === 3 && blocks === 1) return 10000;
             if (count === 2 && blocks === 1) return 500; if (count === 1 && blocks === 0) return 100;
             if (count === 1 && blocks === 1) return 10; return 0;
        }

        // 检查胜利 (代码与上一版相同)
        function checkWin(row, col) {
             // ... (省略以减少篇幅) ...
             const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ]; const player = board[row][col]; if (player === 0) return false;
             for (let [dr, dc] of directions) {
                 let count = 1; let r = row + dr, c = col + dc;
                 while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r += dr; c += dc; }
                 r = row - dr; c = col - dc;
                 while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r -= dr; c -= dc; }
                 if (count >= 5) return true;
             } return false;
        }

    </script>
    
    <script>
        class GomokuGame {
            constructor() { 
                this.boardSize = 15; // 固定为 15
                
                const maxCanvasWidth = 500;
                this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                // [AI瞬时开局] 初始 currentPlayer 设为 2 (AI)，但 UI 上会显示玩家
                this.currentPlayer = 2; 
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.gameMode = 'ai'; // 固定为 AI
                this.difficulty = 'god'; // 固定为 god
                
                // 计时器相关
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;
                
                this.playerTimerId = null;
                this.playerTimeLeft = 10; // 秒

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                // AI 核心
                this.GOD_DEPTH = 6;       // 神(6)
                this.zobristTable = [];
                this.currentHash = 0;
                this.initZobrist();
                
                // 初始化 Web Worker
                try {
                    const workerScript = document.getElementById('ai-worker-script').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    this.aiWorker = new Worker(URL.createObjectURL(blob));
                    
                    this.aiWorker.onmessage = (e) => {
                        this.receiveAiMove(e.data);
                    };
                } catch (error) {
                    console.error("无法创建 AI Worker: ", error);
                    alert("加载AI线程失败！请检查浏览器兼容性或刷新页面。");
                }


                this.initCanvas();
                this.drawBoard(); // 画空棋盘
                this.setupEventListeners();
                this.loadBestTime();
                
                // [AI瞬时开局.1] 延迟执行 AI 的第一步，确保 UI 先渲染
                 // 并确保在 DOMContentLoaded 之后执行
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.performAiFirstMove());
                } else {
                    setTimeout(() => { this.performAiFirstMove(); }, 0); 
                }
            }
            
            // [AI瞬时开局.2] AI 第一步逻辑
            performAiFirstMove() {
                // 确保只在游戏开始时执行一次
                if (this.moveHistory.length === 0 && !this.gameOver) {
                    const center = Math.floor(this.boardSize / 2);
                    if (this.board[center][center] === 0) {
                        
                        console.log("AI performs instant first move.");
                        
                        // 直接修改状态，不通过 makeMove 
                        this.board[center][center] = 2; // AI (白棋) 落子
                        this.moveHistory.push({ row: center, col: center, player: 2 });
                        this.currentHash ^= this.zobristTable[center][center][1]; // 更新哈希
                        this.currentPlayer = 1; // 轮到玩家
                        
                        this.drawBoard(); // 重绘棋盘
                        this.updateCurrentPlayer(); // 更新UI显示轮到玩家 (此时还不计时)
                    }
                }
            }

            
            // 初始化 Zobrist 哈希表 (主线程)
            initZobrist() {
                this.zobristTable = Array(this.boardSize).fill(null).map(() => 
                    Array(this.boardSize).fill(null).map(() => 
                        Array(2).fill(null) // 2个玩家
                    )
                );
                
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        for (let k = 0; k < 2; k++) {
                            this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        }
                    }
                }
                this.currentHash = 0;
            }


            initCanvas() {
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
            }

            drawBoard() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const boardSize = this.boardSize;

                // 清空画布
                ctx.fillStyle = '#daa520';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制网格线
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < boardSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
                    ctx.stroke();
                }

                // 绘制天元和星位 (15x15)
                const drawDot = (x, y) => {
                    ctx.beginPath();
                    ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                };
                
                drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
                drawDot(11, 11); drawDot(7, 7); 

                // 绘制棋子
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }
                
                // 绘制AI最后一步的标记
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    if (lastMove.player === 2) {
                        this.highlightLastMove(lastMove.row, lastMove.col);
                    }
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                if (player === 1) { // 玩家黑棋
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else { // AI 白棋
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                }
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            highlightLastMove(row, col) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.15; 
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; 
                ctx.fill();
            }

            setupEventListeners() {
                if (this.clickHandler) {
                    this.canvas.removeEventListener('click', this.clickHandler);
                }
                this.clickHandler = (e) => {
                    if (this.gameOver) return;
                    if (this.currentPlayer === 2) return; // AI 回合不能点
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const col = Math.round(canvasX / this.cellSize) - 1;
                    const row = Math.round(canvasY / this.cellSize) - 1;
                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                };
                this.canvas.addEventListener('click', this.clickHandler);
            }

            isValidMove(row, col) {
                if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
                    return false;
                }
                return this.board[row][col] === 0;
            }

            // 玩家或AI的 *真实* 落子
            makeMove(row, col) {
                // 玩家落子，停止计时
                if (!this.gameOver && this.currentPlayer === 1) {
                   this.stopPlayerTimer();
                }
                
                // 游戏总计时在玩家下第一步后开始 (moveHistory 从 0 (AI) -> 1 (玩家) 时)
                if (this.moveHistory.length === 1) { // AI 已走一步，这是玩家第一步
                    this.startTimer(); // 游戏总计时开始
                }

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showWinner();
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showDraw();
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    
                    // 轮到 AI
                    if (this.currentPlayer === 2) {
                         // AI 下棋前先更新 UI，显示轮到 AI
                         this.updateCurrentPlayer();
                         this.aiMove();
                    } 
                    // 轮到玩家
                    else {
                        // 只有在玩家下了第一步棋之后 (即 history >= 2) 才启动计时器
                        if (this.moveHistory.length >= 2) {
                            this.startPlayerTimer();
                        } else {
                            // 玩家第一步后，不启动计时器，但需要更新 UI
                            this.updateCurrentPlayer(); 
                        }
                    }
                }
            }
            
            // aiMove 交给 Web Worker
            aiMove() {
                 if (this.gameOver) return; // 防止游戏结束后 AI 仍然思考

                const aiThinkingEl = document.getElementById('aiThinking');
                 // 固定为硕神模式的提示
                let thinkingText = `🔥 硕神思考中... (迭代至D:${this.GOD_DEPTH}, 10s熔断)`;
                
                aiThinkingEl.innerHTML = thinkingText;
                aiThinkingEl.style.display = 'block';

                // 将当前状态发给 Worker 线程
                this.aiWorker.postMessage({
                    board: this.board,
                    boardSize: this.boardSize,
                    difficulty: 'god', // 固定为 god
                    maxDepth: this.GOD_DEPTH, // 传递最大深度
                    zobristTable: this.zobristTable,
                    currentHash: this.currentHash,
                    moveHistory: this.moveHistory
                });
            }
            
            // 接收 Worker 的计算结果
            receiveAiMove(moveData) {
                const { move, duration, depth } = moveData; 
                
                // 如果游戏已经结束了（比如玩家在AI思考时刷新或重开），则不处理AI结果
                if (this.gameOver) {
                    console.log("Game over, ignoring AI move.");
                    return;
                }
                
                const aiThinkingEl = document.getElementById('aiThinking');
                
                let depthStr = (depth > 1) ? `(D:${depth})` : ''; 
                let durationText = `(用时 ${duration}s)`;
                // TIMEOUT_MS 在 Worker 中定义，这里用字面量
                if (parseFloat(duration) >= 10.0) { 
                    durationText = `(超时 ${duration}s, 返回D:${depth}结果)`;
                }
                
                // [嘲讽] 准备嘲讽语录
                const targets = ["小强强", "小辉辉"];
                const target = targets[Math.floor(Math.random() * targets.length)];
                let stepTaunts = [ // 硕神专属嘲讽
                    `神之一手。到你了, ${target}。`,
                    `你还有 ${10 - Math.ceil(parseFloat(duration))} 秒来揣摩圣意, ${target}。`,
                    `${target}, 你已经输了, 只是还没意识到。`,
                    `完美的防守，无懈可击的进攻。颤抖吧, ${target}！`,
                    `我看到了 ${depth} 层之后的世界, ${target}, 你呢？`,
                    `放弃吧, ${target}, 胜负已定。`,
                    `弱小的人类${target}, 你的策略漏洞百出。`,
                    `是不是很绝望啊, ${target}？`
                ];
                const stepTaunt = stepTaunts[Math.floor(Math.random() * stepTaunts.length)];
                
                // 显示信息 + 嘲讽
                aiThinkingEl.innerHTML = `✅ AI落子 ${depthStr} ${durationText} <span class="step-taunt">${stepTaunt}</span>`; 
                
                if (move) {
                    // 再次检查游戏状态，并且当前必须轮到 AI (player 2)
                    if (!this.gameOver && this.currentPlayer === 2 && this.isValidMove(move.row, move.col)) {
                        this.makeMove(move.row, move.col);
                    } else if (!this.gameOver && this.currentPlayer === 2) {
                         console.error("AI Worker 返回了一个无效走法: ", move);
                         const randomMove = this.getRandomMoveForMainThread();
                         if(randomMove) this.makeMove(randomMove.row, randomMove.col);
                    } else {
                         console.log("Ignoring AI move received after turn changed or game ended.");
                    }
                } else {
                    aiThinkingEl.innerHTML = '🤔 游戏结束? (AI无棋可走)';
                }
            }

            // 主线程的保底随机走法 (用于玩家超时)
            getRandomMoveForMainThread() {
                 const emptyPositions = [];
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            emptyPositions.push({ row: i, col: j });
                        }
                    }
                }
                if (emptyPositions.length > 0) {
                    return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
                return null;
            }

            // 主线程仍然需要 checkWin (用于玩家)
            checkWin(row, col) {
                const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
                const player = this.board[row][col];
                if (player === 0) return false;

                for (let [dr, dc] of directions) {
                    let count = 1;
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r += dr; c += dc;
                    }
                    r = row - dr; c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r -= dr; c -= dc;
                    }
                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            isBoardFull() {
                for (let row of this.board) {
                    if (row.includes(0)) {
                        return false;
                    }
                }
                return true;
            }

            updateCurrentPlayer() {
                let playerText;
                // 只有 AI 模式
                playerText = this.currentPlayer === 1
                    ? '<span class="player-black">● 你（黑棋）</span>'
                    : '<span class="player-white">○ AI（白棋）</span>';
                
                // 更新 UI (附加计时器)
                const playerTimerSpan = document.getElementById('playerTimeLeft');
                 // 只有当计时器ID存在时(表示计时器正在运行)才显示时间
                if (this.playerTimerId !== null && this.currentPlayer === 1 && !this.gameOver) {
                    playerTimerSpan.textContent = `(${this.playerTimeLeft}s)`;
                } else {
                    playerTimerSpan.textContent = ''; 
                }
                document.getElementById('currentPlayer').innerHTML = '当前玩家：' + playerText + playerTimerSpan.outerHTML;
            }

            showWinner() {
                 // 只有 AI 模式
                let playerName = this.winner === 1 ? '你' : '硕神AI';

                const message = document.getElementById('winnerMessage');
                const timeStr = this.formatTime(this.elapsedTime);
                let messageText = `🎉 ${playerName} 获胜！`;
                
                // [嘲讽] AI 获胜时添加嘲讽
                if (this.winner === 2) {
                    const targets = ["小强强", "小辉辉"];
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    let taunts = [ // 硕神胜利嘲讽
                        `6层搜索，${target}你拿什么赢？`, `凡人${target}，你尽力了。`, `我的每一步，都是最优解。`,
                        `${target}, 你甚至没能逼我走出开局库。`, `结束了, ${target}, 游戏才刚刚开始。`,
                        `不堪一击，${target}。`, `回去再练练吧，${target}！`
                    ];
                    const taunt = taunts[Math.floor(Math.random() * taunts.length)];
                    messageText += `<span class="ai-taunt">${taunt}</span>`;
                }

                // 玩家获胜记录时间
                if (this.winner === 1) {
                    messageText += `<br>⏱️ 用时：${timeStr}`;
                    const bestTimeKey = `bestTime_god`; // 固定 Key
                    const currentBest = localStorage.getItem(bestTimeKey);

                    if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
                        localStorage.setItem(bestTimeKey, this.elapsedTime);
                        this.loadBestTime();
                        messageText += `<br>🏆 新纪录！你竟然赢了硕神？！`;
                    } else {
                        messageText += `<br>（虽然赢了，但没破纪录哦）`;
                    }
                }

                message.innerHTML = messageText;
                message.className = 'winner-message show';
                message.style.color = this.winner === 1 ? '#4caf50' : '#d32f2f'; // 玩家赢绿色，AI赢红色
            }

            showDraw() {
                const message = document.getElementById('winnerMessage');
                message.innerHTML = '🤝 平局！棋盘已满';
                message.className = 'winner-message show';
                message.style.color = '#ff9800';
            }
            
            // 启动玩家计时器
            startPlayerTimer() {
                // [玩家计时.启动逻辑修正] 确保游戏未结束且确实轮到玩家
                if (this.gameOver || this.currentPlayer !== 1) return; 
                
                this.stopPlayerTimer(); // 先清除旧的
                this.playerTimeLeft = 10;
                this.updateCurrentPlayer(); // 更新显示 (10s)
                
                this.playerTimerId = setInterval(() => {
                    // 再次检查，防止计时器在不该跑的时候跑
                     if (this.gameOver || this.currentPlayer !== 1) {
                         this.stopPlayerTimer();
                         return;
                     }
                    
                    this.playerTimeLeft--;
                    this.updateCurrentPlayer(); // 更新显示
                    
                    if (this.playerTimeLeft <= 0) {
                        this.forceRandomMove();
                    }
                }, 1000); // 每秒执行
            }
            
            // 停止玩家计时器
            stopPlayerTimer() {
                 if (this.playerTimerId) {
                    clearInterval(this.playerTimerId);
                    this.playerTimerId = null; // 清除 ID 很重要
                }
                 // 清除计时显示 
                 const playerTimerSpan = document.getElementById('playerTimeLeft');
                 if(playerTimerSpan) playerTimerSpan.textContent = '';
                 // 确保UI立即更新为不带计时器状态 (如果当前是玩家回合)
                 if (!this.gameOver && this.currentPlayer === 1) {
                     // 调用 updateCurrentPlayer 可能会意外启动计时器，直接设置文本
                     const playerText = '<span class="player-black">● 你（黑棋）</span>';
                     document.getElementById('currentPlayer').innerHTML = '当前玩家：' + playerText;
                 }
            }
            
            // 强制随机落子
            forceRandomMove() {
                 this.stopPlayerTimer(); // 确保停止
                 if (this.gameOver || this.currentPlayer !== 1) return; // 游戏已结束或不是玩家回合
                 
                 console.warn("玩家超时，强制随机落子！");
                 const randomMove = this.getRandomMoveForMainThread();
                 
                 // 短暂提示
                 const aiThinkingEl = document.getElementById('aiThinking');
                 aiThinkingEl.innerHTML = `⏰ 时间到！已替你随机落子！`;
                 aiThinkingEl.style.display = 'block';
                 
                 if (randomMove) {
                     // 延迟一点点执行，让提示能被看到
                     setTimeout(() => {
                         // 检查游戏是否在延迟期间结束了，并且确认现在是玩家回合
                         if (!this.gameOver && this.currentPlayer === 1) {
                            // 强制落子也算一步有效操作
                            this.makeMove(randomMove.row, randomMove.col); 
                         }
                     }, 500);
                 } else {
                     aiThinkingEl.innerHTML = `⏰ 时间到！但棋盘已满？`;
                 }
            }


            _internalReset() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 2; // AI 先手
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.currentHash = 0;
                
                this.stopTimer(); // 停止游戏总计时
                this.stopPlayerTimer(); // 停止玩家计时
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                this.drawBoard(); // 画空棋盘
                // updateCurrentPlayer 会在 startNewGame 中调用
            }
            
            startNewGame() { 
                this._internalReset();
                // [AI瞬时开局.3] 重开游戏时，也立即执行 AI 第一步
                 // 使用 setTimeout 确保 UI 渲染完成后再执行
                setTimeout(() => {
                     this.performAiFirstMove();
                }, 0);
            }

            startTimer() {
                if (this.timerInterval) return; // 防止重复启动
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    // 只有游戏进行中才计时
                    if (!this.gameOver) {
                        this.elapsedTime = Date.now() - this.startTime;
                        this.updateTimerDisplay();
                    } else {
                        this.stopTimer(); // 游戏结束，停止计时
                    }
                }, 100); 
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimerDisplay() {
                const timeStr = this.formatTime(this.elapsedTime);
                document.getElementById('currentTime').textContent = timeStr;
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            loadBestTime() {
                const bestTimeKey = `bestTime_god`; // 固定 Key
                const bestTime = localStorage.getItem(bestTimeKey);

                if (bestTime) {
                    const timeStr = this.formatTime(parseInt(bestTime));
                    document.getElementById('bestTime').textContent = timeStr;
                } else {
                    document.getElementById('bestTime').textContent = '--:--';
                }
            }
        }

        // ===============================================
        // 启动逻辑 (UI 线程)
        // ===============================================
        let game; 

        function restartGame() {
            if (!game) return;
            if (confirm('确定要重新开始游戏吗？（硕神AI将立即在天元落子）')) {
                game.startNewGame(); 
            }
        }
        
        // 等待HTML加载完毕后，才初始化游戏
        document.addEventListener('DOMContentLoaded', () => {
            // 直接初始化硕神模式
            game = new GomokuGame();
            
            // 更新规则文本
            const rulesList = document.getElementById('rules-list'); // Get the list by ID
            // 清空旧规则 (如果存在)
            while (rulesList.firstChild) {
                 rulesList.removeChild(rulesList.firstChild);
            }
            // 添加新规则
            const rules = [
                 '🔥 **硕神模式**: AI执白棋 (2) **立即**在天元落子先行，你执黑棋 (1)',
                 '点击棋盘空白处落子',
                 '先将五个棋子连成一线者获胜（横、竖、斜均可）',
                 '玩家**第一步后**每步思考时间不得超过10秒，超时将随机落子',
                 'AI 每步思考时间上限10秒',
                 '**无悔棋**'
            ];
             rules.forEach(ruleText => {
                 const li = document.createElement('li');
                 li.innerHTML = ruleText; // 使用 innerHTML 支持加粗
                 rulesList.appendChild(li);
             });
        });
    </script>
</body>
</html>
