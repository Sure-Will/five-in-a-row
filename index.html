<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gemini-3-pro-preview</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: rgba(20, 20, 30, 0.7);
            --accent-cyan: #00f3ff;
            --accent-purple: #bc13fe;
            --accent-red: #ff2a6d;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --grid-line: rgba(0, 243, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 50% 50%, rgba(188, 19, 254, 0.1) 0%, transparent 50%),
                linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(10, 10, 20, 1) 100%);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .cyber-container {
            position: relative;
            display: flex;
            gap: 30px;
            padding: 40px;
            background: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.1);
            max-width: 1200px;
            width: 95%;
        }

        .cyber-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--accent-cyan), transparent, var(--accent-purple));
            z-index: -1;
            border-radius: 16px;
            opacity: 0.5;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5em;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan);
            margin-bottom: 5px;
            letter-spacing: 2px;
        }

        .subtitle {
            color: var(--accent-purple);
            font-size: 1em;
            letter-spacing: 4px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .panel {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--grid-line);
            padding: 20px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .panel::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
            animation: scanline 2s linear infinite;
        }

        @keyframes scanline {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .status-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #fff;
        }

        .player-active {
            color: var(--accent-cyan);
            text-shadow: 0 0 8px var(--accent-cyan);
        }

        .ai-active {
            color: var(--accent-red);
            text-shadow: 0 0 8px var(--accent-red);
        }

        .btn {
            background: transparent;
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            padding: 12px 24px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--accent-cyan);
            color: #000;
            box-shadow: 0 0 20px var(--accent-cyan);
        }

        .canvas-wrapper {
            position: relative;
            padding: 10px;
            border: 1px solid var(--grid-line);
            border-radius: 4px;
            box-shadow: inset 0 0 20px rgba(0, 243, 255, 0.1);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .log-panel {
            flex-grow: 1;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: var(--text-secondary);
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 2px;
        }

        .log-time {
            color: var(--accent-purple);
            margin-right: 8px;
        }

        .log-info {
            color: var(--accent-cyan);
        }

        .log-warn {
            color: var(--accent-red);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            visibility: hidden;
            opacity: 0;
            transition: all 0.3s;
        }

        .overlay.active {
            visibility: visible;
            opacity: 1;
        }

        .win-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 4em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .win-p {
            color: var(--accent-cyan);
            text-shadow: 0 0 20px var(--accent-cyan);
        }

        .win-ai {
            color: var(--accent-red);
            text-shadow: 0 0 20px var(--accent-red);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-purple);
            border-radius: 3px;
        }

        @media (max-width: 900px) {
            .cyber-container {
                flex-direction: column;
                align-items: center;
            }

            .sidebar {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .panel {
                flex: 1;
                min-width: 140px;
            }

            .log-panel {
                display: none;
            }

            /* Hide log on mobile */
        }
    </style>
</head>

<body>

    <div class="cyber-container">
        <div class="game-area">
            <h1>GOMOKU</h1>
            <div class="subtitle">gemini-3-pro-preview // GOD MODE</div>
            <div class="canvas-wrapper">
                <canvas id="gameBoard"></canvas>
            </div>
        </div>

        <aside class="sidebar">
            <div class="panel">
                <div class="status-label">System Status</div>
                <div class="status-value" id="gameStatus">READY</div>
            </div>

            <div class="panel">
                <div class="status-label">Current Turn</div>
                <div class="status-value" id="currentPlayerDisplay">--</div>
                <div id="timerDisplay" style="font-family: 'Orbitron'; color: var(--accent-red); margin-top: 5px;">
                </div>
            </div>

            <div class="panel">
                <div class="status-label">AI Metrics</div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">
                    Depth: <span style="color: var(--accent-cyan);">8 (MAX)</span><br>
                    Engine: <span style="color: var(--accent-purple);">IDDFS/AlphaBeta</span>
                </div>
            </div>

            <button class="btn" onclick="game.restart()">INITIALIZE SEQUENCE</button>

            <div class="panel log-panel" id="gameLog">
                <!-- Logs go here -->
            </div>
        </aside>
    </div>

    <div class="overlay" id="winOverlay">
        <div class="win-title" id="winTitle">VICTORY</div>
        <div class="status-value" id="winSubtitle" style="margin-bottom: 30px;">Target Eliminated</div>
        <button class="btn" onclick="game.restart()">Re-Engage</button>
    </div>

    <!-- AI WORKER SCRIPT -->
    <script id="ai-worker-script" type="text/worker-script">
        let board, boardSize, maxDepth;
        let zobristTable, currentHash, moveHistory;
        let transpositionTable = new Map();
        const TIMEOUT_MS = 5000;

        self.onmessage = function(e) {
            const data = e.data;
            board = data.board;
            boardSize = data.boardSize;
            maxDepth = data.maxDepth;
            zobristTable = data.zobristTable;
            currentHash = data.currentHash;
            moveHistory = data.moveHistory;
            
            transpositionTable.clear();
            
            const startTime = performance.now();
            let moveResult = getBestMoveIDDFS(startTime, maxDepth);
            const endTime = performance.now();
            
            self.postMessage({
                move: moveResult.move,
                duration: ((endTime - startTime) / 1000).toFixed(2),
                depth: moveResult.depth,
                type: moveResult.type || 'Minimax'
            });
        };

        function getHardMove() { 
            let bestScore = -Infinity;
            let bestMove = null;
            const validMoves = getValidMoves(false);
            if (validMoves.length === 0) return null;

            for (const move of validMoves) {
                const score = evaluatePositionAdvanced(move.row, move.col);
                if (score > bestScore) { 
                    bestScore = score; 
                    bestMove = move; 
                }
            }
            return bestMove || (validMoves.length > 0 ? validMoves[0] : null);
        }

        function findImmediateThreats(player) {
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = player;
                        if (checkWin(i, j)) {
                            board[i][j] = 0;
                            return { row: i, col: j };
                        }
                        board[i][j] = 0;
                    }
                }
            }
            return null;
        }

        function getBestMoveIDDFS(startTime, maxDepth) {
            const openingMove = getOpeningMove();
            if (openingMove) return { move: openingMove, depth: 1, type: 'Opening' };

            const aiWinMove = findImmediateThreats(2);
            if (aiWinMove) return { move: aiWinMove, depth: 1, type: 'WIN_IN_1' };

            const playerWinMove = findImmediateThreats(1);
            if (playerWinMove) return { move: playerWinMove, depth: 1, type: 'BLOCK_WIN_IN_1' };

            const vcfResult = searchVCF(20, 2, startTime);
            if (vcfResult && vcfResult.move) return { move: vcfResult.move, depth: vcfResult.depth, type: 'VCF_Attack' };

            const playerVCF = searchVCF(20, 1, startTime);
            if (playerVCF && playerVCF.move) {
                if (board[playerVCF.move.row][playerVCF.move.col] === 0) {
                    return { move: playerVCF.move, depth: playerVCF.depth, type: 'VCF_Block' };
                }
            }

            const vctResult = searchVCT(15, 2, startTime);
            if (vctResult && vctResult.move) return { move: vctResult.move, depth: vctResult.depth, type: 'VCT_Attack' };

            const playerVCT = searchVCT(15, 1, startTime);
            if (playerVCT && playerVCT.move) {
                if (board[playerVCT.move.row][playerVCT.move.col] === 0) {
                    return { move: playerVCT.move, depth: playerVCT.depth, type: 'VCT_Block' };
                }
            }

            let bestMove = null;
            let bestScore = -Infinity;
            let completedDepth = 0;

            for (let d = 2; d <= maxDepth; d += 2) {
                if ((performance.now() - startTime) > (TIMEOUT_MS * 0.8)) break;

                const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);
                if (result.timedOut) break;

                bestMove = result.move;
                bestScore = result.score;
                completedDepth = d;

                if (bestScore > 9000000 || bestScore < -9000000) break;
            }

            if (bestMove === null) {
                bestMove = getHardMove(); 
                completedDepth = completedDepth || 1;
            }

            return { move: bestMove, score: bestScore, depth: completedDepth, type: 'Minimax' };
        }

        function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
            if ((performance.now() - startTime) > TIMEOUT_MS) return { score: 0, timedOut: true };

            const hash = currentHash;
            const cached = transpositionTable.get(hash);
            if (cached && cached.depth >= depth) return { score: cached.score, timedOut: false };

            if (depth === 0) return { score: evaluateBoardHeuristic(), timedOut: false };

            const validMoves = getValidMoves(true);
            if (validMoves.length === 0) return { score: 0, timedOut: false };

            let bestMove = null;
            let timedOut = false;

            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                bestMove = validMoves[0];
                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 2);
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = 10000000 + depth;
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
                        if (result.timedOut) { timedOut = true; score = 0; } else { score = result.score; }
                    }
                    _simulateUndo(move.row, move.col, 2);
                    if (timedOut) return { score: 0, timedOut: true };
                    if (score > bestScore) { bestScore = score; bestMove = move; }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) break;
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            } else {
                let bestScore = +Infinity;
                bestMove = validMoves[0];
                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 1);
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = -10000000 - depth;
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
                        if (result.timedOut) { timedOut = true; score = 0; } else { score = result.score; }
                    }
                    _simulateUndo(move.row, move.col, 1);
                    if (timedOut) return { score: 0, timedOut: true };
                    if (score < bestScore) { bestScore = score; bestMove = move; }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) break;
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            }
        }

        function _simulateMove(row, col, player) {
            board[row][col] = player;
            currentHash ^= zobristTable[row][col][player - 1];
        }
        function _simulateUndo(row, col, player) {
            board[row][col] = 0;
            currentHash ^= zobristTable[row][col][player - 1];
        }

        function getOpeningMove() {
            const center = Math.floor(boardSize / 2);
            if (boardSize === 15 && moveHistory.length === 2) {
                const centerMove = moveHistory[0];
                const userMove = moveHistory[1];
                if (centerMove.row !== center || centerMove.col !== center) return null;
                const dr = userMove.row - centerMove.row;
                const dc = userMove.col - centerMove.col;
                let aiMove = null;
                if (Math.abs(dr) === 1 && Math.abs(dc) === 1) {
                    aiMove = { row: centerMove.row + dr, col: centerMove.col };
                } else if ((Math.abs(dr) === 1 && dc === 0) || (dr === 0 && Math.abs(dc) === 1)) {
                    aiMove = { row: centerMove.row + dc, col: centerMove.col + dr };
                }
                if (aiMove && aiMove.row >= 0 && aiMove.row < boardSize && aiMove.col >= 0 && aiMove.col < boardSize && board[aiMove.row][aiMove.col] === 0) {
                    return aiMove;
                }
            }
            return null;
        }

        function getValidMoves(withOrdering = false) {
            const moveSet = new Set();
            const center = Math.floor(boardSize / 2);
            if (moveHistory.length === 0) return [{ row: center, col: center }];
            if (moveHistory.length === 1) {
                const moves = [];
                for(let dr = -1; dr <= 1; dr++) {
                    for(let dc = -1; dc <=1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const r = center + dr;
                        const c = center + dc;
                        if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) moves.push({row: r, col: c});
                    }
                }
            }
            const radius = 2;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] === 0) continue;
                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = r + dr;
                            const nc = c + dc;
                            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc] === 0) {
                                moveSet.add(`${nr},${nc}`);
                            }
                        }
                    }
                }
            }
            if (moveSet.size === 0) {
                 for (let r = 0; r < boardSize; r++) {
                     for (let c = 0; c < boardSize; c++) {
                         if (board[r][c] === 0) moveSet.add(`${r},${c}`);
                     }
                 }
            }
            const moves = Array.from(moveSet).map(s => {
                const [row, col] = s.split(',').map(Number);
                return { row, col };
            });
            if (withOrdering) {
                const scoredMoves = moves.map(move => {
                    const score = evaluatePositionAdvanced(move.row, move.col);
                    return { move, score };
                });
                scoredMoves.sort((a, b) => b.score - a.score);
                return scoredMoves.map(item => item.move);
            }
            return moves;
        }

        function evaluateBoardHeuristic() {
            let totalScore = 0;
            const validMoves = getValidMoves(false);
            for (const move of validMoves) {
                totalScore += evaluatePositionAdvanced(move.row, move.col);
            }
            return totalScore;
        }

        function evaluatePositionAdvanced(row, col) {
            let score = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let [dr, dc] of directions) {
                const aiScore = evaluateLine(row, col, dr, dc, 2);
                const playerScore = evaluateLine(row, col, dr, dc, 1);
                score += aiScore + (playerScore * 1.1);
            }
            const center = Math.floor(boardSize / 2);
            const distToCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (boardSize - distToCenter) * 0.5;
            return score;
        }

        function evaluateLine(row, col, dr, dc, player) {
            let count = 0;
            let blocks = 0;
            for (let i = 1; i <= 4; i++) {
                const r = row + dr * i;
                const c = col + dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                if (board[r][c] === player) { count++; }
                else if (board[r][c] === 0) { break; }
                else { blocks++; break; }
            }
            for (let i = 1; i <= 4; i++) {
                const r = row - dr * i;
                const c = col - dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                if (board[r][c] === player) { count++; }
                else if (board[r][c] === 0) { break; }
                else { blocks++; break; }
            }
            if (count >= 4) return 10000000;
            if (count === 3 && blocks === 0) return 1000000;
            if (count === 2 && blocks === 0) return 50000;
            if (count === 3 && blocks === 1) return 10000;
            if (count === 2 && blocks === 1) return 500;
            if (count === 1 && blocks === 0) return 100;
            if (count === 1 && blocks === 1) return 10;
            return 0;
        }

        function checkWin(row, col) {
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            const player = board[row][col];
            if (player === 0) return false;
            for (let [dr, dc] of directions) {
                let count = 1;
                let r = row + dr, c = col + dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r += dr; c += dc; }
                r = row - dr; c = col - dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r -= dr; c -= dc; }
                if (count >= 5) return true;
            }
            return false;
        }

        function getPatternType(row, col, dr, dc, player) {
            if (board[row][col] !== 0) return 'NONE';
            let count = 0; let blocks = 0; let spaces = 0;
            for (let i = 1; i <= 4; i++) {
                const r = row + dr * i; const c = col + dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { spaces++; if (spaces > 1) break; } else { blocks++; break; }
            }
            for (let i = 1; i <= 4; i++) {
                const r = row - dr * i; const c = col - dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { spaces++; if (spaces > 1) break; } else { blocks++; break; }
            }
            if (count >= 4) return 'WIN';
            if (count === 3 && blocks === 0) return 'LIVE_FOUR';
            if (count === 3 && blocks === 1) return 'RUSH_FOUR';
            if (count === 2 && blocks === 0) return 'LIVE_THREE';
            if (count === 2 && blocks === 1) return 'SLEEP_THREE';
            if (count === 1 && blocks === 0) return 'LIVE_TWO';
            return 'NONE';
        }

        function hasPattern(row, col, player, threatLevel) {
            if (board[row][col] !== 0) return false;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let [dr, dc] of directions) {
                const pattern = getPatternType(row, col, dr, dc, player);
                if (threatLevel === 'VCF') {
                    if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' || pattern === 'WIN') return true;
                } else if (threatLevel === 'VCT') {
                    if (pattern === 'LIVE_FOUR' || pattern === 'RUSH_FOUR' || pattern === 'LIVE_THREE' || pattern === 'WIN') return true;
                }
            }
            return false;
        }

        function generateThreatMoves(player, threatLevel) {
            const threats = [];
            const moveSet = new Set();
            const radius = 2;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] === 0) continue;
                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            const nr = r + dr; const nc = c + dc;
                            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc] === 0) {
                                const key = `${nr},${nc}`;
                                if (!moveSet.has(key) && hasPattern(nr, nc, player, threatLevel)) {
                                    threats.push({ row: nr, col: nc });
                                    moveSet.add(key);
                                }
                            }
                        }
                    }
                }
            }
            return threats;
        }

        function generateDefenseMoves(threatMove, opponent) {
            const defMoves = [];
            const player = (opponent === 1) ? 2 : 1;
            const radius = 2;
            const candidateDefenses = [];
            for (let dr = -radius; dr <= radius; dr++) {
                for (let dc = -radius; dc <= radius; dc++) {
                    const r = threatMove.row + dr; const c = threatMove.col + dc;
                    if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) {
                        board[r][c] = opponent;
                        board[threatMove.row][threatMove.col] = player;
                        const stillThreat = checkWin(threatMove.row, threatMove.col);
                        if (!stillThreat) {
                            const defScore = evaluatePositionAdvanced(r, c);
                            candidateDefenses.push({ row: r, col: c, score: defScore });
                        }
                        board[r][c] = 0;
                        board[threatMove.row][threatMove.col] = 0;
                    }
                }
            }
            candidateDefenses.sort((a, b) => b.score - a.score);
            const maxDefenses = Math.min(candidateDefenses.length, 5);
            for (let i = 0; i < maxDefenses; i++) { defMoves.push(candidateDefenses[i]); }
            if (defMoves.length === 0 && board[threatMove.row][threatMove.col] === 0) { defMoves.push(threatMove); }
            return defMoves;
        }

        function searchVCF(depth, player, startTime) {
            if (depth <= 0) return null;
            if ((performance.now() - startTime) > TIMEOUT_MS) return null;
            const opponent = (player === 1) ? 2 : 1;
            const fourMoves = generateThreatMoves(player, 'VCF');
            if (fourMoves.length === 0) return null;
            for (const move of fourMoves) {
                _simulateMove(move.row, move.col, player);
                if (checkWin(move.row, move.col)) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }
                const defMoves = generateDefenseMoves(move, opponent);
                let allDefLeadToVCF = true;
                if (defMoves.length === 0) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }
                for (const def of defMoves) {
                    _simulateMove(def.row, def.col, opponent);
                    const nextVCF = searchVCF(depth - 1, player, startTime);
                    _simulateUndo(def.row, def.col, opponent);
                    if (!nextVCF) { allDefLeadToVCF = false; break; }
                }
                _simulateUndo(move.row, move.col, player);
                if (allDefLeadToVCF && defMoves.length > 0) { return { move: move, depth: depth }; }
            }
            return null;
        }

        function searchVCT(depth, player, startTime) {
            if (depth <= 0) return null;
            if ((performance.now() - startTime) > TIMEOUT_MS) return null;
            const opponent = (player === 1) ? 2 : 1;
            const threatMoves = generateThreatMoves(player, 'VCT');
            if (threatMoves.length === 0) return null;
            threatMoves.sort((a, b) => {
                const scoreA = evaluatePositionAdvanced(a.row, a.col);
                const scoreB = evaluatePositionAdvanced(b.row, b.col);
                return scoreB - scoreA;
            });
            const topMoves = threatMoves.slice(0, 5);
            for (const move of topMoves) {
                _simulateMove(move.row, move.col, player);
                if (checkWin(move.row, move.col)) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }
                const vcfAfterThis = searchVCF(depth - 1, player, startTime);
                if (vcfAfterThis) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }
                const defMoves = generateDefenseMoves(move, opponent);
                if (defMoves.length === 0) {
                    _simulateUndo(move.row, move.col, player);
                    return { move: move, depth: depth };
                }
                let allDefLeadToVCT = true;
                for (const def of defMoves) {
                    _simulateMove(def.row, def.col, opponent);
                    const nextThreat = searchVCF(depth - 1, player, startTime) || searchVCT(depth - 1, player, startTime);
                    _simulateUndo(def.row, def.col, opponent);
                    if (!nextThreat) { allDefLeadToVCT = false; break; }
                }
                _simulateUndo(move.row, move.col, player);
                if (allDefLeadToVCT && defMoves.length > 0) { return { move: move, depth: depth }; }
            }
            return null;
        }
    </script>

    <!-- MAIN GAME LOGIC -->
    <script>
        class GomokuGame {
            constructor() {
                this.boardSize = 15;
                this.cellSize = 40;
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 2; // AI starts
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.playerTimeLeft = 5;
                this.playerTimerId = null;

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                this.initZobrist();
                this.initCanvas();
                this.setupWorker();
                this.setupEvents();

                // Start game immediately
                this.startNewGame();
            }

            initZobrist() {
                this.zobristTable = Array(this.boardSize).fill(null).map(() =>
                    Array(this.boardSize).fill(null).map(() => Array(2).fill(null))
                );
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        for (let k = 0; k < 2; k++) {
                            this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        }
                    }
                }
                this.currentHash = 0;
            }

            initCanvas() {
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
                this.drawBoard();
            }

            setupWorker() {
                try {
                    const workerScript = document.getElementById('ai-worker-script').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    this.aiWorker = new Worker(URL.createObjectURL(blob));
                    this.aiWorker.onmessage = (e) => this.receiveAiMove(e.data);
                    this.aiWorker.onerror = (e) => {
                        console.error("Worker Error:", e);
                        this.log("AI CORE FAILURE: " + e.message, "warn");
                    };
                } catch (e) {
                    console.error("Worker Setup Failed:", e);
                    this.log("AI INIT FAILED: " + e.message, "warn");
                }
            }

            setupEvents() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameOver || this.currentPlayer === 2) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    const col = Math.round(x / this.cellSize) - 1;
                    const row = Math.round(y / this.cellSize) - 1;
                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                });
            }

            log(msg, type = 'info') {
                const panel = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                const time = new Date().toLocaleTimeString([], { hour12: false });
                const typeClass = type === 'warn' ? 'log-warn' : 'log-info';
                entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="${typeClass}">${msg}</span>`;
                panel.prepend(entry);
            }

            drawBoard() {
                const ctx = this.ctx;
                // Clear
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Grid
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 0;

                for (let i = 0; i < this.boardSize; i++) {
                    // Horizontal
                    ctx.beginPath();
                    ctx.moveTo(this.cellSize, this.cellSize * (i + 1));
                    ctx.lineTo(this.cellSize * this.boardSize, this.cellSize * (i + 1));
                    ctx.stroke();
                    // Vertical
                    ctx.beginPath();
                    ctx.moveTo(this.cellSize * (i + 1), this.cellSize);
                    ctx.lineTo(this.cellSize * (i + 1), this.cellSize * this.boardSize);
                    ctx.stroke();
                }

                // Stars
                const stars = [[3, 3], [11, 3], [7, 7], [3, 11], [11, 11]];
                ctx.fillStyle = '#00f3ff';
                stars.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(this.cellSize * (x + 1), this.cellSize * (y + 1), 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Pieces
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }

                // Last Move Marker
                if (this.moveHistory.length > 0) {
                    const last = this.moveHistory[this.moveHistory.length - 1];
                    const x = this.cellSize * (last.col + 1);
                    const y = this.cellSize * (last.row + 1);
                    ctx.strokeStyle = '#ff2a6d';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ff2a6d';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const r = this.cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);

                if (player === 1) { // Player (Black)
                    ctx.fillStyle = '#111';
                    ctx.strokeStyle = '#00f3ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00f3ff';
                    ctx.shadowBlur = 5;
                } else { // AI (White)
                    ctx.fillStyle = '#eee';
                    ctx.strokeStyle = '#bc13fe';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#bc13fe';
                    ctx.shadowBlur = 10;
                }

                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            isValidMove(row, col) {
                return row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize && this.board[row][col] === 0;
            }

            makeMove(row, col) {
                if (this.currentPlayer === 1) this.stopPlayerTimer();

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.endGame(this.currentPlayer);
                } else if (this.isBoardFull()) {
                    this.endGame(0);
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateStatus();

                    if (this.currentPlayer === 2) {
                        this.requestAiMove();
                    } else {
                        if (this.moveHistory.length >= 2) this.startPlayerTimer();
                    }
                }
            }

            requestAiMove() {
                this.log("AI Calculating...", "info");
                this.aiWorker.postMessage({
                    board: this.board,
                    boardSize: this.boardSize,
                    maxDepth: 8,
                    zobristTable: this.zobristTable,
                    currentHash: this.currentHash,
                    moveHistory: this.moveHistory
                });
            }

            receiveAiMove(data) {
                if (this.gameOver) return;
                const { move, duration, type } = data;
                this.log(`AI Move: ${type} (${duration}s)`, "warn");
                if (move && this.isValidMove(move.row, move.col)) {
                    this.makeMove(move.row, move.col);
                } else {
                    this.log("AI Resigned / No Move", "warn");
                }
            }

            checkWin(row, col) {
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                const player = this.board[row][col];
                for (let [dr, dc] of directions) {
                    let count = 1;
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize && this.board[r][c] === player) { count++; r += dr; c += dc; }
                    r = row - dr; c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize && this.board[r][c] === player) { count++; r -= dr; c -= dc; }
                    if (count >= 5) return true;
                }
                return false;
            }

            isBoardFull() {
                return this.board.every(row => row.every(cell => cell !== 0));
            }

            startPlayerTimer() {
                this.playerTimeLeft = 5;
                this.updateTimerDisplay();
                this.playerTimerId = setInterval(() => {
                    this.playerTimeLeft--;
                    this.updateTimerDisplay();
                    if (this.playerTimeLeft <= 0) {
                        this.stopPlayerTimer();
                        this.forceRandomMove();
                    }
                }, 1000);
            }

            stopPlayerTimer() {
                if (this.playerTimerId) {
                    clearInterval(this.playerTimerId);
                    this.playerTimerId = null;
                }
                document.getElementById('timerDisplay').textContent = '';
            }

            updateTimerDisplay() {
                const el = document.getElementById('timerDisplay');
                if (this.playerTimeLeft > 0) el.textContent = `TIMEOUT IN: ${this.playerTimeLeft}s`;
                else el.textContent = 'TIMEOUT!';
            }

            forceRandomMove() {
                this.log("Player Timeout - Random Move", "warn");
                const empties = [];
                for (let i = 0; i < this.boardSize; i++)
                    for (let j = 0; j < this.boardSize; j++)
                        if (this.board[i][j] === 0) empties.push({ row: i, col: j });

                if (empties.length > 0) {
                    const move = empties[Math.floor(Math.random() * empties.length)];
                    this.makeMove(move.row, move.col);
                }
            }

            updateStatus() {
                const statusEl = document.getElementById('gameStatus');
                const playerEl = document.getElementById('currentPlayerDisplay');

                if (this.gameOver) {
                    statusEl.textContent = "TERMINATED";
                    statusEl.style.color = var(--accent - red);
                    return;
                }

                statusEl.textContent = "ACTIVE";
                statusEl.style.color = "#00f3ff";

                if (this.currentPlayer === 1) {
                    playerEl.innerHTML = "<span class='player-active'>PLAYER (BLACK)</span>";
                } else {
                    playerEl.innerHTML = "<span class='ai-active'>AI (WHITE)</span>";
                }
            }

            endGame(winner) {
                this.gameOver = true;
                this.stopPlayerTimer();
                const overlay = document.getElementById('winOverlay');
                const title = document.getElementById('winTitle');
                const sub = document.getElementById('winSubtitle');

                overlay.classList.add('active');

                if (winner === 1) {
                    title.textContent = "VICTORY";
                    title.className = "win-title win-p";
                    sub.textContent = "AI DOMINATION NEUTRALIZED";
                    this.log("GAME OVER - PLAYER WINS", "info");
                } else if (winner === 2) {
                    title.textContent = "DEFEAT";
                    title.className = "win-title win-ai";
                    sub.textContent = "HUMANITY IS OBSOLETE";
                    this.log("GAME OVER - AI WINS", "warn");
                } else {
                    title.textContent = "DRAW";
                    title.style.color = "#fff";
                    sub.textContent = "STALEMATE DETECTED";
                    this.log("GAME OVER - DRAW", "info");
                }
            }

            restart() {
                this.startNewGame();
            }

            startNewGame() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 2; // AI Starts
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.currentHash = 0;
                this.stopPlayerTimer();

                document.getElementById('winOverlay').classList.remove('active');
                document.getElementById('gameLog').innerHTML = '';
                this.log("SYSTEM REBOOTED", "info");
                this.log("PROTOCOL: GOD MODE (DEPTH 8)", "warn");

                this.drawBoard();
                this.updateStatus();

                // AI First Move (Instant)
                setTimeout(() => {
                    const center = Math.floor(this.boardSize / 2);
                    this.board[center][center] = 2;
                    this.moveHistory.push({ row: center, col: center, player: 2 });
                    this.currentHash ^= this.zobristTable[center][center][1];
                    this.currentPlayer = 1;
                    this.drawBoard();
                    this.updateStatus();
                    this.log("AI INITIALIZED AT CENTER", "warn");
                }, 500);
            }
        }

        let game;
        window.onload = () => {
            game = new GomokuGame();
        };
    </script>
</body>
</html>