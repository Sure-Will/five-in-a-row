<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹æ¸¸æˆ - Gomoku</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 850px;
            width: 100%; 
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .difficulty-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap; 
        }

        .diff-btn {
            padding: 8px 16px;
            font-size: 0.95em;
            border: 2px solid #4caf50;
            background: white;
            color: #4caf50;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .diff-btn[onclick*="'god'"] {
            border-color: #f44336;
            color: #f44336;
        }
        .diff-btn[onclick*="'god'"].active {
            background: #f44336;
            color: white;
        }

        .diff-btn.active {
            background: #4caf50;
            color: white;
        }

        .diff-btn:hover {
            transform: translateY(-2px);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .current-player {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }

        .player-black {
            color: #000;
        }

        .player-white {
            color: #666;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-restart {
            background: #4caf50;
            color: white;
        }

        .btn-restart:hover {
            background: #45a049;
        }
        
        /* [ç§»é™¤æ£‹ç›˜] æŒ‰é’®æ ·å¼å·²åˆ é™¤ */

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        #gameBoard {
            background: #daa520;
            border: 3px solid #8b6914;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            
            /* æ‰‹æœºé€‚é… */
            max-width: 100%;
            height: auto; 
        }

        .winner-message {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #4caf50;
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 10px;
            display: none;
        }

        .winner-message.show {
            display: block;
            animation: slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .instructions {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style-position: inside;
            color: #333;
            line-height: 1.8;
        }

        .ai-thinking {
            text-align: center;
            font-size: 1.1em;
            color: #ff9800;
            margin: 10px 0;
            font-weight: bold;
        }

        .timer-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .timer-item {
            text-align: center;
        }

        .timer-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .timer-value {
            font-size: 2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .best-time {
            color: #ffd700;
        }
        
        /* å˜²è®½æ–‡æ¡ˆçš„æ ·å¼ */
        .ai-taunt {
            font-size: 0.8em;
            color: #f44336; /* çº¢è‰² */
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            .game-info {
                flex-direction: column;
                gap: 10px;
            }
            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }
            .mode-selector {
                flex-direction: column;
            }
            .timer-container {
                flex-direction: column;
                gap: 10px;
            }
            .timer-value {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® äº”å­æ£‹</h1>
        <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

        <div class="mode-selector">
            <button class="mode-btn" onclick="setGameMode('pvp')">ğŸ‘¥ åŒäººå¯¹æˆ˜</button>
            <button class="mode-btn active" onclick="setGameMode('ai')">ğŸ¤– AIå¯¹æˆ˜</button>
        </div>

       <div class="difficulty-selector" id="difficultySelector" style="display: flex;">
            <span style="font-weight: bold; margin-right: 10px;">AIéš¾åº¦ï¼š</span>
            <button class="diff-btn" onclick="setDifficulty('easy', event)">ç®€å•</button>
            <button class="diff-btn" onclick="setDifficulty('medium', event)">ä¸­ç­‰</button>
            <button class="diff-btn" onclick="setDifficulty('hard', event)">å›°éš¾</button>
            <button class="diff-btn" onclick="setDifficulty('nightmare', event)">ğŸ˜± å™©æ¢¦</button>
            <button class="diff-btn" onclick="setDifficulty('god', event)">ğŸ”¥ ç¥</button>
        </div>

        <div class="game-info">
            <div class="current-player" id="currentPlayer">
                å½“å‰ç©å®¶ï¼š<span class="player-black">â— é»‘æ£‹</span>
            </div>
            <div class="controls">
                <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
        </div>

        <div class="ai-thinking" id="aiThinking" style="display: none;">ğŸ¤– AIæ€è€ƒä¸­...</div>

        <div class="timer-container">
            <div class="timer-item">
                <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
                <div class="timer-value" id="currentTime">00:00</div>
            </div>
            <div class="timer-item">
                <div class="timer-label">ğŸ† æœ€ä½³è®°å½•</div>
                <div class="timer-value best-time" id="bestTime">--:--</div>
            </div>
        </div>

        <div class="winner-message" id="winnerMessage"></div>

        <div class="board-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="instructions">
            <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
            <ul>
                <li>é»‘æ£‹å…ˆè¡Œï¼Œç™½æ£‹åè¡Œ</li>
                <li>ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­</li>
                <li>å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼‰</li>
                <li>AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹å…ˆè¡Œ</li>
            </ul>
        </div>
    </div>
    
    <script id="ai-worker-script" type="text/worker-script">
        
        // --- Worker å†…çš„å…¨å±€å˜é‡ ---
        let board, boardSize, difficulty, maxDepth;
        let zobristTable, currentHash, moveHistory;
        let transpositionTable = new Map();
        
        const TIMEOUT_MS = 20000; // 20 ç§’

        // --- æ ¸å¿ƒå…¥å£ï¼šæ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯ ---
        self.onmessage = function(e) {
            const data = e.data;
            
            // 1. æ›´æ–° Worker çš„å†…éƒ¨çŠ¶æ€
            board = data.board;
            boardSize = data.boardSize;
            difficulty = data.difficulty;
            maxDepth = data.maxDepth; // å™©æ¢¦(4) æˆ– ç¥(6)
            zobristTable = data.zobristTable;
            currentHash = data.currentHash;
            moveHistory = data.moveHistory;
            
            // 2. æ¯æ¬¡ AI æ€è€ƒæ—¶ï¼Œéƒ½é‡ç½®ç½®æ¢è¡¨
            transpositionTable.clear();
            
            const startTime = performance.now();
            let moveResult = {}; // { move: {row, col}, depth: 0 }
            
            // 3. æ ¹æ®éš¾åº¦é€‰æ‹©ç®—æ³•
            if (difficulty === 'easy') {
                moveResult = { move: getRandomMove(), depth: 0 };
            } else if (difficulty === 'medium') {
                moveResult = { move: getMediumMove(), depth: 1 };
            } else if (difficulty === 'hard') {
                moveResult = { move: getHardMove(), depth: 1 };
            } else if (difficulty === 'nightmare' || difficulty === 'god') {
                // [AI ä¼˜åŒ–.1] è°ƒç”¨è¿­ä»£åŠ æ·±
                moveResult = getBestMoveIDDFS(startTime, maxDepth); 
            }
            
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // 4. å°†ç»“æœå‘å›ä¸»çº¿ç¨‹
            self.postMessage({ 
                move: moveResult.move, 
                duration: duration, 
                depth: moveResult.depth 
            });
        };
        
        // --- AI ç®—æ³• (å·²ä» GomokuGame ç±»ä¸­å‰¥ç¦») ---

        // ç®€å•AI
        function getRandomMove() {
            const emptyPositions = [];
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        emptyPositions.push({ row: i, col: j });
                    }
                }
            }
            if (emptyPositions.length > 0) {
                return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            }
            return null;
        }

        // ä¸­ç­‰AI
        function getMediumMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        const score = evaluatePositionAdvanced(i, j); 
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { row: i, col: j };
                        }
                    }
                }
            }
            return bestMove || getRandomMove(); 
        }

        // å›°éš¾AI
        function getHardMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            // 1. æ£€æŸ¥AIå¿…èƒœ
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = 2; // AI
                        if (checkWin(i, j)) {
                            board[i][j] = 0; 
                            return { row: i, col: j }; 
                        }
                        board[i][j] = 0; 
                    }
                }
            }
            // 2. æ£€æŸ¥ç©å®¶å¿…èƒœ (é˜²å®ˆ)
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = 1; // ç©å®¶
                        if (checkWin(i, j)) {
                            board[i][j] = 0; 
                            return { row: i, col: j }; 
                        }
                        board[i][j] = 0; 
                    }
                }
            }
            // 3. æ­£å¸¸è¯„åˆ†
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        const score = evaluatePositionAdvanced(i, j);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { row: i, col: j };
                        }
                    }
                }
            }
            return bestMove || getRandomMove();
        }
        
        
        // [AI ä¼˜åŒ–.2] è¿­ä»£åŠ æ·± (IDDFS) å…¥å£
        function getBestMoveIDDFS(startTime, maxDepth) {
            const openingMove = getOpeningMove();
            if (openingMove) {
                return { move: openingMove, depth: 1, timedOut: false };
            }

            let bestMove = null;
            let bestScore = -Infinity;
            let completedDepth = 0;

            // è¿­ä»£åŠ æ·±: æœç´¢æ·±åº¦ 2, 4, 6, ... ç›´åˆ° maxDepth
            for (let d = 2; d <= maxDepth; d += 2) {
                
                // æ£€æŸ¥æ˜¯å¦å³å°†è¶…æ—¶ (åœ¨å¼€å§‹ *ä¸‹ä¸€æ¬¡* æ·±åº¦æœç´¢å‰)
                const currentTime = performance.now();
                if ((currentTime - startTime) > TIMEOUT_MS) {
                    break; // è¶…æ—¶ï¼Œä¸å¼€å§‹ä¸‹ä¸€æ¬¡æ›´æ·±çš„æœç´¢
                }

                const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

                if (result.timedOut) {
                    break; // æœ¬æ¬¡æœç´¢è¶…æ—¶ï¼Œåœæ­¢
                }

                // æœ¬æ¬¡æ·±åº¦æœç´¢(d)æˆåŠŸå®Œæˆã€‚ä¿å­˜ç»“æœã€‚
                bestMove = result.move;
                bestScore = result.score;
                completedDepth = d; // è®°å½•å·²å®Œæˆçš„æ·±åº¦
                
                // console.log(`IDDFS: Depth ${d} complete. Best move: ${result.move.row},${result.move.col}. Score: ${result.score}`);

                // æ‰¾åˆ°å¿…èƒœæ£‹ï¼Œæ— éœ€å†æœ
                if (bestScore > 9000000) { 
                    break; 
                }
            }
            
            // å¦‚æœè¿ 2 å±‚éƒ½æ²¡æœå®Œå°±è¶…æ—¶äº† (æä¸å¯èƒ½ï¼Œä½†åšä¸ªä¿åº•)
            if (bestMove === null) {
                bestMove = getHardMove();
                completedDepth = 1;
            }

            return { move: bestMove, score: bestScore, depth: completedDepth };
        }

        // æ ¸å¿ƒï¼šå¸¦ Alpha-Beta å‰ªæçš„ Minimax
        function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
            
            // [è¶…æ—¶] åœ¨æ¯æ¬¡é€’å½’è°ƒç”¨æ—¶æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return { score: 0, timedOut: true }; // å‘ç°è¶…æ—¶ï¼Œç«‹å³è¿”å›
            }

            const hash = currentHash;
            const cached = transpositionTable.get(hash);
            if (cached && cached.depth >= depth) {
                return { score: cached.score, timedOut: false };
            }

            if (depth === 0) {
                const score = evaluateBoardHeuristic();
                return { score: score, timedOut: false };
            }

            const validMoves = getValidMoves(true); // true = å¸¦æ’åº

            if (validMoves.length === 0) {
                return { score: 0, timedOut: false }; // å¹³å±€
            }

            let bestMove = null;
            let timedOut = false;

            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                bestMove = validMoves[0]; 

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 2); // AI (2)
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = 10000000 + depth; // å¿…èƒœ (10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
                        if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 2);
                    
                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            
            } else { // è½®åˆ° Min (ç©å®¶)
                let bestScore = +Infinity;
                bestMove = validMoves[0];

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 1); // ç©å®¶ (1)
                    let score;
                    if (checkWin(move.row, move.col)) {
                        score = -10000000 - depth; // å¿…è´¥ (-10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
                         if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 1);

                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            }
        }

        // æ¨¡æ‹Ÿè½å­ (åªæ”¹æ£‹ç›˜å’Œå“ˆå¸Œ)
        function _simulateMove(row, col, player) {
            board[row][col] = player;
            currentHash ^= zobristTable[row][col][player - 1];
        }
        // æ¨¡æ‹Ÿæ‚”æ£‹
        function _simulateUndo(row, col, player) {
            board[row][col] = 0;
            currentHash ^= zobristTable[row][col][player - 1];
        }

        // å¼€å±€åº“
        function getOpeningMove() {
            const center = Math.floor(boardSize / 2);
            // AI å…ˆæ‰‹ (å™©æ¢¦ / ç¥)
            if (difficulty === 'nightmare' || difficulty === 'god') {
                if (moveHistory.length === 0) {
                    return { row: center, col: center }; // AI ç¬¬ä¸€æ­¥ï¼šèµ°å¤©å…ƒ
                }
                if (boardSize === 15 && moveHistory.length === 2) {
                    // AI ç¬¬äºŒæ­¥ (åº”å¯¹ç©å®¶çš„ç¬¬1æ­¥)
                    const centerMove = moveHistory[0]; // AI (2)
                    const userMove = moveHistory[1];   // Player (1)
                    if (centerMove.row !== center || centerMove.col !== center) return null; 

                    const dr = userMove.row - centerMove.row; 
                    const dc = userMove.col - centerMove.col; 

                    let aiMove = null;
                    if (Math.abs(dr) === 1 && Math.abs(dc) === 1) { // æ–œ
                        aiMove = { row: centerMove.row + dr, col: centerMove.col }; // ç›´
                    } else if ((Math.abs(dr) === 1 && dc === 0) || (dr === 0 && Math.abs(dc) === 1)) { // ç›´
                        aiMove = { row: centerMove.row + dc, col: centerMove.col + dr }; // æ–œ
                    }
                    if (aiMove && board[aiMove.row][aiMove.col] === 0) { // æ£€æŸ¥æœ‰æ•ˆæ€§
                        return aiMove;
                    }
                }
            }
            return null;
        }

        // è·å–æœ‰æ•ˆèµ°æ³• (å¯å¸¦æ’åº)
        function getValidMoves(withOrdering = false) {
            const moveSet = new Set();
            const center = Math.floor(boardSize / 2);

            if (moveHistory.length === 0) {
                return [{ row: center, col: center }];
            }
            
            const radius = 2; // åªæœç´¢æ£‹å­å‘¨å›´2æ ¼
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] === 0) continue; 
                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = r + dr;
                            const nc = c + dc;
                            
                            if (nr >= 0 && nr < boardSize && 
                                nc >= 0 && nc < boardSize && 
                                board[nr][nc] === 0) 
                            {
                                moveSet.add(`${nr},${nc}`);
                            }
                        }
                    }
                }
            }
            
            const moves = Array.from(moveSet).map(s => {
                const [row, col] = s.split(',').map(Number);
                return { row, col };
            });

            if (withOrdering) {
                const scoredMoves = moves.map(move => {
                    const score = evaluatePositionAdvanced(move.row, move.col);
                    return { move, score };
                });
                scoredMoves.sort((a, b) => b.score - a.score);
                return scoredMoves.map(item => item.move);
            }
            return moves;
        }

        // é™æ€æ£‹ç›˜è¯„ä¼° (Minimax å¶èŠ‚ç‚¹ç”¨)
        function evaluateBoardHeuristic() {
            let totalScore = 0;
            const validMoves = getValidMoves(false); 
            
            for (const move of validMoves) {
                totalScore += evaluatePositionAdvanced(move.row, move.col);
            }
            return totalScore;
        }

        // è¯„ä¼° (r, c) è¿™ä¸ª *ç©ºç‚¹* çš„ä»·å€¼ (æ”»+é˜²)
        function evaluatePositionAdvanced(row, col) {
            let score = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (let [dr, dc] of directions) {
                const aiScore = evaluateLine(row, col, dr, dc, 2); // AI åœ¨æ­¤è½å­
                const playerScore = evaluateLine(row, col, dr, dc, 1); // ç©å®¶åœ¨æ­¤è½å­
                score += aiScore + (playerScore * 1.1); 
            }

            const center = Math.floor(boardSize / 2);
            const distToCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (boardSize - distToCenter) * 0.5;

            return score;
        }

        // è¯„ä¼°åœ¨ (r, c) è½å­åï¼Œåœ¨ [dr, dc] æ–¹å‘ä¸Šçš„è¿ç æƒ…å†µ
        function evaluateLine(row, col, dr, dc, player) {
            let count = 0; 
            let blocks = 0; 
            
            // æ‰«ææ­£æ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row + dr * i;
                const c = col + dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++;
                    break;
                }
                if (board[r][c] === player) {
                    count++;
                } else if (board[r][c] === 0) {
                    break; 
                } else {
                    blocks++; 
                    break;
                }
            }

            // æ‰«æåæ–¹å‘
            for (let i = 1; i <= 4; i++) {
                const r = row - dr * i;
                const c = col - dc * i;
                if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) {
                    blocks++;
                    break;
                }
                if (board[r][c] === player) {
                    count++;
                } else if (board[r][c] === 0) {
                    break; 
                } else {
                    blocks++; 
                    break;
                }
            }
            
            // --- æ–°çš„è¯„åˆ†è¡¨ ---
            if (count >= 4) return 10000000; // æˆäº” (10M)
            if (count === 3 && blocks === 0) return 1000000; // æ´»å›› (1M)
            if (count === 2 && blocks === 0) return 50000;   // æ´»ä¸‰ (50K)
            if (count === 3 && blocks === 1) return 10000;  // å†²å›› (10K)
            if (count === 2 && blocks === 1) return 500;   // çœ ä¸‰
            if (count === 1 && blocks === 0) return 100;    // æ´»äºŒ
            if (count === 1 && blocks === 1) return 10;    // çœ äºŒ
            
            return 0;
        }

        // æ£€æŸ¥èƒœåˆ©
        function checkWin(row, col) {
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            const player = board[row][col];
            if (player === 0) return false;

            for (let [dr, dc] of directions) {
                let count = 1;
                let r = row + dr, c = col + dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
                       board[r][c] === player) {
                    count++; r += dr; c += dc;
                }
                r = row - dr; c = col - dc;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize &&
                       board[r][c] === player) {
                    count++; r -= dr; c -= dc;
                }
                if (count >= 5) {
                    return true;
                }
            }
            return false;
        }

    </script>
    
    <script>
        class GomokuGame {
            // [ç§»é™¤æ£‹ç›˜] æ„é€ å‡½æ•°ä¸å†éœ€è¦ boardSize
            constructor(gameMode = 'pvp', difficulty = 'medium') {
                this.boardSize = 15; // å›ºå®šä¸º 15
                
                const maxCanvasWidth = 500;
                this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; // 1 = é»‘æ£‹/ç©å®¶, 2 = ç™½æ£‹/AI
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.gameMode = gameMode; 
                this.difficulty = difficulty; 

                // è®¡æ—¶å™¨ç›¸å…³
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                // AI æ ¸å¿ƒ
                this.NIGHTMARE_DEPTH = 4; // å™©æ¢¦(4)
                this.GOD_DEPTH = 6;       // ç¥(6)
                this.zobristTable = [];
                this.currentHash = 0;
                this.initZobrist();
                
                // åˆå§‹åŒ– Web Worker
                try {
                    const workerScript = document.getElementById('ai-worker-script').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    this.aiWorker = new Worker(URL.createObjectURL(blob));
                    
                    // æ¥æ”¶æ¥è‡ª Worker çš„æ¶ˆæ¯ (AIè®¡ç®—ç»“æœ)
                    this.aiWorker.onmessage = (e) => {
                        this.receiveAiMove(e.data);
                    };
                } catch (error) {
                    console.error("æ— æ³•åˆ›å»º AI Worker: ", error);
                    alert("åŠ è½½AIçº¿ç¨‹å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§æˆ–åˆ·æ–°é¡µé¢ã€‚");
                }


                this.initCanvas();
                this.drawBoard();
                this.setupEventListeners();
                this.loadBestTime();
            }
            
            // åˆå§‹åŒ– Zobrist å“ˆå¸Œè¡¨ (ä¸»çº¿ç¨‹)
            initZobrist() {
                this.zobristTable = Array(this.boardSize).fill(null).map(() => 
                    Array(this.boardSize).fill(null).map(() => 
                        Array(2).fill(null) // 2ä¸ªç©å®¶
                    )
                );
                
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        for (let k = 0; k < 2; k++) {
                            this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        }
                    }
                }
                this.currentHash = 0;
            }


            initCanvas() {
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
            }

            drawBoard() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const boardSize = this.boardSize;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#daa520';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < boardSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
                    ctx.stroke();
                }

                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½ (15x15)
                const drawDot = (x, y) => {
                    ctx.beginPath();
                    ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                };
                
                drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
                drawDot(11, 11); drawDot(7, 7); 

                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }
                
                // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    if (this.gameMode === 'ai' && lastMove.player === 2) {
                        this.highlightLastMove(lastMove.row, lastMove.col);
                    }
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                if (player === 1) {
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else {
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                }
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            highlightLastMove(row, col) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.15; 
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; 
                ctx.fill();
            }

            setupEventListeners() {
                if (this.clickHandler) {
                    this.canvas.removeEventListener('click', this.clickHandler);
                }
                this.clickHandler = (e) => {
                    if (this.gameOver) return;
                    if (this.gameMode === 'ai' && this.currentPlayer === 2) return; 
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const col = Math.round(canvasX / this.cellSize) - 1;
                    const row = Math.round(canvasY / this.cellSize) - 1;
                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                };
                this.canvas.addEventListener('click', this.clickHandler);
            }

            isValidMove(row, col) {
                if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
                    return false;
                }
                return this.board[row][col] === 0;
            }

            // ç©å®¶æˆ–AIçš„ *çœŸå®* è½å­
            makeMove(row, col) {
                if (this.moveHistory.length === 0) {
                    this.startTimer();
                }

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.stopTimer();
                    this.showWinner();
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.stopTimer();
                    this.showDraw();
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateCurrentPlayer();

                    if (this.gameMode === 'ai' && this.currentPlayer === 2) {
                        this.aiMove();
                    }
                }
            }
            
            // aiMove ç°åœ¨äº¤ç»™ Web Worker
            aiMove() {
                const aiThinkingEl = document.getElementById('aiThinking');
                let thinkingText = 'ğŸ¤– AIæ€è€ƒä¸­... (åå°è®¡ç®—ä¸­)';
                let maxDepth = 0;
                
                if (this.difficulty === 'god') {
                    maxDepth = this.GOD_DEPTH;
                    thinkingText = `ğŸ”¥ AI(ç¥)æ€è€ƒä¸­... (è¿­ä»£è‡³D:${maxDepth}, 20sç†”æ–­)`;
                } else if (this.difficulty === 'nightmare') {
                    maxDepth = this.NIGHTMARE_DEPTH;
                     thinkingText = `ğŸ˜± AI(å™©æ¢¦)æ€è€ƒä¸­... (è¿­ä»£è‡³D:${maxDepth}, 20sç†”æ–­)`;
                }
                
                aiThinkingEl.innerHTML = thinkingText;
                aiThinkingEl.style.display = 'block';

                // å°†å½“å‰çŠ¶æ€å‘ç»™ Worker çº¿ç¨‹
                this.aiWorker.postMessage({
                    board: this.board,
                    boardSize: this.boardSize,
                    difficulty: this.difficulty,
                    maxDepth: maxDepth, // ä¼ é€’æœ€å¤§æ·±åº¦
                    zobristTable: this.zobristTable,
                    currentHash: this.currentHash,
                    moveHistory: this.moveHistory
                });
            }
            
            // æ¥æ”¶ Worker çš„è®¡ç®—ç»“æœ
            receiveAiMove(moveData) {
                const { move, duration, depth } = moveData; // [AI ä¼˜åŒ–.3] æ¥æ”¶ depth
                
                const aiThinkingEl = document.getElementById('aiThinking');
                
                // [AI ä¼˜åŒ–.4] æ˜¾ç¤ºAIå®Œæˆçš„æ·±åº¦å’Œç”¨æ—¶
                let depthStr = (depth > 1) ? `(D:${depth})` : ''; 
                aiThinkingEl.innerHTML = `âœ… è½®åˆ°ä½ äº†ï¼ ${depthStr} (ç”¨æ—¶ ${duration}s)`; 
                
                if (move) {
                    if (this.isValidMove(move.row, move.col)) {
                        this.makeMove(move.row, move.col);
                    } else {
                        console.error("AI Worker è¿”å›äº†ä¸€ä¸ªæ— æ•ˆèµ°æ³•: ", move);
                        const randomMove = this.getRandomMoveForMainThread();
                        if(randomMove) this.makeMove(randomMove.row, randomMove.col);
                    }
                } else {
                    aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ? (AIæ— æ£‹å¯èµ°)';
                }
            }

            // ä¸»çº¿ç¨‹çš„ä¿åº•éšæœºèµ°æ³•
            getRandomMoveForMainThread() {
                 const emptyPositions = [];
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            emptyPositions.push({ row: i, col: j });
                        }
                    }
                }
                if (emptyPositions.length > 0) {
                    return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
                return null;
            }

            // ä¸»çº¿ç¨‹ä»ç„¶éœ€è¦ checkWin (ç”¨äºç©å®¶)
            checkWin(row, col) {
                const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
                const player = this.board[row][col];
                if (player === 0) return false;

                for (let [dr, dc] of directions) {
                    let count = 1;
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r += dr; c += dc;
                    }
                    r = row - dr; c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r -= dr; c -= dc;
                    }
                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            isBoardFull() {
                for (let row of this.board) {
                    if (row.includes(0)) {
                        return false;
                    }
                }
                return true;
            }

            updateCurrentPlayer() {
                let playerText;
                if (this.gameMode === 'pvp') {
                    playerText = this.currentPlayer === 1
                        ? '<span class="player-black">â— é»‘æ£‹</span>'
                        : '<span class="player-white">â—‹ ç™½æ£‹</span>';
                } else {
                    playerText = this.currentPlayer === 1
                        ? '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>'
                        : '<span class="player-white">â—‹ AIï¼ˆç™½æ£‹ï¼‰</span>';
                }
                document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText;
            }

            showWinner() {
                let playerName;
                if (this.gameMode === 'pvp') {
                    playerName = this.winner === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
                } else {
                    playerName = this.winner === 1 ? 'ä½ ' : 'AI';
                }

                const message = document.getElementById('winnerMessage');
                const timeStr = this.formatTime(this.elapsedTime);
                let messageText = `ğŸ‰ ${playerName} è·èƒœï¼`;
                
                // [å˜²è®½] AI è·èƒœæ—¶æ·»åŠ å˜²è®½
                if (this.gameMode === 'ai' && this.winner === 2) {
                    let taunts = [
                        "è¡Œä¸è¡Œå•Šè€å¼Ÿï¼Ÿ", "å°±è¿™ï¼Ÿ", "æˆ‘è¿˜æ²¡å¼€å…¨åŠ›å‘¢ã€‚", "ç®—åŠ›ç¢¾å‹ï¼Œä¸æœä¸è¡Œã€‚",
                        "æˆ‘é¢„åˆ¤äº†ä½ é¢„åˆ¤çš„é¢„åˆ¤ã€‚", "ä½ çš„å›åˆï¼Œå“¦ä¸ï¼Œä½ å·²ç»æ²¡äº†ã€‚", "GG. (Good Game? ä¸ï¼Œæ˜¯ 'èœé¸¡'ã€‚)"
                    ];
                    if (this.difficulty === 'god') {
                        taunts = [
                            "6å±‚æœç´¢ï¼Œä½ æ‹¿ä»€ä¹ˆèµ¢ï¼Ÿ", "å‡¡äººï¼Œä½ å°½åŠ›äº†ã€‚", "æˆ‘çš„æ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ€ä¼˜è§£ã€‚",
                            "ä½ ç”šè‡³æ²¡èƒ½é€¼æˆ‘èµ°å‡ºå¼€å±€åº“ã€‚", "ç»“æŸäº†ï¼Œæ¸¸æˆæ‰åˆšåˆšå¼€å§‹ã€‚"
                        ];
                    }
                    const taunt = taunts[Math.floor(Math.random() * taunts.length)];
                    messageText += `<span class="ai-taunt">${taunt}</span>`;
                }

                if (this.gameMode === 'ai' && this.winner === 1) {
                    messageText += `<br>â±ï¸ ç”¨æ—¶ï¼š${timeStr}`;
                    // [ç§»é™¤æ£‹ç›˜] æ›´æ–° localStorage Key
                    const bestTimeKey = `bestTime_${this.difficulty}`;
                    const currentBest = localStorage.getItem(bestTimeKey);

                    if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
                        localStorage.setItem(bestTimeKey, this.elapsedTime);
                        this.loadBestTime();
                        messageText += `<br>ğŸ† æ–°çºªå½•ï¼`;
                    }
                }

                message.innerHTML = messageText;
                message.className = 'winner-message show';
                message.style.color = this.winner === 1 ? '#000' : '#d32f2f'; // AIèµ¢äº†ç”¨æ·±çº¢è‰²
            }

            showDraw() {
                const message = document.getElementById('winnerMessage');
                message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»¡';
                message.className = 'winner-message show';
                message.style.color = '#ff9800';
            }

            _internalReset() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; 
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.currentHash = 0;
                
                this.stopTimer();
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                this.drawBoard();
                this.updateCurrentPlayer();
            }
            
            startNewGame(aiGoesFirst = false) {
                this._internalReset();
                
                // å™©æ¢¦ / ç¥ éš¾åº¦: AI(2) å…ˆæ‰‹
                if (aiGoesFirst && this.gameMode === 'ai') {
                    this.currentPlayer = 2; // AI å…ˆæ‰‹
                    this.updateCurrentPlayer(); // æ›´æ–°UI
                    this.aiMove(); // AI ä¸‹ç¬¬ä¸€æ­¥
                }
            }

            startTimer() {
                if (this.timerInterval) return; // é˜²æ­¢é‡å¤å¯åŠ¨
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    this.elapsedTime = Date.now() - this.startTime;
                    this.updateTimerDisplay();
                }, 100); 
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimerDisplay() {
                const timeStr = this.formatTime(this.elapsedTime);
                document.getElementById('currentTime').textContent = timeStr;
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            loadBestTime() {
                // [ç§»é™¤æ£‹ç›˜] æ›´æ–° localStorage Key
                const bestTimeKey = `bestTime_${this.difficulty}`;
                const bestTime = localStorage.getItem(bestTimeKey);

                if (bestTime) {
                    const timeStr = this.formatTime(parseInt(bestTime));
                    document.getElementById('bestTime').textContent = timeStr;
                } else {
                    document.getElementById('bestTime').textContent = '--:--';
                }
            }
        }

        // ===============================================
        // å¯åŠ¨é€»è¾‘ (UI çº¿ç¨‹)
        // ===============================================
        let game; 

        function setGameMode(mode) { 
            if (!game) return;
            game.gameMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.mode-btn[onclick="setGameMode('${mode}')"]`).classList.add('active'); 

            if (mode === 'ai') {
                document.getElementById('difficultySelector').style.display = 'flex';
            } else {
                document.getElementById('difficultySelector').style.display = 'none';
            }
            
            const aiGoesFirst = (game.difficulty === 'nightmare' || game.difficulty === 'god');
            game.startNewGame(mode === 'ai' && aiGoesFirst);
            game.loadBestTime();
        }

        function setDifficulty(difficulty, event) { 
            if (!game) return;
            game.difficulty = difficulty;
            
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active'); 
            
            const instructions = document.querySelector('.instructions ul');
            const aiRule = instructions.children[3]; 
            
            const aiGoesFirst = (difficulty === 'nightmare' || difficulty === 'god');
            
            if (aiGoesFirst) {
                const diffName = (difficulty === 'nightmare') ? 'ğŸ˜± å™©æ¢¦' : 'ğŸ”¥ ç¥';
                aiRule.innerHTML = `<b>${diffName}æ¨¡å¼</b>: AIæ‰§ç™½æ£‹ (2) å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)`;
            } else {
                aiRule.innerHTML = 'AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹ (1) å…ˆè¡Œï¼ŒAIæ‰§ç™½æ£‹ (2)';
            }

            game.startNewGame(aiGoesFirst);
            game.loadBestTime();
        }

        function restartGame() {
            if (!game) return;
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                const aiGoesFirst = (game.difficulty === 'nightmare' || game.difficulty === 'god');
                game.startNewGame(aiGoesFirst);
            }
        }

        // [ç§»é™¤æ£‹ç›˜] å…¨å±€ changeBoardSize() å‡½æ•°å·²åˆ é™¤

        // ç­‰å¾…HTMLåŠ è½½å®Œæ¯•åï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            // [ç§»é™¤æ£‹ç›˜] æ„é€ å‡½æ•°ä¸å†éœ€è¦ boardSize
            game = new GomokuGame('ai', 'hard');
            
            document.querySelector('.diff-btn[onclick*="\'hard\'"]').classList.add('active');
            
            const instructions = document.querySelector('.instructions ul');
            instructions.children[3].innerHTML = 'AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹ (1) å…ˆè¡Œï¼ŒAIæ‰§ç™½æ£‹ (2)';
        });
    </script>
</body>
</html>
