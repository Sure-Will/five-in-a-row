<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹æ¸¸æˆ - æŒ‘æˆ˜ç¡•ç¥</title>
    <style>
        /* CSS æ ·å¼ä¸ä¸Šä¸€ç‰ˆç›¸åŒ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 20px;
        }
        .container {
            background: white; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px; max-width: 850px; width: 100%;
        }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 1.1em; }
        .difficulty-selector { display: flex; justify-content: center; margin-bottom: 20px; align-items: center; }
        .diff-label { font-weight: bold; margin-right: 10px; font-size: 1.1em;}
        .god-mode-active {
             padding: 10px 20px; font-size: 1.1em; border-radius: 10px;
             background: #f44336; color: white; font-weight: bold;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .game-info {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px;
        }
        .current-player { font-size: 1.3em; font-weight: bold; color: #333; }
        #playerTimeLeft { font-size: 0.8em; color: #f44336; margin-left: 8px; font-weight: normal; }
        .player-black { color: #000; }
        .player-white { color: #666; }
        .controls { display: flex; gap: 10px; }
        button {
            padding: 10px 20px; font-size: 1em; border: none; border-radius: 8px;
            cursor: pointer; transition: all 0.3s; font-weight: bold;
        }
        .btn-restart { background: #4caf50; color: white; }
        .btn-restart:hover { background: #45a049; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .board-container { display: flex; justify-content: center; margin: 20px 0; }
        #gameBoard {
            background: #daa520; border: 3px solid #8b6914;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); cursor: pointer;
            max-width: 100%; height: auto;
        }
        .winner-message {
            text-align: center; font-size: 1.5em; font-weight: bold; color: #4caf50;
            margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 10px; display: none;
        }
        .winner-message.show { display: block; animation: slideDown 0.5s ease; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .instructions { background: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; }
        .instructions h3 { color: #1976d2; margin-bottom: 10px; }
        .instructions ul { list-style-position: inside; color: #333; line-height: 1.8; }
        .ai-thinking { text-align: center; font-size: 1.1em; color: #ff9800; margin: 10px 0; font-weight: bold; }
        .step-taunt { display: block; font-size: 0.9em; color: #e91e63; margin-top: 5px; }
        .timer-container {
            display: flex; justify-content: center; align-items: center; gap: 20px;
            margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px; color: white;
        }
        .timer-item { text-align: center; }
        .timer-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
        .timer-value { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
        .best-time { color: #ffd700; }
        .ai-taunt { font-size: 0.8em; color: #f44336; font-weight: bold; display: block; margin-top: 10px; }
        @media (max-width: 600px) {
            .container { padding: 15px; } h1 { font-size: 1.8em; }
            .game-info { flex-direction: column; gap: 10px; }
            .controls { flex-wrap: wrap; justify-content: center; }
            .timer-container { flex-direction: column; gap: 10px; } .timer-value { font-size: 1.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® äº”å­æ£‹</h1>
        <p class="subtitle">Gomoku / Five in a Row (15x15)</p>

         <div class="difficulty-selector">
            <span class="diff-label">å½“å‰æ¨¡å¼ï¼š</span>
            <span class="god-mode-active">ğŸ”¥ ç¡•ç¥æ¨¡å¼</span>
        </div>


        <div class="game-info">
            <div class="current-player" id="currentPlayer">
                å½“å‰ç©å®¶ï¼š<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>
                <span id="playerTimeLeft"></span>
            </div>
            <div class="controls">
                <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
        </div>

        <div class="ai-thinking" id="aiThinking" style="display: none;">ğŸ¤– AIæ€è€ƒä¸­...</div>

        <div class="timer-container">
            <div class="timer-item">
                <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
                <div class="timer-value" id="currentTime">00:00</div>
            </div>
            <div class="timer-item">
                <div class="timer-label">ğŸ† æœ€ä½³è®°å½• (ç¡•ç¥æ¨¡å¼)</div>
                <div class="timer-value best-time" id="bestTime">--:--</div>
            </div>
        </div>

        <div class="winner-message" id="winnerMessage"></div>

        <div class="board-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="instructions">
            <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
            <ul id="rules-list">
                {/* Rules will be added by JS */}
            </ul>
        </div>
    </div>
    
    <script id="ai-worker-script" type="text/worker-script">
        
        // --- Worker å†…çš„å…¨å±€å˜é‡ ---
        let board, boardSize, maxDepth; 
        let zobristTable, currentHash, moveHistory;
        let transpositionTable = new Map();
        
        const TIMEOUT_MS = 10000; // 10 ç§’ AI ç†”æ–­

        // [å¼€å±€åº“.1] å®šä¹‰å¼€å±€åº“ (Map: hash -> move)
        const openingBook = new Map();
        // !!! è­¦å‘Šï¼šä¸‹é¢çš„ hash å€¼æ˜¯å ä½ç¬¦ï¼Œå¿…é¡»æ›¿æ¢ä¸ºçœŸå®è®¡ç®—å€¼ !!!
        // æ ¼å¼: openingBook.set(å±€é¢å“ˆå¸Œå€¼, { row: AIåº”èµ°è¡Œ, col: AIåº”èµ°åˆ— });
        // --- AI ç™½æ£‹ (2) å…ˆæ‰‹ ---
        // å±€é¢ 1: AI (7,7) -> ç©å®¶ (6,6) [ç©å®¶æ–œ]
        const hash_p1_6_6 = 123456789012345; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_6_6, { row: 6, col: 7 }); // AI å›åº” (6,7) [AIç›´] (æ°´æœˆ)
        // å±€é¢ 2: AI (7,7) -> ç©å®¶ (7,6) [ç©å®¶ç›´]
        const hash_p1_7_6 = 234567890123456; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_7_6, { row: 6, col: 6 }); // AI å›åº” (6,6) [AIæ–œ] (èŠ±æœˆ)
         // å±€é¢ 3: AI (7,7) -> ç©å®¶ (8,8) [ç©å®¶æ–œ]
        const hash_p1_8_8 = 345678901234567; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_8_8, { row: 8, col: 7 }); // AI å›åº” (8,7) [AIç›´] (æ°´æœˆ)
         // å±€é¢ 4: AI (7,7) -> ç©å®¶ (6,7) [ç©å®¶ç›´]
        const hash_p1_6_7 = 456789012345678; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_6_7, { row: 6, col: 6 }); // AI å›åº” (6,6) [AIæ–œ] (èŠ±æœˆ)
        // --- æ›´å¤šå®šå¼å¯ä»¥ç»§ç»­æ·»åŠ  ---
        // å±€é¢ 5: AI(7,7)->P(6,6)->AI(6,7)->P(7,6)
        const hash_p1_66_ai_67_p1_76 = 567890123456789; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_66_ai_67_p1_76, { row: 5, col: 7 }); // AI ç¬¬ 3 æ­¥ç¤ºä¾‹
        // å±€é¢ 6: AI(7,7)->P(7,6)->AI(6,6)->P(6,7)
        const hash_p1_76_ai_66_p1_67 = 678901234567890; // <-- æ›¿æ¢!
        openingBook.set(hash_p1_76_ai_66_p1_67, { row: 5, col: 5 }); // AI ç¬¬ 3 æ­¥ç¤ºä¾‹

        // --- æ ¸å¿ƒå…¥å£ï¼šæ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯ ---
        self.onmessage = function(e) {
            const data = e.data;
            
            // 1. æ›´æ–° Worker çš„å†…éƒ¨çŠ¶æ€
            board = data.board;
            boardSize = data.boardSize;
            maxDepth = data.maxDepth; // ç¡•ç¥(6)
            zobristTable = data.zobristTable;
            currentHash = data.currentHash;
            moveHistory = data.moveHistory;
            
            // 2. æ¯æ¬¡ AI æ€è€ƒæ—¶ï¼Œéƒ½é‡ç½®ç½®æ¢è¡¨
            transpositionTable.clear();
            
            const startTime = performance.now();
            let moveResult = {}; 
            
            // 3. è°ƒç”¨ AI æ ¸å¿ƒé€»è¾‘ (åŒ…å«å¼€å±€åº“å’Œå¼ºåˆ¶ç»ˆç»“æ£€æŸ¥)
            moveResult = getBestMoveIDDFS(startTime, maxDepth); 
            
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // 4. å°†ç»“æœå‘å›ä¸»çº¿ç¨‹
            self.postMessage({ 
                move: moveResult.move, 
                duration: duration, 
                depth: moveResult.depth // åŒ…å«å®é™…å®Œæˆçš„æ·±åº¦
            });
        };
        
        // --- AI ç®—æ³• ---
        
        function getHardMove() { // ä½œä¸º IDDFS è¶…æ—¶æˆ–å¼€å±€åº“/å¼ºåˆ¶æ£€æŸ¥æœªå‘½ä¸­æ—¶çš„å¤‡ç”¨
            let bestScore = -Infinity;
            let bestMove = null;
            // (ä»£ç ä¸ä¸Šä¸€ç‰ˆ getHardMove ç›¸åŒ)
            // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
            const emptyPositions = []; // ä¿åº•éšæœºèµ°æ³•
            for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) emptyPositions.push({ row: i, col: j }); } }
            return bestMove || (emptyPositions.length > 0 ? emptyPositions[Math.floor(Math.random() * emptyPositions.length)] : null);
        }
        
        // è¿­ä»£åŠ æ·± (IDDFS) å…¥å£ - åŒ…å«å¼€å±€åº“å’Œå¼ºåˆ¶ç»ˆç»“æ£€æŸ¥
        function getBestMoveIDDFS(startTime, maxDepth) {
            
            // [å¼€å±€åº“.3] æ£€æŸ¥å¼€å±€åº“ (é™åˆ¶åœ¨ 8 æ­¥å†…)
            const bookMove = openingBook.get(currentHash);
            if (bookMove && moveHistory.length < 8) {
                console.log("Using opening book move!");
                // ç¡®ä¿åº“é‡Œçš„èµ°æ³•å½“å‰æ˜¯æœ‰æ•ˆçš„ (ä»¥é˜²ä¸‡ä¸€)
                if (board[bookMove.row][bookMove.col] === 0) {
                     return { move: bookMove, depth: 1, timedOut: false };
                } else {
                     console.warn("Opening book move is invalid, recalculating.");
                }
            }

            // [å¼ºåˆ¶ç»ˆç»“.1] æ£€æŸ¥ AI æ˜¯å¦èƒ½ä¸€æ­¥è·èƒœæˆ–éœ€è¦é˜²å®ˆ
            const validMoves = getValidMoves(false); // è·å–æ— æ’åºçš„èµ°æ³•ç”¨äºæ£€æŸ¥
            let immediateAiWinMove = null;
            let immediatePlayerBlockMove = null;

            for (const move of validMoves) {
                // æ£€æŸ¥ AI è·èƒœ
                _simulateMove(move.row, move.col, 2); // æ¨¡æ‹Ÿ AI è½å­
                if (checkWin(move.row, move.col)) {
                    immediateAiWinMove = { row: move.row, col: move.col };
                    _simulateUndo(move.row, move.col, 2); // æ’¤é”€æ¨¡æ‹Ÿ
                    break; // æ‰¾åˆ°ä¸€ä¸ªå³å¯
                }
                _simulateUndo(move.row, move.col, 2); // æ’¤é”€æ¨¡æ‹Ÿ

                // æ£€æŸ¥ç©å®¶è·èƒœ (AI éœ€è¦é˜²å®ˆ) - ä»…å½“æ²¡æ‰¾åˆ° AI å¿…èƒœæ—¶æ£€æŸ¥
                if (!immediateAiWinMove) {
                     _simulateMove(move.row, move.col, 1); // æ¨¡æ‹Ÿç©å®¶è½å­
                     if (checkWin(move.row, move.col)) {
                         immediatePlayerBlockMove = { row: move.row, col: move.col }; // AI éœ€è¦ä¸‹åœ¨è¿™é‡Œ
                         _simulateUndo(move.row, move.col, 1); // æ’¤é”€æ¨¡æ‹Ÿ
                         // ç»§ç»­æ£€æŸ¥ï¼Œçœ‹åé¢æ˜¯å¦æœ‰ AI èƒ½ç›´æ¥èµ¢çš„ (AI èµ¢ä¼˜å…ˆ)
                     } else {
                         _simulateUndo(move.row, move.col, 1); // æ’¤é”€æ¨¡æ‹Ÿ
                     }
                }
            }

            // å¦‚æœæ‰¾åˆ° AI å¿…èƒœæ£‹
            if (immediateAiWinMove) {
                 console.log("Found immediate AI win!");
                 return { move: immediateAiWinMove, depth: 1, timedOut: false };
            }
            // å¦‚æœæ‰¾åˆ°éœ€è¦ç«‹å³é˜²å®ˆçš„æ£‹
            if (immediatePlayerBlockMove) {
                 console.log("Found immediate block required!");
                 return { move: immediatePlayerBlockMove, depth: 1, timedOut: false };
            }

            // --- å¦‚æœæ²¡æœ‰å¼€å±€åº“å‘½ä¸­å’Œå¼ºåˆ¶ç»ˆç»“ï¼Œåˆ™å¼€å§‹ IDDFS ---
            let bestMove = null;
            let bestScore = -Infinity;
            let completedDepth = 0;

            // è¿­ä»£åŠ æ·±: æœç´¢æ·±åº¦ 2, 4, 6, ... ç›´åˆ° maxDepth
            for (let d = 2; d <= maxDepth; d += 2) {
                
                const currentTime = performance.now();
                if ((currentTime - startTime) > TIMEOUT_MS) {
                    break; 
                }

                const result = minimax_alphabeta(d, -Infinity, +Infinity, true, startTime);

                if (result.timedOut) {
                    break; 
                }

                // åªæœ‰å½“ result.move æœ‰æ•ˆæ—¶æ‰æ›´æ–° bestMove
                if (result.move) {
                    bestMove = result.move;
                    bestScore = result.score;
                    completedDepth = d; 
                } else {
                    // å¦‚æœ minimax è¿”å›äº† null move (å¯èƒ½å‘ç”Ÿåœ¨æ ¹èŠ‚ç‚¹æ— æ³•èµ°æ£‹?)ï¼Œè·³å‡ºå¾ªç¯
                    console.warn(`Minimax returned null move at depth ${d}`);
                    break;
                }
                
                if (bestScore > 9000000) { // æ‰¾åˆ°å¿…èƒœ
                    break; 
                }
            }
            
            // å¦‚æœè¶…æ—¶æˆ–æœç´¢æœªå®Œæˆï¼Œè¿”å›ä¸Šä¸€ä¸ªæ·±åº¦çš„ç»“æœæˆ–ä¿åº•
            if (bestMove === null) {
                console.warn("IDDFS couldn't find a move (timeout likely), using hard move.");
                bestMove = getHardMove(); 
                completedDepth = completedDepth || 1; 
            }

            return { move: bestMove, score: bestScore, depth: completedDepth };
        }

        // æ ¸å¿ƒï¼šå¸¦ Alpha-Beta å‰ªæçš„ Minimax
        function minimax_alphabeta(depth, alpha, beta, isMaximizingPlayer, startTime) {
            
            const currentTime = performance.now();
            if ((currentTime - startTime) > TIMEOUT_MS) {
                return { score: 0, timedOut: true }; 
            }

            const hash = currentHash;
            const cached = transpositionTable.get(hash);
            if (cached && cached.depth >= depth) {
                return { score: cached.score, timedOut: false };
            }

            if (depth === 0) {
                const score = evaluateBoardHeuristic();
                return { score: score, timedOut: false };
            }

            const validMoves = getValidMoves(true); // true = å¸¦æ’åº

            if (validMoves.length === 0) {
                return { score: 0, timedOut: false }; // å¹³å±€
            }

            let bestMove = null;
            let timedOut = false;

            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                bestMove = validMoves[0]; // åˆå§‹å‡è®¾ç¬¬ä¸€ä¸ªæ˜¯æœ€å¥½çš„

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 2); // AI (2)
                    let score;
                    // [å¼ºåˆ¶ç»ˆç»“.2] æ£€æŸ¥æ¨¡æ‹Ÿåçš„å±€é¢æ˜¯å¦ AI èƒœåˆ©
                    if (checkWin(move.row, move.col)) {
                        score = 10000000 + depth; // å¿…èƒœ (10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, false, startTime);
                        if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 2);
                    
                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move; // æ›´æ–°æœ€ä½³èµ°æ³•
                    }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                // ç¡®ä¿ bestMove ä¸æ˜¯ null (å¦‚æœå¾ªç¯æ²¡æœ‰æ‰§è¡Œæˆ–æ‰€æœ‰èµ°æ³•éƒ½è¢«å‰ªæ?)
                 bestMove = bestMove || validMoves[0]; // ä¿åº•
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            
            } else { // è½®åˆ° Min (ç©å®¶)
                let bestScore = +Infinity;
                bestMove = validMoves[0]; // åˆå§‹å‡è®¾ç¬¬ä¸€ä¸ªæ˜¯æœ€å¥½çš„

                for (const move of validMoves) {
                    _simulateMove(move.row, move.col, 1); // ç©å®¶ (1)
                    let score;
                     // [å¼ºåˆ¶ç»ˆç»“.3] æ£€æŸ¥æ¨¡æ‹Ÿåçš„å±€é¢æ˜¯å¦ç©å®¶èƒœåˆ©
                    if (checkWin(move.row, move.col)) {
                        score = -10000000 - depth; // å¿…è´¥ (-10M)
                    } else {
                        const result = minimax_alphabeta(depth - 1, alpha, beta, true, startTime);
                         if (result.timedOut) {
                            timedOut = true;
                            score = 0; // è¿™ä¸ªåˆ†æ•°æ— æ•ˆ
                        } else {
                            score = result.score;
                        }
                    }
                    _simulateUndo(move.row, move.col, 1);

                    if (timedOut) return { score: 0, timedOut: true }; // ä¼ æ’­è¶…æ—¶

                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move; // æ›´æ–°æœ€ä½³èµ°æ³• (å¯¹ Min æ¥è¯´æ˜¯åˆ†æ•°æœ€ä½çš„)
                    }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // å‰ªæ
                    }
                }
                 // ç¡®ä¿ bestMove ä¸æ˜¯ null
                bestMove = bestMove || validMoves[0]; // ä¿åº•
                transpositionTable.set(hash, { depth: depth, score: bestScore });
                return { score: bestScore, move: bestMove, timedOut: false };
            }
        }

        // æ¨¡æ‹Ÿè½å­
        function _simulateMove(row, col, player) {
            board[row][col] = player;
            currentHash ^= zobristTable[row][col][player - 1];
        }
        // æ¨¡æ‹Ÿæ‚”æ£‹
        function _simulateUndo(row, col, player) {
            board[row][col] = 0;
            currentHash ^= zobristTable[row][col][player - 1];
        }

        // è·å–æœ‰æ•ˆèµ°æ³• (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
        function getValidMoves(withOrdering = false) {
             // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
             const moveSet = new Set();
             const center = Math.floor(boardSize / 2);
             if (moveHistory.length === 0) return [{ row: center, col: center }];
             if (moveHistory.length === 1) { // ç©å®¶ç¬¬ä¸€æ­¥
                 const moves = [];
                 for(let dr = -1; dr <= 1; dr++) { for(let dc = -1; dc <=1; dc++) {
                      if (dr === 0 && dc === 0) continue;
                      const r = center + dr; const c = center + dc;
                      if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === 0) moves.push({row: r, col: c});
                 }} return moves;
             }
             const radius = 2; // æ­£å¸¸æœç´¢
             for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) {
                 if (board[r][c] === 0) continue; 
                 for (let dr = -radius; dr <= radius; dr++) { for (let dc = -radius; dc <= radius; dc++) {
                     if (dr === 0 && dc === 0) continue;
                     const nr = r + dr; const nc = c + dc;
                     if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc] === 0) moveSet.add(`${nr},${nc}`);
                 }}
             }}
             if (moveSet.size === 0) { // ä¿åº•ï¼šè¿”å›æ‰€æœ‰ç©ºç‚¹
                  for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { if (board[r][c] === 0) moveSet.add(`${r},${c}`); }}
             }
             const moves = Array.from(moveSet).map(s => { const [row, col] = s.split(',').map(Number); return { row, col }; });
             if (withOrdering) { // æ’åº
                 const scoredMoves = moves.map(move => ({ move, score: evaluatePositionAdvanced(move.row, move.col) }));
                 scoredMoves.sort((a, b) => b.score - a.score); return scoredMoves.map(item => item.move);
             } return moves;
        }

        // é™æ€æ£‹ç›˜è¯„ä¼° (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
        function evaluateBoardHeuristic() {
             // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
             let totalScore = 0; const validMoves = getValidMoves(false);
             for (const move of validMoves) { totalScore += evaluatePositionAdvanced(move.row, move.col); }
             return totalScore;
        }

        // è¯„ä¼°ç©ºç‚¹ä»·å€¼ (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
        function evaluatePositionAdvanced(row, col) {
            // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
            let score = 0; const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let [dr, dc] of directions) {
                const aiScore = evaluateLine(row, col, dr, dc, 2); const playerScore = evaluateLine(row, col, dr, dc, 1);
                score += aiScore + (playerScore * 1.1);
            }
            const center = Math.floor(boardSize / 2); const distToCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (boardSize - distToCenter) * 0.5; return score;
        }

        // è¯„ä¼°è¿ç æƒ…å†µ (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
        function evaluateLine(row, col, dr, dc, player) {
             // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
             let count = 0; let blocks = 0;
             for (let i = 1; i <= 4; i++) { // æ­£å‘
                 const r = row + dr * i; const c = col + dc * i;
                 if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                 if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
             }
             for (let i = 1; i <= 4; i++) { // åå‘
                 const r = row - dr * i; const c = col - dc * i;
                 if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) { blocks++; break; }
                 if (board[r][c] === player) { count++; } else if (board[r][c] === 0) { break; } else { blocks++; break; }
             }
             if (count >= 4) return 10000000; if (count === 3 && blocks === 0) return 1000000;
             if (count === 2 && blocks === 0) return 50000; if (count === 3 && blocks === 1) return 10000;
             if (count === 2 && blocks === 1) return 500; if (count === 1 && blocks === 0) return 100;
             if (count === 1 && blocks === 1) return 10; return 0;
        }

        // æ£€æŸ¥èƒœåˆ© (ä»£ç ä¸ä¸Šä¸€ç‰ˆç›¸åŒ)
        function checkWin(row, col) {
             // ... (çœç•¥ä»¥å‡å°‘ç¯‡å¹…) ...
             const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ]; const player = board[row][col]; if (player === 0) return false;
             for (let [dr, dc] of directions) {
                 let count = 1; let r = row + dr, c = col + dc;
                 while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r += dr; c += dc; }
                 r = row - dr; c = col - dc;
                 while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) { count++; r -= dr; c -= dc; }
                 if (count >= 5) return true;
             } return false;
        }

    </script>
    
    <script>
        class GomokuGame {
            constructor() { 
                this.boardSize = 15; // å›ºå®šä¸º 15
                
                const maxCanvasWidth = 500;
                this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                // [AIç¬æ—¶å¼€å±€] åˆå§‹ currentPlayer è®¾ä¸º 2 (AI)ï¼Œä½† UI ä¸Šä¼šæ˜¾ç¤ºç©å®¶
                this.currentPlayer = 2; 
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.gameMode = 'ai'; // å›ºå®šä¸º AI
                this.difficulty = 'god'; // å›ºå®šä¸º god
                
                // è®¡æ—¶å™¨ç›¸å…³
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;
                
                this.playerTimerId = null;
                this.playerTimeLeft = 10; // ç§’

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                // AI æ ¸å¿ƒ
                this.GOD_DEPTH = 6;       // ç¥(6)
                this.zobristTable = [];
                this.currentHash = 0;
                this.initZobrist();
                
                // åˆå§‹åŒ– Web Worker
                try {
                    const workerScript = document.getElementById('ai-worker-script').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    this.aiWorker = new Worker(URL.createObjectURL(blob));
                    
                    this.aiWorker.onmessage = (e) => {
                        this.receiveAiMove(e.data);
                    };
                } catch (error) {
                    console.error("æ— æ³•åˆ›å»º AI Worker: ", error);
                    alert("åŠ è½½AIçº¿ç¨‹å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§æˆ–åˆ·æ–°é¡µé¢ã€‚");
                }


                this.initCanvas();
                this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
                this.setupEventListeners();
                this.loadBestTime();
                
                // [AIç¬æ—¶å¼€å±€.1] å»¶è¿Ÿæ‰§è¡Œ AI çš„ç¬¬ä¸€æ­¥ï¼Œç¡®ä¿ UI å…ˆæ¸²æŸ“
                 // å¹¶ç¡®ä¿åœ¨ DOMContentLoaded ä¹‹åæ‰§è¡Œ
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.performAiFirstMove());
                } else {
                    setTimeout(() => { this.performAiFirstMove(); }, 0); 
                }
            }
            
            // [AIç¬æ—¶å¼€å±€.2] AI ç¬¬ä¸€æ­¥é€»è¾‘
            performAiFirstMove() {
                // ç¡®ä¿åªåœ¨æ¸¸æˆå¼€å§‹æ—¶æ‰§è¡Œä¸€æ¬¡
                if (this.moveHistory.length === 0 && !this.gameOver) {
                    const center = Math.floor(this.boardSize / 2);
                    if (this.board[center][center] === 0) {
                        
                        console.log("AI performs instant first move.");
                        
                        // ç›´æ¥ä¿®æ”¹çŠ¶æ€ï¼Œä¸é€šè¿‡ makeMove 
                        this.board[center][center] = 2; // AI (ç™½æ£‹) è½å­
                        this.moveHistory.push({ row: center, col: center, player: 2 });
                        this.currentHash ^= this.zobristTable[center][center][1]; // æ›´æ–°å“ˆå¸Œ
                        this.currentPlayer = 1; // è½®åˆ°ç©å®¶
                        
                        this.drawBoard(); // é‡ç»˜æ£‹ç›˜
                        this.updateCurrentPlayer(); // æ›´æ–°UIæ˜¾ç¤ºè½®åˆ°ç©å®¶ (æ­¤æ—¶è¿˜ä¸è®¡æ—¶)
                    }
                }
            }

            
            // åˆå§‹åŒ– Zobrist å“ˆå¸Œè¡¨ (ä¸»çº¿ç¨‹)
            initZobrist() {
                this.zobristTable = Array(this.boardSize).fill(null).map(() => 
                    Array(this.boardSize).fill(null).map(() => 
                        Array(2).fill(null) // 2ä¸ªç©å®¶
                    )
                );
                
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        for (let k = 0; k < 2; k++) {
                            this.zobristTable[i][j][k] = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        }
                    }
                }
                this.currentHash = 0;
            }


            initCanvas() {
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
            }

            drawBoard() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const boardSize = this.boardSize;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#daa520';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < boardSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
                    ctx.stroke();
                }

                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½ (15x15)
                const drawDot = (x, y) => {
                    ctx.beginPath();
                    ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                };
                
                drawDot(3, 3); drawDot(11, 3); drawDot(3, 11);
                drawDot(11, 11); drawDot(7, 7); 

                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }
                
                // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    if (lastMove.player === 2) {
                        this.highlightLastMove(lastMove.row, lastMove.col);
                    }
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                if (player === 1) { // ç©å®¶é»‘æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else { // AI ç™½æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                }
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            highlightLastMove(row, col) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.15; 
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; 
                ctx.fill();
            }

            setupEventListeners() {
                if (this.clickHandler) {
                    this.canvas.removeEventListener('click', this.clickHandler);
                }
                this.clickHandler = (e) => {
                    if (this.gameOver) return;
                    if (this.currentPlayer === 2) return; // AI å›åˆä¸èƒ½ç‚¹
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const col = Math.round(canvasX / this.cellSize) - 1;
                    const row = Math.round(canvasY / this.cellSize) - 1;
                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                };
                this.canvas.addEventListener('click', this.clickHandler);
            }

            isValidMove(row, col) {
                if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
                    return false;
                }
                return this.board[row][col] === 0;
            }

            // ç©å®¶æˆ–AIçš„ *çœŸå®* è½å­
            makeMove(row, col) {
                // ç©å®¶è½å­ï¼Œåœæ­¢è®¡æ—¶
                if (!this.gameOver && this.currentPlayer === 1) {
                   this.stopPlayerTimer();
                }
                
                // æ¸¸æˆæ€»è®¡æ—¶åœ¨ç©å®¶ä¸‹ç¬¬ä¸€æ­¥åå¼€å§‹ (moveHistory ä» 0 (AI) -> 1 (ç©å®¶) æ—¶)
                if (this.moveHistory.length === 1) { // AI å·²èµ°ä¸€æ­¥ï¼Œè¿™æ˜¯ç©å®¶ç¬¬ä¸€æ­¥
                    this.startTimer(); // æ¸¸æˆæ€»è®¡æ—¶å¼€å§‹
                }

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.currentHash ^= this.zobristTable[row][col][this.currentPlayer - 1];
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showWinner();
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.stopTimer(); 
                    this.stopPlayerTimer(); 
                    this.showDraw();
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    
                    // è½®åˆ° AI
                    if (this.currentPlayer === 2) {
                         // AI ä¸‹æ£‹å‰å…ˆæ›´æ–° UIï¼Œæ˜¾ç¤ºè½®åˆ° AI
                         this.updateCurrentPlayer();
                         this.aiMove();
                    } 
                    // è½®åˆ°ç©å®¶
                    else {
                        // åªæœ‰åœ¨ç©å®¶ä¸‹äº†ç¬¬ä¸€æ­¥æ£‹ä¹‹å (å³ history >= 2) æ‰å¯åŠ¨è®¡æ—¶å™¨
                        if (this.moveHistory.length >= 2) {
                            this.startPlayerTimer();
                        } else {
                            // ç©å®¶ç¬¬ä¸€æ­¥åï¼Œä¸å¯åŠ¨è®¡æ—¶å™¨ï¼Œä½†éœ€è¦æ›´æ–° UI
                            this.updateCurrentPlayer(); 
                        }
                    }
                }
            }
            
            // aiMove äº¤ç»™ Web Worker
            aiMove() {
                 if (this.gameOver) return; // é˜²æ­¢æ¸¸æˆç»“æŸå AI ä»ç„¶æ€è€ƒ

                const aiThinkingEl = document.getElementById('aiThinking');
                 // å›ºå®šä¸ºç¡•ç¥æ¨¡å¼çš„æç¤º
                let thinkingText = `ğŸ”¥ ç¡•ç¥æ€è€ƒä¸­... (è¿­ä»£è‡³D:${this.GOD_DEPTH}, 10sç†”æ–­)`;
                
                aiThinkingEl.innerHTML = thinkingText;
                aiThinkingEl.style.display = 'block';

                // å°†å½“å‰çŠ¶æ€å‘ç»™ Worker çº¿ç¨‹
                this.aiWorker.postMessage({
                    board: this.board,
                    boardSize: this.boardSize,
                    difficulty: 'god', // å›ºå®šä¸º god
                    maxDepth: this.GOD_DEPTH, // ä¼ é€’æœ€å¤§æ·±åº¦
                    zobristTable: this.zobristTable,
                    currentHash: this.currentHash,
                    moveHistory: this.moveHistory
                });
            }
            
            // æ¥æ”¶ Worker çš„è®¡ç®—ç»“æœ
            receiveAiMove(moveData) {
                const { move, duration, depth } = moveData; 
                
                // å¦‚æœæ¸¸æˆå·²ç»ç»“æŸäº†ï¼ˆæ¯”å¦‚ç©å®¶åœ¨AIæ€è€ƒæ—¶åˆ·æ–°æˆ–é‡å¼€ï¼‰ï¼Œåˆ™ä¸å¤„ç†AIç»“æœ
                if (this.gameOver) {
                    console.log("Game over, ignoring AI move.");
                    return;
                }
                
                const aiThinkingEl = document.getElementById('aiThinking');
                
                let depthStr = (depth > 1) ? `(D:${depth})` : ''; 
                let durationText = `(ç”¨æ—¶ ${duration}s)`;
                // TIMEOUT_MS åœ¨ Worker ä¸­å®šä¹‰ï¼Œè¿™é‡Œç”¨å­—é¢é‡
                if (parseFloat(duration) >= 10.0) { 
                    durationText = `(è¶…æ—¶ ${duration}s, è¿”å›D:${depth}ç»“æœ)`;
                }
                
                // [å˜²è®½] å‡†å¤‡å˜²è®½è¯­å½•
                const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
                const target = targets[Math.floor(Math.random() * targets.length)];
                let stepTaunts = [ // ç¡•ç¥ä¸“å±å˜²è®½
                    `ç¥ä¹‹ä¸€æ‰‹ã€‚åˆ°ä½ äº†, ${target}ã€‚`,
                    `ä½ è¿˜æœ‰ ${10 - Math.ceil(parseFloat(duration))} ç§’æ¥æ£æ‘©åœ£æ„, ${target}ã€‚`,
                    `${target}, ä½ å·²ç»è¾“äº†, åªæ˜¯è¿˜æ²¡æ„è¯†åˆ°ã€‚`,
                    `å®Œç¾çš„é˜²å®ˆï¼Œæ— æ‡ˆå¯å‡»çš„è¿›æ”»ã€‚é¢¤æŠ–å§, ${target}ï¼`,
                    `æˆ‘çœ‹åˆ°äº† ${depth} å±‚ä¹‹åçš„ä¸–ç•Œ, ${target}, ä½ å‘¢ï¼Ÿ`,
                    `æ”¾å¼ƒå§, ${target}, èƒœè´Ÿå·²å®šã€‚`,
                    `å¼±å°çš„äººç±»${target}, ä½ çš„ç­–ç•¥æ¼æ´ç™¾å‡ºã€‚`,
                    `æ˜¯ä¸æ˜¯å¾ˆç»æœ›å•Š, ${target}ï¼Ÿ`
                ];
                const stepTaunt = stepTaunts[Math.floor(Math.random() * stepTaunts.length)];
                
                // æ˜¾ç¤ºä¿¡æ¯ + å˜²è®½
                aiThinkingEl.innerHTML = `âœ… AIè½å­ ${depthStr} ${durationText} <span class="step-taunt">${stepTaunt}</span>`; 
                
                if (move) {
                    // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œå¹¶ä¸”å½“å‰å¿…é¡»è½®åˆ° AI (player 2)
                    if (!this.gameOver && this.currentPlayer === 2 && this.isValidMove(move.row, move.col)) {
                        this.makeMove(move.row, move.col);
                    } else if (!this.gameOver && this.currentPlayer === 2) {
                         console.error("AI Worker è¿”å›äº†ä¸€ä¸ªæ— æ•ˆèµ°æ³•: ", move);
                         const randomMove = this.getRandomMoveForMainThread();
                         if(randomMove) this.makeMove(randomMove.row, randomMove.col);
                    } else {
                         console.log("Ignoring AI move received after turn changed or game ended.");
                    }
                } else {
                    aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ? (AIæ— æ£‹å¯èµ°)';
                }
            }

            // ä¸»çº¿ç¨‹çš„ä¿åº•éšæœºèµ°æ³• (ç”¨äºç©å®¶è¶…æ—¶)
            getRandomMoveForMainThread() {
                 const emptyPositions = [];
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            emptyPositions.push({ row: i, col: j });
                        }
                    }
                }
                if (emptyPositions.length > 0) {
                    return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
                return null;
            }

            // ä¸»çº¿ç¨‹ä»ç„¶éœ€è¦ checkWin (ç”¨äºç©å®¶)
            checkWin(row, col) {
                const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
                const player = this.board[row][col];
                if (player === 0) return false;

                for (let [dr, dc] of directions) {
                    let count = 1;
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r += dr; c += dc;
                    }
                    r = row - dr; c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++; r -= dr; c -= dc;
                    }
                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            isBoardFull() {
                for (let row of this.board) {
                    if (row.includes(0)) {
                        return false;
                    }
                }
                return true;
            }

            updateCurrentPlayer() {
                let playerText;
                // åªæœ‰ AI æ¨¡å¼
                playerText = this.currentPlayer === 1
                    ? '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>'
                    : '<span class="player-white">â—‹ AIï¼ˆç™½æ£‹ï¼‰</span>';
                
                // æ›´æ–° UI (é™„åŠ è®¡æ—¶å™¨)
                const playerTimerSpan = document.getElementById('playerTimeLeft');
                 // åªæœ‰å½“è®¡æ—¶å™¨IDå­˜åœ¨æ—¶(è¡¨ç¤ºè®¡æ—¶å™¨æ­£åœ¨è¿è¡Œ)æ‰æ˜¾ç¤ºæ—¶é—´
                if (this.playerTimerId !== null && this.currentPlayer === 1 && !this.gameOver) {
                    playerTimerSpan.textContent = `(${this.playerTimeLeft}s)`;
                } else {
                    playerTimerSpan.textContent = ''; 
                }
                document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText + playerTimerSpan.outerHTML;
            }

            showWinner() {
                 // åªæœ‰ AI æ¨¡å¼
                let playerName = this.winner === 1 ? 'ä½ ' : 'ç¡•ç¥AI';

                const message = document.getElementById('winnerMessage');
                const timeStr = this.formatTime(this.elapsedTime);
                let messageText = `ğŸ‰ ${playerName} è·èƒœï¼`;
                
                // [å˜²è®½] AI è·èƒœæ—¶æ·»åŠ å˜²è®½
                if (this.winner === 2) {
                    const targets = ["å°å¼ºå¼º", "å°è¾‰è¾‰"];
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    let taunts = [ // ç¡•ç¥èƒœåˆ©å˜²è®½
                        `6å±‚æœç´¢ï¼Œ${target}ä½ æ‹¿ä»€ä¹ˆèµ¢ï¼Ÿ`, `å‡¡äºº${target}ï¼Œä½ å°½åŠ›äº†ã€‚`, `æˆ‘çš„æ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ€ä¼˜è§£ã€‚`,
                        `${target}, ä½ ç”šè‡³æ²¡èƒ½é€¼æˆ‘èµ°å‡ºå¼€å±€åº“ã€‚`, `ç»“æŸäº†, ${target}, æ¸¸æˆæ‰åˆšåˆšå¼€å§‹ã€‚`,
                        `ä¸å ªä¸€å‡»ï¼Œ${target}ã€‚`, `å›å»å†ç»ƒç»ƒå§ï¼Œ${target}ï¼`
                    ];
                    const taunt = taunts[Math.floor(Math.random() * taunts.length)];
                    messageText += `<span class="ai-taunt">${taunt}</span>`;
                }

                // ç©å®¶è·èƒœè®°å½•æ—¶é—´
                if (this.winner === 1) {
                    messageText += `<br>â±ï¸ ç”¨æ—¶ï¼š${timeStr}`;
                    const bestTimeKey = `bestTime_god`; // å›ºå®š Key
                    const currentBest = localStorage.getItem(bestTimeKey);

                    if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
                        localStorage.setItem(bestTimeKey, this.elapsedTime);
                        this.loadBestTime();
                        messageText += `<br>ğŸ† æ–°çºªå½•ï¼ä½ ç«Ÿç„¶èµ¢äº†ç¡•ç¥ï¼Ÿï¼`;
                    } else {
                        messageText += `<br>ï¼ˆè™½ç„¶èµ¢äº†ï¼Œä½†æ²¡ç ´çºªå½•å“¦ï¼‰`;
                    }
                }

                message.innerHTML = messageText;
                message.className = 'winner-message show';
                message.style.color = this.winner === 1 ? '#4caf50' : '#d32f2f'; // ç©å®¶èµ¢ç»¿è‰²ï¼ŒAIèµ¢çº¢è‰²
            }

            showDraw() {
                const message = document.getElementById('winnerMessage');
                message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»¡';
                message.className = 'winner-message show';
                message.style.color = '#ff9800';
            }
            
            // å¯åŠ¨ç©å®¶è®¡æ—¶å™¨
            startPlayerTimer() {
                // [ç©å®¶è®¡æ—¶.å¯åŠ¨é€»è¾‘ä¿®æ­£] ç¡®ä¿æ¸¸æˆæœªç»“æŸä¸”ç¡®å®è½®åˆ°ç©å®¶
                if (this.gameOver || this.currentPlayer !== 1) return; 
                
                this.stopPlayerTimer(); // å…ˆæ¸…é™¤æ—§çš„
                this.playerTimeLeft = 10;
                this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º (10s)
                
                this.playerTimerId = setInterval(() => {
                    // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢è®¡æ—¶å™¨åœ¨ä¸è¯¥è·‘çš„æ—¶å€™è·‘
                     if (this.gameOver || this.currentPlayer !== 1) {
                         this.stopPlayerTimer();
                         return;
                     }
                    
                    this.playerTimeLeft--;
                    this.updateCurrentPlayer(); // æ›´æ–°æ˜¾ç¤º
                    
                    if (this.playerTimeLeft <= 0) {
                        this.forceRandomMove();
                    }
                }, 1000); // æ¯ç§’æ‰§è¡Œ
            }
            
            // åœæ­¢ç©å®¶è®¡æ—¶å™¨
            stopPlayerTimer() {
                 if (this.playerTimerId) {
                    clearInterval(this.playerTimerId);
                    this.playerTimerId = null; // æ¸…é™¤ ID å¾ˆé‡è¦
                }
                 // æ¸…é™¤è®¡æ—¶æ˜¾ç¤º 
                 const playerTimerSpan = document.getElementById('playerTimeLeft');
                 if(playerTimerSpan) playerTimerSpan.textContent = '';
                 // ç¡®ä¿UIç«‹å³æ›´æ–°ä¸ºä¸å¸¦è®¡æ—¶å™¨çŠ¶æ€ (å¦‚æœå½“å‰æ˜¯ç©å®¶å›åˆ)
                 if (!this.gameOver && this.currentPlayer === 1) {
                     // è°ƒç”¨ updateCurrentPlayer å¯èƒ½ä¼šæ„å¤–å¯åŠ¨è®¡æ—¶å™¨ï¼Œç›´æ¥è®¾ç½®æ–‡æœ¬
                     const playerText = '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>';
                     document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText;
                 }
            }
            
            // å¼ºåˆ¶éšæœºè½å­
            forceRandomMove() {
                 this.stopPlayerTimer(); // ç¡®ä¿åœæ­¢
                 if (this.gameOver || this.currentPlayer !== 1) return; // æ¸¸æˆå·²ç»“æŸæˆ–ä¸æ˜¯ç©å®¶å›åˆ
                 
                 console.warn("ç©å®¶è¶…æ—¶ï¼Œå¼ºåˆ¶éšæœºè½å­ï¼");
                 const randomMove = this.getRandomMoveForMainThread();
                 
                 // çŸ­æš‚æç¤º
                 const aiThinkingEl = document.getElementById('aiThinking');
                 aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼å·²æ›¿ä½ éšæœºè½å­ï¼`;
                 aiThinkingEl.style.display = 'block';
                 
                 if (randomMove) {
                     // å»¶è¿Ÿä¸€ç‚¹ç‚¹æ‰§è¡Œï¼Œè®©æç¤ºèƒ½è¢«çœ‹åˆ°
                     setTimeout(() => {
                         // æ£€æŸ¥æ¸¸æˆæ˜¯å¦åœ¨å»¶è¿ŸæœŸé—´ç»“æŸäº†ï¼Œå¹¶ä¸”ç¡®è®¤ç°åœ¨æ˜¯ç©å®¶å›åˆ
                         if (!this.gameOver && this.currentPlayer === 1) {
                            // å¼ºåˆ¶è½å­ä¹Ÿç®—ä¸€æ­¥æœ‰æ•ˆæ“ä½œ
                            this.makeMove(randomMove.row, randomMove.col); 
                         }
                     }, 500);
                 } else {
                     aiThinkingEl.innerHTML = `â° æ—¶é—´åˆ°ï¼ä½†æ£‹ç›˜å·²æ»¡ï¼Ÿ`;
                 }
            }


            _internalReset() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 2; // AI å…ˆæ‰‹
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.currentHash = 0;
                
                this.stopTimer(); // åœæ­¢æ¸¸æˆæ€»è®¡æ—¶
                this.stopPlayerTimer(); // åœæ­¢ç©å®¶è®¡æ—¶
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                this.drawBoard(); // ç”»ç©ºæ£‹ç›˜
                // updateCurrentPlayer ä¼šåœ¨ startNewGame ä¸­è°ƒç”¨
            }
            
            startNewGame() { 
                this._internalReset();
                // [AIç¬æ—¶å¼€å±€.3] é‡å¼€æ¸¸æˆæ—¶ï¼Œä¹Ÿç«‹å³æ‰§è¡Œ AI ç¬¬ä¸€æ­¥
                 // ä½¿ç”¨ setTimeout ç¡®ä¿ UI æ¸²æŸ“å®Œæˆåå†æ‰§è¡Œ
                setTimeout(() => {
                     this.performAiFirstMove();
                }, 0);
            }

            startTimer() {
                if (this.timerInterval) return; // é˜²æ­¢é‡å¤å¯åŠ¨
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    // åªæœ‰æ¸¸æˆè¿›è¡Œä¸­æ‰è®¡æ—¶
                    if (!this.gameOver) {
                        this.elapsedTime = Date.now() - this.startTime;
                        this.updateTimerDisplay();
                    } else {
                        this.stopTimer(); // æ¸¸æˆç»“æŸï¼Œåœæ­¢è®¡æ—¶
                    }
                }, 100); 
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimerDisplay() {
                const timeStr = this.formatTime(this.elapsedTime);
                document.getElementById('currentTime').textContent = timeStr;
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            loadBestTime() {
                const bestTimeKey = `bestTime_god`; // å›ºå®š Key
                const bestTime = localStorage.getItem(bestTimeKey);

                if (bestTime) {
                    const timeStr = this.formatTime(parseInt(bestTime));
                    document.getElementById('bestTime').textContent = timeStr;
                } else {
                    document.getElementById('bestTime').textContent = '--:--';
                }
            }
        }

        // ===============================================
        // å¯åŠ¨é€»è¾‘ (UI çº¿ç¨‹)
        // ===============================================
        let game; 

        function restartGame() {
            if (!game) return;
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿï¼ˆç¡•ç¥AIå°†ç«‹å³åœ¨å¤©å…ƒè½å­ï¼‰')) {
                game.startNewGame(); 
            }
        }
        
        // ç­‰å¾…HTMLåŠ è½½å®Œæ¯•åï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            // ç›´æ¥åˆå§‹åŒ–ç¡•ç¥æ¨¡å¼
            game = new GomokuGame();
            
            // æ›´æ–°è§„åˆ™æ–‡æœ¬
            const rulesList = document.getElementById('rules-list'); // Get the list by ID
            // æ¸…ç©ºæ—§è§„åˆ™ (å¦‚æœå­˜åœ¨)
            while (rulesList.firstChild) {
                 rulesList.removeChild(rulesList.firstChild);
            }
            // æ·»åŠ æ–°è§„åˆ™
            const rules = [
                 'ğŸ”¥ **ç¡•ç¥æ¨¡å¼**: AIæ‰§ç™½æ£‹ (2) **ç«‹å³**åœ¨å¤©å…ƒè½å­å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)',
                 'ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­',
                 'å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼‰',
                 'ç©å®¶**ç¬¬ä¸€æ­¥å**æ¯æ­¥æ€è€ƒæ—¶é—´ä¸å¾—è¶…è¿‡10ç§’ï¼Œè¶…æ—¶å°†éšæœºè½å­',
                 'AI æ¯æ­¥æ€è€ƒæ—¶é—´ä¸Šé™10ç§’',
                 '**æ— æ‚”æ£‹**'
            ];
             rules.forEach(ruleText => {
                 const li = document.createElement('li');
                 li.innerHTML = ruleText; // ä½¿ç”¨ innerHTML æ”¯æŒåŠ ç²—
                 rulesList.appendChild(li);
             });
        });
    </script>
</body>
</html>
