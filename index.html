<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹æ¸¸æˆ - Gomoku</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 850px;
            width: 100%; /* [æ‰‹æœºé€‚é….1] ç¡®ä¿å®¹å™¨åœ¨å°å±ä¸‹å æ»¡ */
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .difficulty-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap; /* [æ‰‹æœºé€‚é….2] éš¾åº¦æŒ‰é’®æ¢è¡Œ */
        }

        .diff-btn {
            padding: 8px 16px;
            font-size: 0.95em;
            border: 2px solid #4caf50;
            background: white;
            color: #4caf50;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .diff-btn.active {
            background: #4caf50;
            color: white;
        }

        .diff-btn:hover {
            transform: translateY(-2px);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .current-player {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }

        .player-black {
            color: #000;
        }

        .player-white {
            color: #666;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-undo {
            background: #ff9800;
            color: white;
        }

        .btn-undo:hover {
            background: #f57c00;
        }

        .btn-restart {
            background: #4caf50;
            color: white;
        }

        .btn-restart:hover {
            background: #45a049;
        }

        .btn-size {
            background: #2196f3;
            color: white;
        }

        .btn-size:hover {
            background: #0b7dda;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        #gameBoard {
            background: #daa520;
            border: 3px solid #8b6914;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            
            /* [æ‰‹æœºé€‚é….3] å…³é”®ï¼šè®©canvaså“åº”å¼ç¼©æ”¾ */
            max-width: 100%;
            height: auto; 
        }

        .winner-message {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #4caf50;
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 10px;
            display: none;
        }

        .winner-message.show {
            display: block;
            animation: slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .instructions {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style-position: inside;
            color: #333;
            line-height: 1.8;
        }

        .ai-thinking {
            text-align: center;
            font-size: 1.1em;
            color: #ff9800;
            margin: 10px 0;
            font-weight: bold;
        }

        .timer-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .timer-item {
            text-align: center;
        }

        .timer-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .timer-value {
            font-size: 2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .best-time {
            color: #ffd700;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
            }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .mode-selector {
                flex-direction: column;
            }
            
            /* [æ‰‹æœºé€‚é….4] è°ƒæ•´è®¡æ—¶å™¨å¸ƒå±€ */
            .timer-container {
                flex-direction: column;
                gap: 10px;
            }
            .timer-value {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® äº”å­æ£‹</h1>
        <p class="subtitle">Gomoku / Five in a Row</p>

        <div class="mode-selector">
            <button class="mode-btn" onclick="setGameMode('pvp')">ğŸ‘¥ åŒäººå¯¹æˆ˜</button>
            <button class="mode-btn active" onclick="setGameMode('ai')">ğŸ¤– AIå¯¹æˆ˜</button>
        </div>

       <div class="difficulty-selector" id="difficultySelector" style="display: flex;">
            <span style="font-weight: bold; margin-right: 10px;">AIéš¾åº¦ï¼š</span>
            <button class="diff-btn" onclick="setDifficulty('easy', event)">ç®€å•</button>
            <button class="diff-btn" onclick="setDifficulty('medium', event)">ä¸­ç­‰</button>
            <button class="diff-btn active" onclick="setDifficulty('hard', event)">å›°éš¾</button>
            <button class="diff-btn" onclick="setDifficulty('nightmare', event)">ğŸ˜± å™©æ¢¦</button>
        </div>

        <div class="game-info">
            <div class="current-player" id="currentPlayer">
                å½“å‰ç©å®¶ï¼š<span class="player-black">â— é»‘æ£‹</span>
            </div>
            <div class="controls">
                <button class="btn-undo" id="undoBtn" onclick="undoMove()">â†©ï¸ æ‚”æ£‹</button>
                <button class="btn-restart" id="restartBtn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
                <button class="btn-size" id="sizeBtn" onclick="changeBoardSize()">ğŸ“ æ”¹å˜æ£‹ç›˜</button>
            </div>
        </div>

        <div class="ai-thinking" id="aiThinking" style="display: none;">ğŸ¤– AIæ€è€ƒä¸­...</div>

        <div class="timer-container">
            <div class="timer-item">
                <div class="timer-label">â±ï¸ ç”¨æ—¶</div>
                <div class="timer-value" id="currentTime">00:00</div>
            </div>
            <div class="timer-item">
                <div class="timer-label">ğŸ† æœ€ä½³è®°å½•</div>
                <div class="timer-value best-time" id="bestTime">--:--</div>
            </div>
        </div>

        <div class="winner-message" id="winnerMessage"></div>

        <div class="board-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="instructions">
            <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
            <ul>
                <li>é»‘æ£‹å…ˆè¡Œï¼Œç™½æ£‹åè¡Œ</li>
                <li>ç‚¹å‡»æ£‹ç›˜ç©ºç™½å¤„è½å­</li>
                <li>å…ˆå°†äº”ä¸ªæ£‹å­è¿æˆä¸€çº¿è€…è·èƒœï¼ˆæ¨ªã€ç«–ã€æ–œå‡å¯ï¼‰</li>
                <li>AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹å…ˆè¡Œ</li>
            </ul>
        </div>
    </div>

    <script>
        class GomokuGame {
            constructor(boardSize = 15, gameMode = 'pvp', difficulty = 'medium') {
                this.boardSize = boardSize;
                
                // [æ‰‹æœºé€‚é….5] ä¿®æ­£ cellSize è®¡ç®—é€»è¾‘
                // ç¡®ä¿æ£‹ç›˜åˆ†è¾¨ç‡æœ€å¤§ä¸º 500pxï¼ŒåŒæ—¶å•å…ƒæ ¼æœ€å¤§ä¸º 40px
                // (boardSize + 1) æ˜¯å› ä¸ºæ£‹ç›˜è¾¹ç¼˜éœ€è¦ç•™ç™½
                const maxCanvasWidth = 500;
                this.cellSize = Math.floor(Math.min(maxCanvasWidth / (this.boardSize + 1), 40));

                this.board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(0));
                this.currentPlayer = 1; // 1 = é»‘æ£‹/ç©å®¶, 2 = ç™½æ£‹/AI
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.gameMode = gameMode; // 'pvp' or 'ai'
                this.difficulty = difficulty; // 'easy', 'medium', 'hard', 'nightmare'

                // è®¡æ—¶å™¨ç›¸å…³
                this.startTime = null;
                this.timerInterval = null;
                this.elapsedTime = 0;

                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');

                this.initCanvas();
                this.drawBoard();
                this.setupEventListeners();
                this.loadBestTime();
            }

            initCanvas() {
                // [æ‰‹æœºé€‚é….6] æ£‹ç›˜åˆ†è¾¨ç‡ (width/height) ç”± cellSize å†³å®š
                const size = this.cellSize * (this.boardSize + 1);
                this.canvas.width = size;
                this.canvas.height = size;
            }

            drawBoard() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;
                const boardSize = this.boardSize;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#daa520';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < boardSize; i++) {
                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(cellSize * boardSize, cellSize * (i + 1));
                    ctx.stroke();

                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), cellSize * boardSize);
                    ctx.stroke();
                }

                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½
                const drawDot = (x, y) => {
                    ctx.beginPath();
                    ctx.arc(cellSize * (x + 1), cellSize * (y + 1), 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                };

                if (boardSize === 15) {
                    // æ ‡å‡†15è·¯æ£‹ç›˜çš„æ˜Ÿä½
                    drawDot(3, 3);
                    drawDot(11, 3);
                    drawDot(3, 11);
                    drawDot(11, 11);
                    drawDot(7, 7); // å¤©å…ƒ
                }

                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawPiece(i, j, this.board[i][j]);
                        }
                    }
                }
                
                // [ä¿®æ”¹ AIæ ‡æ³¨.1] ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡è®°
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    // åªæ ‡è®°AI(ç©å®¶2)çš„æ£‹
                    if (this.gameMode === 'ai' && lastMove.player === 2) {
                        this.highlightLastMove(lastMove.row, lastMove.col);
                    }
                }
            }

            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.4;

                // ç»˜åˆ¶é˜´å½±
                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();

                // ç»˜åˆ¶æ£‹å­
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                if (player === 1) {
                    // é»‘æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                } else {
                    // ç™½æ£‹
                    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                }

                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // [ä¿®æ”¹ AIæ ‡æ³¨.2] æ–°å¢ï¼šé«˜äº®AIæœ€åä¸€æ­¥çš„å‡½æ•°
            highlightLastMove(row, col) {
                const ctx = this.ctx;
                const x = this.cellSize * (col + 1);
                const y = this.cellSize * (row + 1);
                const radius = this.cellSize * 0.15; // çº¢è‰²åœ†ç‚¹çš„å¤§å°

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; // é²œçº¢è‰²
                ctx.fill();
            }

            setupEventListeners() {
                // å…ˆç§»é™¤æ—§çš„ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.clickHandler) {
                    this.canvas.removeEventListener('click', this.clickHandler);
                }

                // åˆ›å»ºæ–°çš„ç‚¹å‡»å¤„ç†å‡½æ•°
                this.clickHandler = (e) => {
                    if (this.gameOver) return;
                    if (this.gameMode === 'ai' && this.currentPlayer === 2) return; // AIå›åˆä¸å…è®¸ç©å®¶ä¸‹

                    // [æ‰‹æœºé€‚é….7] å…³é”®ï¼šå¤„ç†ç¼©æ”¾åçš„ç‚¹å‡»åæ ‡
                    const rect = this.canvas.getBoundingClientRect();
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;

                    // å°†å±å¹•åæ ‡ è½¬æ¢å› canvas å†…éƒ¨åæ ‡
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    
                    const col = Math.round(canvasX / this.cellSize) - 1;
                    const row = Math.round(canvasY / this.cellSize) - 1;

                    if (this.isValidMove(row, col)) {
                        this.makeMove(row, col);
                    }
                };

                // æ·»åŠ æ–°çš„ç›‘å¬å™¨
                this.canvas.addEventListener('click', this.clickHandler);
            }

            isValidMove(row, col) {
                if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
                    return false;
                }
                return this.board[row][col] === 0;
            }

            makeMove(row, col) {
                // ç¬¬ä¸€æ­¥æ£‹æ—¶å¯åŠ¨è®¡æ—¶å™¨
                if (this.moveHistory.length === 0) {
                    this.startTimer();
                }

                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({ row, col, player: this.currentPlayer });
                this.drawBoard();

                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.stopTimer();
                    this.showWinner();
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.stopTimer();
                    this.showDraw();
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateCurrentPlayer();

                    // AIæ¨¡å¼ä¸‹ï¼Œå¦‚æœè½®åˆ°AIï¼Œè®©AIä¸‹æ£‹
                    if (this.gameMode === 'ai' && this.currentPlayer === 2) {
                        this.aiMove();
                    }
                }

                document.getElementById('undoBtn').disabled = false;
            }

            aiMove() {
                // æ›´æ”¹ 'aiThinking' çŠ¶æ€
                const aiThinkingEl = document.getElementById('aiThinking');
                aiThinkingEl.innerHTML = 'ğŸ¤– AIæ€è€ƒä¸­...';
                aiThinkingEl.style.display = 'block';

                // å»¶è¿Ÿæ‰§è¡Œï¼Œè®©"AIæ€è€ƒä¸­"æç¤ºæ˜¾ç¤ºå‡ºæ¥
                setTimeout(() => {
                    let move;

                    if (this.difficulty === 'easy') {
                        move = this.getRandomMove();
                    } else if (this.difficulty === 'medium') {
                        move = this.getMediumMove();
                    } else if (this.difficulty === 'hard') {
                        move = this.getHardMove();
                    } else if (this.difficulty === 'nightmare') {
                        move = this.getNightmareMove(); 
                    }

                    if (move) {
                        // æ›´æ”¹ 'aiThinking' çŠ¶æ€ï¼Œä½†ä¸éšè—
                        aiThinkingEl.innerHTML = 'âœ… è½®åˆ°ä½ äº†ï¼'; 
                        this.makeMove(move.row, move.col);
                    } else {
                        // ä¿åº•å¤„ç†ï¼Œé˜²æ­¢AIå¡ä½
                        aiThinkingEl.innerHTML = 'ğŸ¤” æ¸¸æˆç»“æŸ?';
                    }
                }, 500); // 0.5ç§’å»¶è¿Ÿï¼Œè®©AIçœ‹èµ·æ¥åœ¨æ€è€ƒ
            }

            // ç®€å•AIï¼šéšæœºé€‰æ‹©
            getRandomMove() {
                const emptyPositions = [];
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            emptyPositions.push({ row: i, col: j });
                        }
                    }
                }

                if (emptyPositions.length > 0) {
                    return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
                return null;
            }

            // ä¸­ç­‰AIï¼šä½¿ç”¨æ›´æ™ºèƒ½çš„è¯„åˆ† (evaluatePositionAdvanced)
            getMediumMove() {
                let bestScore = -Infinity;
                let bestMove = null;

                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            const score = this.evaluatePositionAdvanced(i, j); 
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { row: i, col: j };
                            }
                        }
                    }
                }

                return bestMove || this.getRandomMove(); 
            }

            // å›°éš¾AIï¼šæ£€æŸ¥å¿…èƒœ/å¿…é˜²
            getHardMove() {
                let bestScore = -Infinity;
                let bestMove = null;

                // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å¿…èƒœçš„ä¸€æ‰‹
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            this.board[i][j] = 2; // AIæ˜¯2
                            if (this.checkWin(i, j)) {
                                this.board[i][j] = 0; 
                                return { row: i, col: j }; 
                            }
                            this.board[i][j] = 0; 
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦éœ€è¦é˜²å®ˆï¼ˆå¯¹æ‰‹æ˜¯å¦æœ‰å¿…èƒœçš„ä¸€æ‰‹ï¼‰
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            this.board[i][j] = 1; // ç©å®¶æ˜¯1
                            if (this.checkWin(i, j)) {
                                this.board[i][j] = 0; 
                                return { row: i, col: j }; 
                            }
                            this.board[i][j] = 0; 
                        }
                    }
                }

                // å¦åˆ™é€‰æ‹©è¯„åˆ†æœ€é«˜çš„ä½ç½®
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === 0) {
                            const score = this.evaluatePositionAdvanced(i, j);
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { row: i, col: j };
                            }
                        }
                    }
                }

                return bestMove || this.getRandomMove();
            }

            // [ä¿®æ”¹ å™©æ¢¦AI.1] å™©æ¢¦AIæ€»å…¥å£
            getNightmareMove() {
                // 1. æ£€æŸ¥æ˜¯å¦æœ‰å¼€å±€å®šå¼
                const openingMove = this.getOpeningMove();
                if (openingMove) {
                    return openingMove;
                }
                
                // 2. å¦‚æœæ²¡æœ‰å®šå¼ï¼Œåˆ™è¿è¡Œ Minimax ç®—æ³•
                return this.runMinimax();
            }

            // [ä¿®æ”¹ å™©æ¢¦AI.2] æ–°å¢ï¼šå¼€å±€åº“ (å®šå¼)
            getOpeningMove() {
                // å¼€å±€å®šå¼ä»…åœ¨ 15x15 æ£‹ç›˜ï¼Œä¸”æ˜¯ AI çš„ç¬¬äºŒæ­¥æ—¶è§¦å‘ (æ€»æ­¥æ•° = 2)
                // å™©æ¢¦AIå…ˆæ‰‹ (AI=2)ï¼Œç©å®¶(1)åæ‰‹ã€‚æ€»æ­¥æ•°=1æ—¶ï¼Œç©å®¶èµ°äº†ã€‚
                if (this.boardSize !== 15 || this.moveHistory.length !== 1) {
                     return null;
                }

                const centerMove = this.moveHistory[0]; // AIçš„ç¬¬ä¸€æ­¥ (å¤©å…ƒ)
                const userMove = this.moveHistory[1];   // ä½ çš„ç¬¬ä¸€æ­¥
                
                // [BUG FIX] å™©æ¢¦æ¨¡å¼AIå…ˆæ‰‹ï¼Œå†å²è®°å½•åº”è¯¥æ˜¯1
                // æ­¤æ—¶ userMove æ˜¯ undefinedã€‚
                // æˆ‘ä»¬éœ€è¦ç­‰ç©å®¶èµ°äº† (moveHistory.length === 2)
                
                // ç©å®¶(1)é»‘ï¼ŒAI(2)ç™½ã€‚
                // å™©æ¢¦æ¨¡å¼ï¼šAI(2)å…ˆèµ°ã€‚
                if (this.boardSize !== 15 || this.moveHistory.length !== 1) {
                    // moveHistory[0] æ˜¯ AI çš„ç¬¬ä¸€æ­¥ (å¤©å…ƒ)
                    // AI éœ€è¦ç­‰å¾…ç©å®¶èµ° (moveHistory.length === 1)
                    return null;
                }
                
                const centerMove = this.moveHistory[0]; // AI (2) çš„ç¬¬ä¸€æ­¥ (å¤©å…ƒ)
                
                // ç©å®¶è¿˜æ²¡èµ°
                // å•Šï¼Œå®šå¼æ˜¯ *åº”å¯¹* ç©å®¶çš„èµ°æ³•ã€‚
                // ç©å®¶(1)å…ˆæ‰‹ (éå™©æ¢¦) -> AI(2)åº”å¯¹ (length=1)
                // AI(2)å…ˆæ‰‹ (å™©æ¢¦) -> ç©å®¶(1)åº”å¯¹ -> AI(2)å†åº”å¯¹ (length=2)
                
                if (this.difficulty === 'nightmare') {
                    // AI(2) å…ˆæ‰‹ (å¤©å…ƒ) -> Player(1) èµ° (r, c)
                    // æ­¤æ—¶ history.length = 2
                    if (this.boardSize !== 15 || this.moveHistory.length !== 2) {
                        return null;
                    }
                    
                    const centerMove = this.moveHistory[0]; // AI (2)
                    const userMove = this.moveHistory[1];   // Player (1)
                    
                    const center = Math.floor(this.boardSize / 2);
                    if (centerMove.row !== center || centerMove.col !== center) {
                        return null; // AIç¬¬ä¸€æ­¥æ²¡èµ°å¤©å…ƒï¼Œå®šå¼å¤±æ•ˆ
                    }

                    const dr = userMove.row - centerMove.row; // ç›¸å¯¹è¡Œ
                    const dc = userMove.col - centerMove.col; // ç›¸å¯¹åˆ—

                    let aiMove = null;

                    // è§„åˆ™1: ä½ èµ°åœ¨äº† "æ–œ" ä¾§ (å¦‚ (6,6), (6,8), (8,6), (8,8))
                    // AI æ‰§è¡Œ "æ°´æœˆ (Suigetsu)" å®šå¼ï¼Œèµ° "ç›´" ä¾§
                    if (Math.abs(dr) === 1 && Math.abs(dc) === 1) {
                        // ä¾‹å¦‚: ä½ èµ° (6,6) [dr=-1, dc=-1], AI èµ° (6,7) [dr=-1, dc=0]
                        aiMove = { row: centerMove.row + dr, col: centerMove.col };
                    }
                    // è§„åˆ™2: ä½ èµ°åœ¨äº† "ç›´" ä¾§ (å¦‚ (6,7), (7,6), (7,8), (8,7))
                    // AI æ‰§è¡Œ "èŠ±æœˆ (Kagetsu)" å®šå¼ï¼Œèµ° "æ–œ" ä¾§
                    else if ((Math.abs(dr) === 1 && dc === 0) || (dr === 0 && Math.abs(dc) === 1)) {
                        aiMove = { row: centerMove.row + dc, col: centerMove.col + dr };
                    }

                    if (aiMove && this.isValidMove(aiMove.row, aiMove.col)) {
                        return aiMove;
                    }
                }
                
                // éå™©æ¢¦æ¨¡å¼çš„å®šå¼ (AIåæ‰‹)
                // (æ­¤å¤„çœç•¥ï¼Œå› ä¸ºå™©æ¢¦AIæ˜¯é‡ç‚¹)

                return null;
            }


            // [ä¿®æ”¹ å™©æ¢¦AI.3] åŸæ¥çš„ getNightmareMove() é‡å‘½åä¸º runMinimax()
            // [!!! BUG FIX !!!] ä¿®æ­£äº†æ­¤å‡½æ•°çš„è¯„ä¼°é€»è¾‘
            runMinimax() {
                let bestScore = -Infinity;
                let bestMove = null;
                const validMoves = this.getValidMoves();
                
                // (AIç¬¬ä¸€æ­¥èµ°å¤©å…ƒ)
                if (validMoves.length === 1) return validMoves[0]; 

                for (let move1 of validMoves) {
                    // 1. AI å°è¯•èµ°ä¸€æ­¥
                    this.board[move1.row][move1.col] = 2; // AI (2)
                    if (this.checkWin(move1.row, move1.col)) {
                        this.board[move1.row][move1.col] = 0;
                        return move1; // ç«‹å³è·èƒœ
                    }
                    
                    // [BUG FIX.1] AIèµ°å®Œ (move1) åï¼Œç«‹åˆ»è®¡ç®—AIçš„å¾—åˆ†
                    // è¿™ä¸ªåˆ†æ•°æ˜¯åŸºäº (Board + move1) çš„çŠ¶æ€
                    // (æ—§ä»£ç æŠŠè¿™è¡Œæ”¾åœ¨äº† move2 å¾ªç¯å†…éƒ¨ï¼Œå¯¼è‡´çŠ¶æ€æ±¡æŸ“)
                    const aiScore = this.evaluatePositionAdvanced(move1.row, move1.col);
                    
                    let minOpponentScore = +Infinity;
                    const opponentValidMoves = this.getValidMoves();

                    for (let move2 of opponentValidMoves) {
                        // 2. ç©å®¶å°è¯•åº”å¯¹
                        this.board[move2.row][move2.col] = 1; // Player (1)
                        
                        let currentScore = 0;
                        if (this.checkWin(move2.row, move2.col)) {
                            // ç©å®¶çš„è¿™æ­¥æ£‹èƒ½èµ¢ï¼Œè¿™å¯¹AIæ˜¯æå·®çš„
                            currentScore = -1e9;
                        } else {
                            // [BUG FIX.2] åœ¨ (Board + move1 + move2) çš„çŠ¶æ€ä¸‹ï¼Œè®¡ç®—ç©å®¶çš„å¾—åˆ†
                            const playerScore = this.evaluatePositionAdvanced(move2.row, move2.col);
                            
                            // [BUG FIX.3] ä½¿ç”¨ä¿®æ­£åçš„åˆ†æ•°è¿›è¡Œè¯„ä¼°
                            // è¯„ä¼°ï¼šAIèµ°(move1)çš„åˆ†æ•° - ç©å®¶åº”å¯¹(move2)çš„åˆ†æ•°
                            currentScore = aiScore - playerScore * 1.5; 
                        }

                        minOpponentScore = Math.min(minOpponentScore, currentScore);
                        this.board[move2.row][move2.col] = 0; // æ’¤é”€ç©å®¶èµ°æ³•
                    }
                    
                    // minOpponentScore æ˜¯ç©å®¶æ‰€æœ‰åº”å¯¹ä¸­ï¼Œå¯¹AIæœ€ä¸åˆ©çš„åˆ†æ•°
                    // AI è¦é€‰æ‹©é‚£ä¸ª "æœ€ä¸åˆ©åˆ†æ•°" ä¾ç„¶æ˜¯ "æœ€é«˜" çš„èµ°æ³•
                    if (minOpponentScore > bestScore) {
                        bestScore = minOpponentScore;
                        bestMove = move1;
                    }

                    this.board[move1.row][move1.col] = 0; // æ’¤é”€AIèµ°æ³•
                }
                
                return bestMove || this.getRandomMove(); // ä¿åº•
            }

            // è·å–AIçš„æœ‰æ•ˆæœç´¢èŒƒå›´
            getValidMoves() {
                const moveSet = new Set();
                const center = Math.floor(this.boardSize / 2);

                if (this.moveHistory.length === 0) {
                    return [{ row: center, col: center }];
                }
                
                const radius = 2; // åªæœç´¢æ£‹å­å‘¨å›´2æ ¼
                for (let r = 0; r < this.boardSize; r++) {
                    for (let c = 0; c < this.boardSize; c++) {
                        if (this.board[r][c] === 0) continue; // åªå…³å¿ƒæœ‰æ£‹å­çš„åœ°æ–¹

                        // éå†å‘¨å›´ (r-2, c-2) åˆ° (r+2, c+2)
                        for (let dr = -radius; dr <= radius; dr++) {
                            for (let dc = -radius; dc <= radius; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr;
                                const nc = c + dc;
                                
                                if (nr >= 0 && nr < this.boardSize && 
                                    nc >= 0 && nc < this.boardSize && 
                                    this.board[nr][nc] === 0) 
                                {
                                    moveSet.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
                
                // Set è½¬ä¸º Array
                return Array.from(moveSet).map(s => {
                    const [row, col] = s.split(',').map(Number);
                    return { row, col };
                });
            }


            // é«˜çº§è¯„åˆ†å‡½æ•° (è°ƒæ•´æƒé‡)
            evaluatePositionAdvanced(row, col) {
                let score = 0;
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

                for (let [dr, dc] of directions) {
                    const aiScore = this.evaluateLine(row, col, dr, dc, 2);
                    const playerScore = this.evaluateLine(row, col, dr, dc, 1);
                    score += aiScore + (playerScore * 1.1); 
                }

                // ä¸­å¿ƒä½ç½®åŠ åˆ†
                const center = Math.floor(this.boardSize / 2);
                const distToCenter = Math.abs(row - center) + Math.abs(col - center);
                score += (this.boardSize - distToCenter) * 0.5;

                return score;
            }

            // è¯„ä¼°æŸä¸ªæ–¹å‘ä¸Šçš„è¿ç æƒ…å†µ (é‡å†™æ­¤å‡½æ•°ä»¥æé«˜AI)
            evaluateLine(row, col, dr, dc, player) {
                let count = 0; // è¿ç»­çš„å·±æ–¹æ£‹å­
                let blocks = 0; // è¢«å°å µçš„ç«¯ç‚¹ (è¾¹ç•Œæˆ–å¯¹æ–¹æ£‹å­)
                
                // æ‰«ææ­£æ–¹å‘
                for (let i = 1; i <= 4; i++) {
                    const r = row + dr * i;
                    const c = col + dc * i;
                    if (r < 0 || r >= this.boardSize || c < 0 || c >= this.boardSize) {
                        blocks++;
                        break;
                    }
                    if (this.board[r][c] === player) {
                        count++;
                    } else if (this.board[r][c] === 0) {
                        break; 
                    } else {
                        blocks++; 
                        break;
                    }
                }

                // æ‰«æåæ–¹å‘
                for (let i = 1; i <= 4; i++) {
                    const r = row - dr * i;
                    const c = col - dc * i;
                    if (r < 0 || r >= this.boardSize || c < 0 || c >= this.boardSize) {
                        blocks++;
                        break;
                    }
                    if (this.board[r][c] === player) {
                        count++;
                    } else if (this.board[r][c] === 0) {
                        break; 
                    } else {
                        blocks++; 
                        break;
                    }
                }

                if (count >= 4) return 500000; // (è½å­å) æˆäº”
                if (count === 3 && blocks === 0) return 50000; // (è½å­å) æ´»å››
                if (count === 3 && blocks === 1) return 5000;  // (è½å­å) å†²å››
                if (count === 2 && blocks === 0) return 5000;  // (è½å­å) æ´»ä¸‰
                if (count === 2 && blocks === 1) return 100;   // (è½å­å) çœ ä¸‰
                if (count === 1 && blocks === 0) return 10;    // (è½å­å) æ´»äºŒ

                return count;
            }


            checkWin(row, col) {
                const directions = [
                    [0, 1],  // æ¨ªå‘
                    [1, 0],  // çºµå‘
                    [1, 1],  // å³ä¸‹æ–œ
                    [1, -1]  // å·¦ä¸‹æ–œ
                ];

                const player = this.board[row][col];

                for (let [dr, dc] of directions) {
                    let count = 1;
                    // æ­£æ–¹å‘
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        r += dr;
                        c += dc;
                    }
                    // åæ–¹å‘
                    r = row - dr;
                    c = col - dc;
                    while (r >= 0 && r < this.boardSize && c >= 0 && c < this.boardSize &&
                           this.board[r][c] === player) {
                        count++;
                        r -= dr;
                        c -= dc;
                    }
                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            isBoardFull() {
                for (let row of this.board) {
                    if (row.includes(0)) {
                        return false;
                    }
                }
                return true;
            }

            updateCurrentPlayer() {
                let playerText;
                if (this.gameMode === 'pvp') {
                    playerText = this.currentPlayer === 1
                        ? '<span class="player-black">â— é»‘æ£‹</span>'
                        : '<span class="player-white">â—‹ ç™½æ£‹</span>';
                } else {
                    playerText = this.currentPlayer === 1
                        ? '<span class="player-black">â— ä½ ï¼ˆé»‘æ£‹ï¼‰</span>'
                        : '<span class="player-white">â—‹ AIï¼ˆç™½æ£‹ï¼‰</span>';
                }
                document.getElementById('currentPlayer').innerHTML = 'å½“å‰ç©å®¶ï¼š' + playerText;
            }

            showWinner() {
                let playerName;
                if (this.gameMode === 'pvp') {
                    playerName = this.winner === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
                } else {
                    playerName = this.winner === 1 ? 'ä½ ' : 'AI';
                }

                const message = document.getElementById('winnerMessage');
                const timeStr = this.formatTime(this.elapsedTime);
                let messageText = `ğŸ‰ æ­å–œï¼${playerName} è·èƒœï¼`;

                if (this.gameMode === 'ai' && this.winner === 1) {
                    messageText += `<br>â±ï¸ ç”¨æ—¶ï¼š${timeStr}`;
                    const bestTimeKey = `bestTime_${this.difficulty}_${this.boardSize}`;
                    const currentBest = localStorage.getItem(bestTimeKey);

                    if (!currentBest || this.elapsedTime < parseInt(currentBest)) {
                        localStorage.setItem(bestTimeKey, this.elapsedTime);
                        this.loadBestTime();
                        messageText += `<br>ğŸ† æ–°çºªå½•ï¼`;
                    }
                }

                message.innerHTML = messageText;
                message.className = 'winner-message show';
                message.style.color = this.winner === 1 ? '#000' : '#666';
            }

            showDraw() {
                const message = document.getElementById('winnerMessage');
                message.innerHTML = 'ğŸ¤ å¹³å±€ï¼æ£‹ç›˜å·²æ»¡';
                message.className = 'winner-message show';
                message.style.color = '#ff9800';
            }

            undo() {
                if (this.moveHistory.length === 0) {
                    return false;
                }
                const steps = this.gameMode === 'ai' ? 2 : 1;
                for (let i = 0; i < steps && this.moveHistory.length > 0; i++) {
                    const lastMove = this.moveHistory.pop();
                    this.board[lastMove.row][lastMove.col] = 0;
                    this.currentPlayer = lastMove.player;
                }
                this.gameOver = false;
                this.winner = null;
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                this.drawBoard();
                this.updateCurrentPlayer();

                if (this.moveHistory.length === 0) {
                    this.stopTimer();
                    this.elapsedTime = 0;
                    this.updateTimerDisplay();
                    document.getElementById('undoBtn').disabled = true;
                } else {
                    if (!this.timerInterval) {
                        this.startTimer();
                    }
                }
                return true;
            }

            // å†…éƒ¨é‡ç½®æ–¹æ³•
            _internalReset() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; // é»˜è®¤æ€»æ˜¯ç©å®¶1å…ˆæ‰‹
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.stopTimer();
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                document.getElementById('winnerMessage').className = 'winner-message';
                document.getElementById('aiThinking').style.display = 'none';
                document.getElementById('undoBtn').disabled = true;
                this.drawBoard();
                this.updateCurrentPlayer();
            }
            
            // å¼€å§‹æ–°æ¸¸æˆï¼ˆå¤„ç†AIå…ˆæ‰‹ï¼‰
            startNewGame(aiGoesFirst = false) {
                this._internalReset();
                
                if (aiGoesFirst && this.gameMode === 'ai') {
                    // [ä¿®æ”¹ å™©æ¢¦AI.4] åšæŒï¼šPlayer=1(é»‘), AI=2(ç™½)ã€‚
                    // å™©æ¢¦éš¾åº¦ä¸‹ï¼ŒAI(2) å…ˆæ‰‹ã€‚
                    this.currentPlayer = 2; // AI å…ˆæ‰‹
                    this.updateCurrentPlayer(); // æ›´æ–°UI
                    this.aiMove(); // AI ä¸‹ç¬¬ä¸€æ­¥
                }
            }


            // è®¡æ—¶å™¨ç›¸å…³æ–¹æ³•
            startTimer() {
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    this.elapsedTime = Date.now() - this.startTime;
                    this.updateTimerDisplay();
                }, 100); 
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimerDisplay() {
                const timeStr = this.formatTime(this.elapsedTime);
                document.getElementById('currentTime').textContent = timeStr;
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            loadBestTime() {
                const bestTimeKey = `bestTime_${this.difficulty}_${this.boardSize}`;
                const bestTime = localStorage.getItem(bestTimeKey);

                if (bestTime) {
                    const timeStr = this.formatTime(parseInt(bestTime));
                    document.getElementById('bestTime').textContent = timeStr;
                } else {
                    document.getElementById('bestTime').textContent = '--:--';
                }
            }
        }

        // å…¨å±€æ¸¸æˆå®ä¾‹ (é»˜è®¤è¿˜æ˜¯ 'hard')
        // [ä¿®æ”¹ å™©æ¢¦AI.5] ä¿®æ­£äº† setGameMode å’Œ setDifficulty çš„äº‹ä»¶å¤„ç†
        let game = new GomokuGame(15, 'ai', 'hard');

        function setGameMode(mode) { 
            game.gameMode = mode;
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // æ‰¾åˆ°ç‚¹å‡»çš„æŒ‰é’®å¹¶æ¿€æ´»
            // ä¿®æ­£ï¼šä»å…¨å±€ event åˆ‡æ¢åˆ°æŸ¥è¯¢
            document.querySelector(`.mode-btn[onclick="setGameMode('${mode}')"]`).classList.add('active'); 

            if (mode === 'ai') {
                document.getElementById('difficultySelector').style.display = 'flex';
            } else {
                document.getElementById('difficultySelector').style.display = 'none';
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨å™©æ¢¦éš¾åº¦ä¸‹åˆ‡æ¢åˆ°AIæ¨¡å¼
            game.startNewGame(mode === 'ai' && game.difficulty === 'nightmare');
            game.loadBestTime();
        }

        function setDifficulty(difficulty, event) { 
            game.difficulty = difficulty;
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active'); 
            
            // [ä¿®æ”¹ å™©æ¢¦AI.6] è°ƒæ•´è§„åˆ™æ–‡æœ¬
            const instructions = document.querySelector('.instructions ul');
            const aiRule = instructions.children[3]; // 'AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹å…ˆè¡Œ'
            
            if (difficulty === 'nightmare') {
                // [BUG FIX.4] ä¿®æ­£å™©æ¢¦æ¨¡å¼çš„è§„åˆ™æ–‡æœ¬
                aiRule.innerHTML = 'ğŸ˜± <b>å™©æ¢¦æ¨¡å¼</b>: AIæ‰§ç™½æ£‹ (2) å…ˆè¡Œï¼Œä½ æ‰§é»‘æ£‹ (1)';
            } else {
                aiRule.innerHTML = 'AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹ (1) å…ˆè¡Œï¼ŒAIæ‰§ç™½æ£‹ (2)';
            }

            // æ£€æŸ¥æ˜¯å¦åˆ‡æ¢åˆ°å™©æ¢¦éš¾åº¦
            game.startNewGame(difficulty === 'nightmare');
            game.loadBestTime();
        }

        function undoMove() {
            game.undo();
        }

        function restartGame() {
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                // é‡æ–°å¼€å§‹æ—¶ï¼Œä¿æŒå½“å‰éš¾åº¦ï¼ˆåŒ…æ‹¬å™©æ¢¦AIå…ˆæ‰‹ï¼‰
                game.startNewGame(game.difficulty === 'nightmare');
            }
        }

        function changeBoardSize() {
            const sizes = [9, 13, 15, 19];
            const sizeNames = ['9è·¯ï¼ˆå¿«é€Ÿï¼‰', '13è·¯ï¼ˆä¸­ç­‰ï¼‰', '15è·¯ï¼ˆæ ‡å‡†ï¼‰', '19è·¯ï¼ˆå›´æ£‹ï¼‰'];

            let message = `å½“å‰æ£‹ç›˜å¤§å°: ${game.boardSize}x${game.boardSize}\n\né€‰æ‹©æ–°çš„æ£‹ç›˜å¤§å°ï¼š\n`;
            sizes.forEach((size, index) => {
                message += `${index + 1}. ${sizeNames[index]}\n`;
            });
            
            const currentSizeIndex = sizes.indexOf(game.boardSize);
            const defaultChoice = currentSizeIndex !== -1 ? currentSizeIndex + 1 : 3;
            const choice = prompt(message + '\nè¯·è¾“å…¥åºå·ï¼ˆ1-4ï¼‰ï¼š', defaultChoice);
            
            const index = parseInt(choice) - 1;

            if (index >= 0 && index < sizes.length) {
                // é‡æ–°åˆ›å»ºæ¸¸æˆå®ä¾‹
                const oldDifficulty = game.difficulty;
                const oldMode = game.gameMode;
                
                // é”€æ¯æ—§å®ä¾‹çš„è®¡æ—¶å™¨
                game.stopTimer(); 
                
                game = new GomokuGame(sizes[index], oldMode, oldDifficulty);
                
                // é‡æ–°åº”ç”¨æŒ‰é’®æ¿€æ´»çŠ¶æ€ (ç®€å•åŒ¹é…)
                document.querySelectorAll('.diff-btn').forEach(btn => {
                   if (btn.onclick.toString().includes(`'${oldDifficulty}'`)) {
                       btn.classList.add('active');
                   } else {
                       btn.classList.remove('active');
                   }
                });
                
                // æ”¹å˜æ£‹ç›˜å¤§å°åä¹Ÿè¦æ£€æŸ¥AIå…ˆæ‰‹
                game.startNewGame(oldDifficulty === 'nightmare');
            }
        }

        // åˆå§‹åŒ–
        document.getElementById('undoBtn').disabled = true;
        
        // [ä¿®æ”¹ å™©æ¢¦AI.7] é¡µé¢åŠ è½½æ—¶ï¼Œæ‰‹åŠ¨è®¾ç½®ä¸€æ¬¡ "å›°éš¾" æŒ‰é’®çš„ active çŠ¶æ€å’Œè§„åˆ™æ–‡æœ¬
        document.querySelector('.diff-btn[onclick*="\'hard\'"]').classList.add('active');
        const instructions = document.querySelector('.instructions ul');
        // [BUG FIX.5] ç¡®ä¿åˆå§‹è§„åˆ™æ–‡æœ¬æ­£ç¡®
        instructions.children[3].innerHTML = 'AIå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œä½ æ‰§é»‘æ£‹ (1) å…ˆè¡Œï¼ŒAIæ‰§ç™½æ£‹ (2)';
        
        // [ä¿®æ”¹ å™©æ¢¦AI.8] ä¿®æ­£ setGameMode çš„è°ƒç”¨æ–¹å¼
        // (åŸä»£ç åœ¨ event ä¼ é€’ä¸Šæœ‰é—®é¢˜ï¼Œä¿®æ”¹ä¸ºæ˜¾å¼ä¼ é€’å‚æ•°)
        document.querySelectorAll('.mode-btn').forEach(btn => {
            const mode = btn.onclick.toString().match(/'(.*?)'/)[1];
            // é‡æ–°ç»‘å®šï¼Œç¡®ä¿ event å¯¹è±¡æ˜¯ setDifficulty å‡½æ•°çš„ï¼Œè€Œä¸æ˜¯è¿™é‡Œçš„
            btn.onclick = (event) => setGameMode(mode); 
        });

    </script>
</body>
</html>
